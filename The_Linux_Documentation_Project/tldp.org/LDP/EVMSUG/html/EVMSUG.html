<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
>
<!-- Mirrored from tldp.org/LDP/EVMSUG/html/EVMSUG.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 23 Oct 2018 23:53:35 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=ISO-8859-1" /><!-- /Added by HTTrack -->
<HEAD
><TITLE
>EVMS User Guide</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"></HEAD
><BODY
CLASS="book"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="evmsug"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN2"
></A
>EVMS User Guide</H1
><H3
CLASS="author"
><A
NAME="AEN5"
></A
>Christine Lorenz</H3
><DIV
CLASS="affiliation"
><SPAN
CLASS="orgname"
>IBM<BR></SPAN
></DIV
><H3
CLASS="author"
><A
NAME="AEN10"
></A
>Joy Goodreau</H3
><DIV
CLASS="affiliation"
><SPAN
CLASS="orgname"
>IBM<BR></SPAN
></DIV
><H3
CLASS="author"
><A
NAME="AEN15"
></A
>Kylie Smith</H3
><DIV
CLASS="affiliation"
><SPAN
CLASS="orgname"
>IBM<BR></SPAN
></DIV
><P
CLASS="copyright"
>Copyright &copy; 2004 IBM</P
><P
CLASS="pubdate"
>September 16, 2004<BR></P
><DIV
CLASS="legalnotice"
><A
NAME="AEN24"
></A
><P
><B
>Special Notices</B
></P
><P
>The following terms are registered trademarks of International Business Machines corporation in the United States and/or other countries:  AIX, OS/2, System/390.  A full list of U.S. trademarks owned by IBM may be found at <A
HREF="http://www.ibm.com/legal/copytrade.shtml"
TARGET="_top"
>http://www.ibm.com/legal/copytrade.shtml</A
>.</P
><P
>Intel is a trademark or registered trademark of Intel Corporation in the United States, other countries, or both.</P
><P
>Windows is a trademark of Microsoft Corporation in the United States, other countries, or both. </P
><P
> Linux is a trademark of Linus Torvalds. </P
><P
>UNIX is a registered trademark of The Open Group in the United States and other countries.</P
><P
>Other company, product, and service names may be trademarks or service marks of others.</P
><P
>This document is provided "AS IS," with no express or implied warranties. Use the information in this document at your own risk. </P
></DIV
><DIV
CLASS="legalnotice"
><A
NAME="AEN34"
></A
><P
><B
>License Information</B
></P
><P
>This document may be reproduced or distributed in any form without prior permission provided the copyright notice is retained on all copies. Modified versions of this document may be freely distributed provided that they are clearly identified as such, and this copyright is included intact. </P
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#userguidepref"
>Preface</A
></DT
><DT
>1. <A
HREF="#intro"
>What is EVMS?</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#cando"
>Why choose EVMS?</A
></DT
><DT
>1.2. <A
HREF="#uis"
>The EVMS user interfaces</A
></DT
><DT
>1.3. <A
HREF="#terminology"
>EVMS terminology</A
></DT
><DT
>1.4. <A
HREF="#AEN262"
>What makes EVMS so flexible?</A
></DT
><DT
>1.5. <A
HREF="#LAYERDEF"
>Plug-in layer definitions</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#evmscmuse"
>Using the EVMS interfaces</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#GUI"
>EVMS GUI</A
></DT
><DT
>2.2. <A
HREF="#NCURSES"
>EVMS Ncurses interface</A
></DT
><DT
>2.3. <A
HREF="#COMMANDLINE"
>EVMS Command Line Interpreter</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#debuglevels"
>The EVMS log file and error data collection</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#FSIMsupp"
>About the EVMS log file</A
></DT
><DT
>3.2. <A
HREF="#loglevels"
>Log file logging levels</A
></DT
><DT
>3.3. <A
HREF="#specifylevels"
>Specifying the logging levels</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#evmsmigrate"
>Viewing compatibility volumes after migrating</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#guimigrate"
>Using the EVMS GUI</A
></DT
><DT
>4.2. <A
HREF="#ncurmigrate"
>Using Ncurses</A
></DT
><DT
>4.3. <A
HREF="#climigrate"
>Using the CLI</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#displaydetails"
>Obtaining interface display details</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#displaygui"
>Using the EVMS GUI</A
></DT
><DT
>5.2. <A
HREF="#displaydatancurses"
>Using Ncurses</A
></DT
><DT
>5.3. <A
HREF="#AEN812"
>Using the CLI</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#evmsassignseg"
>Adding and removing a segment manager</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#whenassign"
>When to add a segment manager</A
></DT
><DT
>6.2. <A
HREF="#smtypes"
>Types of segment managers</A
></DT
><DT
>6.3. <A
HREF="#assignsegex"
>Adding a segment manager to an existing disk</A
></DT
><DT
>6.4. <A
HREF="#assignsegnew"
>Adding a segment manager to a new disk</A
></DT
><DT
>6.5. <A
HREF="#assignex"
>Example: add a segment manager</A
></DT
><DT
>6.6. <A
HREF="#removeseg"
>Removing a segment manager</A
></DT
><DT
>6.7. <A
HREF="#rmvex"
>Example: remove a segment manager</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#evmscreateseg"
>Creating segments</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#whyseg"
>When to create a segment</A
></DT
><DT
>7.2. <A
HREF="#crsegex"
>Example: create a segment</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#evmscreatecont"
>Creating a container</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#whencont"
>When to create a container</A
></DT
><DT
>8.2. <A
HREF="#contex"
>Example: create a container</A
></DT
></DL
></DD
><DT
>9. <A
HREF="#evmscreatereg"
>Creating regions</A
></DT
><DD
><DL
><DT
>9.1. <A
HREF="#AEN1320"
>When to create regions</A
></DT
><DT
>9.2. <A
HREF="#crregex"
>Example: create a region</A
></DT
></DL
></DD
><DT
>10. <A
HREF="#evmscreatedrivelinking"
>Creating drive links</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#whatisdrivelinking"
>What is drive linking?</A
></DT
><DT
>10.2. <A
HREF="#howimp"
>How drive linking is implemented</A
></DT
><DT
>10.3. <A
HREF="#AEN1453"
>Creating a drive link</A
></DT
><DT
>10.4. <A
HREF="#drivelinkex"
>Example: create a drive link</A
></DT
><DT
>10.5. <A
HREF="#expandpartitions"
>Expanding a drive link</A
></DT
><DT
>10.6. <A
HREF="#shrinkdrivelink"
>Shrinking a drive link</A
></DT
><DT
>10.7. <A
HREF="#deletedrivelink"
>Deleting a drive link</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#evmscreatesnap"
>Creating snapshots</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#whatissnapshotting"
>What is a snapshot?</A
></DT
><DT
>11.2. <A
HREF="#createactivsnap"
>Creating snapshot objects</A
></DT
><DT
>11.3. <A
HREF="#snapshotex"
>Example: create a snapshot</A
></DT
><DT
>11.4. <A
HREF="#AEN1717"
>Reinitializing a snapshot</A
></DT
><DT
>11.5. <A
HREF="#AEN1775"
>Expanding a snapshot</A
></DT
><DT
>11.6. <A
HREF="#AEN1843"
>Deleting a snapshot</A
></DT
><DT
>11.7. <A
HREF="#AEN1847"
>Rolling back a snapshot</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#evmscreatevol"
>Creating volumes</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="#AEN1913"
>When to create a volume</A
></DT
><DT
>12.2. <A
HREF="#crvolexcomp"
>Example: create an EVMS native volume</A
></DT
><DT
>12.3. <A
HREF="#crvolexevms"
>Example: create a compatibility volume</A
></DT
></DL
></DD
><DT
>13. <A
HREF="#evmsfsimops"
>FSIMs and file system operations</A
></DT
><DD
><DL
><DT
>13.1. <A
HREF="#FSIMsuppevms"
>The FSIMs supported by EVMS</A
></DT
><DT
>13.2. <A
HREF="#fsimmkfs"
>Example: add a file system to a volume</A
></DT
><DT
>13.3. <A
HREF="#fsimmkfsaex"
>Example: check a file system</A
></DT
></DL
></DD
><DT
>14. <A
HREF="#clusterops"
>Clustering operations</A
></DT
><DD
><DL
><DT
>14.1. <A
HREF="#AEN2372"
>Rules and restrictions for creating cluster containers</A
></DT
><DT
>14.2. <A
HREF="#AEN2382"
>Example: create a private cluster container</A
></DT
><DT
>14.3. <A
HREF="#AEN2496"
>Example: create a shared cluster container</A
></DT
><DT
>14.4. <A
HREF="#AEN2604"
>Example: convert a private container to a shared container</A
></DT
><DT
>14.5. <A
HREF="#AEN2688"
>Example: convert a shared container to a private container</A
></DT
><DT
>14.6. <A
HREF="#AEN2773"
>Example: deport a private or shared container</A
></DT
><DT
>14.7. <A
HREF="#AEN2849"
>Deleting a cluster container</A
></DT
><DT
>14.8. <A
HREF="#AEN2853"
>Failover and Failback of a private container on Linux-HA</A
></DT
><DT
>14.9. <A
HREF="#AEN2896"
>Remote configuration management</A
></DT
><DT
>14.10. <A
HREF="#AEN2946"
>Forcing a cluster container to be active</A
></DT
></DL
></DD
><DT
>15. <A
HREF="#evmsconvert"
>Converting volumes</A
></DT
><DD
><DL
><DT
>15.1. <A
HREF="#AEN2974"
>When to convert volumes</A
></DT
><DT
>15.2. <A
HREF="#comptoevms"
>Example: convert compatibility volumes to EVMS volumes</A
></DT
><DT
>15.3. <A
HREF="#evmstocomp"
>Example: convert EVMS volumes to compatibility volumes</A
></DT
></DL
></DD
><DT
>16. <A
HREF="#expandshrink"
>Expanding and shrinking volumes</A
></DT
><DD
><DL
><DT
>16.1. <A
HREF="#whyexpandshrink"
>Why expand and shrink volumes?</A
></DT
><DT
>16.2. <A
HREF="#exshrink"
>Example: shrink a volume</A
></DT
><DT
>16.3. <A
HREF="#mkfs"
>Example: expand a volume</A
></DT
></DL
></DD
><DT
>17. <A
HREF="#addfeatures"
>Adding features to an existing volume</A
></DT
><DD
><DL
><DT
>17.1. <A
HREF="#whyadd"
>Why add features to a volume?</A
></DT
><DT
>17.2. <A
HREF="#exaddfeature"
>Example: add drive linking to an existing volume</A
></DT
></DL
></DD
><DT
>18. <A
HREF="#selectact"
>Selectively activating volumes and objects</A
></DT
><DD
><DL
><DT
>18.1. <A
HREF="#initialactivation"
>Initial activation using /etc/evms.conf</A
></DT
><DT
>18.2. <A
HREF="#AEN3528"
>Activating and deactivating volumes and objects</A
></DT
></DL
></DD
><DT
>19. <A
HREF="#mountunmount"
>Mounting and unmounting volumes from within EVMS</A
></DT
><DD
><DL
><DT
>19.1. <A
HREF="#mntvol"
>Mounting a volume</A
></DT
><DT
>19.2. <A
HREF="#AEN3804"
>Unmounting a volume</A
></DT
><DT
>19.3. <A
HREF="#AEN3863"
>The SWAPFS file system</A
></DT
></DL
></DD
><DT
>20. <A
HREF="#plugintasks"
>Plug-in operations tasks</A
></DT
><DD
><DL
><DT
>20.1. <A
HREF="#aboutplugintasks"
>What are plug-in tasks?</A
></DT
><DT
>20.2. <A
HREF="#pluginexample"
>Example: complete a plug-in operations task</A
></DT
></DL
></DD
><DT
>21. <A
HREF="#deleterecurs"
>Deleting objects</A
></DT
><DD
><DL
><DT
>21.1. <A
HREF="#howtodel"
>How to delete objects: delete and delete recursive</A
></DT
><DT
>21.2. <A
HREF="#examdelrecur"
>Example: perform a delete recursive operation</A
></DT
></DL
></DD
><DT
>22. <A
HREF="#evmsreplaceobjects"
>Replacing objects</A
></DT
><DD
><DL
><DT
>22.1. <A
HREF="#whatisobjectreplace"
>What is object-replace?</A
></DT
><DT
>22.2. <A
HREF="#replacedlchildobj"
>Replacing a drive-link child object</A
></DT
></DL
></DD
><DT
>23. <A
HREF="#segstorobjs"
>Moving segment storage objects</A
></DT
><DD
><DL
><DT
>23.1. <A
HREF="#segmovewhatis"
>What is segment moving?</A
></DT
><DT
>23.2. <A
HREF="#whymove"
>Why move a segment?</A
></DT
><DT
>23.3. <A
HREF="#AEN4331"
>Which segment manager plug-ins implement the move function?</A
></DT
><DT
>23.4. <A
HREF="#movesegex"
>Example: move a DOS segment</A
></DT
></DL
></DD
><DT
>A. <A
HREF="#appxdos"
>The DOS plug-in</A
></DT
><DD
><DL
><DT
>A.1. <A
HREF="#DOShow"
>How the DOS plug-in is implemented</A
></DT
><DT
>A.2. <A
HREF="#assignDOS"
>Assigning the DOS plug-in</A
></DT
><DT
>A.3. <A
HREF="#creatingDOS"
>Creating DOS partitions</A
></DT
><DT
>A.4. <A
HREF="#expandDOS"
>Expanding DOS partitions</A
></DT
><DT
>A.5. <A
HREF="#shrinkDOS"
>Shrinking DOS partitions</A
></DT
><DT
>A.6. <A
HREF="#deleteDOS"
>Deleting partitions</A
></DT
></DL
></DD
><DT
>B. <A
HREF="#appxmdreg"
>The MD region manager</A
></DT
><DD
><DL
><DT
>B.1. <A
HREF="#characraidlvls"
>Characteristics of Linux RAID levels</A
></DT
><DT
>B.2. <A
HREF="#createmdreg"
>Creating an MD region</A
></DT
><DT
>B.3. <A
HREF="#activepsareobjs"
>Active and spare objects</A
></DT
><DT
>B.4. <A
HREF="#faultobjs"
>Faulty objects</A
></DT
><DT
>B.5. <A
HREF="#resizemdreg"
>Resizing MD regions</A
></DT
><DT
>B.6. <A
HREF="#replaceobjs"
>Replacing objects</A
></DT
></DL
></DD
><DT
>C. <A
HREF="#appxlvm"
>The LVM plug-in</A
></DT
><DD
><DL
><DT
>C.1. <A
HREF="#lvmimp"
>How LVM is implemented</A
></DT
><DT
>C.2. <A
HREF="#containerops"
>Container operations</A
></DT
><DT
>C.3. <A
HREF="#AEN4759"
>Region operations</A
></DT
></DL
></DD
><DT
>D. <A
HREF="#appxlvm2"
>The LVM2 plug-in</A
></DT
><DD
><DL
><DT
>D.1. <A
HREF="#contops"
>Container operations</A
></DT
><DT
>D.2. <A
HREF="#regionops"
>Region operations</A
></DT
></DL
></DD
><DT
>E. <A
HREF="#appxcsm"
>The CSM plug-in</A
></DT
><DD
><DL
><DT
>E.1. <A
HREF="#csmassn"
>Assigning the CSM plug-in</A
></DT
><DT
>E.2. <A
HREF="#unassignCSM"
>Unassigning the CSM plug-in</A
></DT
><DT
>E.3. <A
HREF="#AEN5078"
>Deleting a CSM container</A
></DT
></DL
></DD
><DT
>F. <A
HREF="#jfsfsim"
>JFS file system interface module</A
></DT
><DD
><DL
><DT
>F.1. <A
HREF="#createjfsfsim"
>Creating JFS file systems</A
></DT
><DT
>F.2. <A
HREF="#checkjfsfsim"
>Checking JFS file systems</A
></DT
><DT
>F.3. <A
HREF="#removejfsfsim"
>Removing JFS file systems</A
></DT
><DT
>F.4. <A
HREF="#expandjfsfsim"
>Expanding JFS file systems</A
></DT
><DT
>F.5. <A
HREF="#shrinkjfsfsim"
>Shrinking JFS file systems</A
></DT
></DL
></DD
><DT
>G. <A
HREF="#xfsfsim"
>XFS file system interface module</A
></DT
><DD
><DL
><DT
>G.1. <A
HREF="#createxfsfsim"
>Creating XFS file systems</A
></DT
><DT
>G.2. <A
HREF="#checkxfsfsim"
>Checking XFS file systems</A
></DT
><DT
>G.3. <A
HREF="#removexfsfsim"
>Removing XFS file systems</A
></DT
><DT
>G.4. <A
HREF="#expandxfsfsim"
>Expanding XFS file systems</A
></DT
><DT
>G.5. <A
HREF="#shrinkxfsfsim"
>Shrinking XFS file systems</A
></DT
></DL
></DD
><DT
>H. <A
HREF="#reiserfsim"
>ReiserFS file system interface module</A
></DT
><DD
><DL
><DT
>H.1. <A
HREF="#createreiserfsim"
>Creating ReiserFS file systems</A
></DT
><DT
>H.2. <A
HREF="#checkreiserfsim"
>Checking ReiserFS file systems</A
></DT
><DT
>H.3. <A
HREF="#removexreiserfsim"
>Removing ReiserFS file systems</A
></DT
><DT
>H.4. <A
HREF="#expandreiserFSfsim"
>Expanding ReiserFS file systems</A
></DT
><DT
>H.5. <A
HREF="#shrinkreiserfsim"
>Shrinking ReiserFS file systems</A
></DT
></DL
></DD
><DT
>I. <A
HREF="#ext23fsim"
>Ext-2/3 file system interface module</A
></DT
><DD
><DL
><DT
>I.1. <A
HREF="#createext23fsim"
>Creating Ext-2/3 file systems</A
></DT
><DT
>I.2. <A
HREF="#checkext23fsim"
>Checking Ext-2/3 file systems</A
></DT
><DT
>I.3. <A
HREF="#removeext23fsim"
>Removing Ext-2/3 file systems</A
></DT
><DT
>I.4. <A
HREF="#expandshrinkext23fsim"
>Expanding and shrinking Ext-2/3 
file systems</A
></DT
></DL
></DD
><DT
>J. <A
HREF="#gfsfsim"
>OpenGFS file system interface module</A
></DT
><DD
><DL
><DT
>J.1. <A
HREF="#createopengfsfsim"
>Creating OpenGFS file systems</A
></DT
><DT
>J.2. <A
HREF="#checkopengfsfsim"
>Checking OpenGFS file systems</A
></DT
><DT
>J.3. <A
HREF="#removeopengfsfsim"
>Removing OpenGFS file systems</A
></DT
><DT
>J.4. <A
HREF="#expandshrinkopengfsfsim"
>Expanding and shrinking OpenGFS
file systems</A
></DT
></DL
></DD
><DT
>K. <A
HREF="#ntfsfsim"
>NTFS file system interface module</A
></DT
><DD
><DL
><DT
>K.1. <A
HREF="#createntfsfsim"
>Creating NTFS file systems</A
></DT
><DT
>K.2. <A
HREF="#fixntfsfsim"
>Fixing NTFS file systems</A
></DT
><DT
>K.3. <A
HREF="#clonentfsfsim"
>Cloning NTFS file systems</A
></DT
><DT
>K.4. <A
HREF="#removentfsfsim"
>Removing NTFS file systems</A
></DT
><DT
>K.5. <A
HREF="#expandshrinkntfsfsim"
>Expanding and shrinking NTFS
file systems</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Tables</B
></DT
><DT
>1. <A
HREF="#bookorg"
>Organization of the EVMS User Guide</A
></DT
><DT
>1-1. <A
HREF="#userinterf"
>EVMS user interfaces</A
></DT
><DT
>2-1. <A
HREF="#AEN370"
>Accelerator keys in the Main Window</A
></DT
><DT
>2-2. <A
HREF="#AEN384"
>Accelerator keys in the views</A
></DT
><DT
>2-3. <A
HREF="#AEN430"
>Accelerator keys in the selection window</A
></DT
><DT
>2-4. <A
HREF="#AEN454"
>Accelerator keys in the configuration options window</A
></DT
><DT
>2-5. <A
HREF="#AEN476"
>Widget navigation keys in the configuration options window</A
></DT
><DT
>3-1. <A
HREF="#AEN645"
>EVMS logging levels</A
></DT
><DT
>16-1. <A
HREF="#AEN3141"
>FSIM support for expand and shrink operations</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Figures</B
></DT
><DT
>4-1. <A
HREF="#AEN726"
>GUI start-up window</A
></DT
><DT
>4-2. <A
HREF="#AEN737"
>Ncurses start-up window</A
></DT
><DT
>4-3. <A
HREF="#AEN756"
>CLI volume query results</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Examples</B
></DT
><DT
>6-1. <A
HREF="#AEN929"
>Add the DOS Segment Manager</A
></DT
><DT
>6-2. <A
HREF="#AEN1049"
>Remove the DOS Segment Manager</A
></DT
><DT
>7-1. <A
HREF="#AEN1122"
>Create a 100MB segment</A
></DT
><DT
>8-1. <A
HREF="#AEN1231"
>Create "Sample Container"</A
></DT
><DT
>9-1. <A
HREF="#AEN1327"
>Create "Sample Region"</A
></DT
><DT
>10-1. <A
HREF="#AEN1461"
>Create a drive link</A
></DT
><DT
>11-1. <A
HREF="#AEN1607"
>Create a snapshot of a volume</A
></DT
><DT
>12-1. <A
HREF="#AEN1923"
>Create an EVMS native volume</A
></DT
><DT
>12-2. <A
HREF="#AEN2001"
>Create a compatibility volume</A
></DT
><DT
>13-1. <A
HREF="#AEN2167"
>Add a JFS File System to a Volume</A
></DT
><DT
>13-2. <A
HREF="#AEN2277"
>Check a JFS File System</A
></DT
><DT
>14-1. <A
HREF="#AEN2386"
>Create a private cluster container</A
></DT
><DT
>14-2. <A
HREF="#AEN2500"
>Create a shared cluster container</A
></DT
><DT
>14-3. <A
HREF="#AEN2608"
>Convert a private container to shared</A
></DT
><DT
>14-4. <A
HREF="#AEN2692"
>Convert a shared container to private</A
></DT
><DT
>14-5. <A
HREF="#AEN2777"
>Deport a cluster container</A
></DT
><DT
>15-1. <A
HREF="#AEN2988"
>Convert a compatibility volume</A
></DT
><DT
>15-2. <A
HREF="#AEN3066"
>Convert an EVMS volume</A
></DT
><DT
>16-1. <A
HREF="#AEN3186"
>Shrink a volume</A
></DT
><DT
>16-2. <A
HREF="#AEN3297"
>Expand a volume</A
></DT
><DT
>17-1. <A
HREF="#AEN3410"
>Add drive linking to an existing volume</A
></DT
><DT
>20-1. <A
HREF="#AEN4012"
>Add a spare disk to a compatibility volume made from an MDRaid5 region</A
></DT
><DT
>21-1. <A
HREF="#AEN4143"
>Destroy a volume and the region and container below it</A
></DT
></DL
></DIV
><DIV
CLASS="preface"
><HR><H1
><A
NAME="userguidepref"
></A
>Preface</H1
><P
>This guide tells how to configure and manage Enterprise
Volume Management System (EVMS).  EVMS is a storage management program
that provides a single framework for managing and administering your system's storage.</P
><P
>This guide is intended for Linux system administrators and users who are
responsible for setting up and maintaining EVMS.</P
><P
>For additional information about EVMS or to ask questions specific to 
your distribution, refer to the EVMS mailing lists. You can view  the list 
archives or subscribe to the lists from 
the <A
HREF="http://evms.sourceforge.net/mailinglists.html"
TARGET="_top"
>EVMS Project 
web site</A
>.</P
><P
>The following table shows how this guide is organized:</P
><DIV
CLASS="table"
><A
NAME="bookorg"
></A
><P
><B
>Table 1. Organization of the EVMS User Guide</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Chapter or appendix title</TH
><TH
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Contents</TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>1. What is EVMS?</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Discusses general EVMS concepts and terms.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>2. Using the EVMS interfaces</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Describes the three EVMS user interfaces and how to use them.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>3. The EVMS log file and error data collection</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Discusses the EVMS information and error log file and explains how to change the logging level.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>4. Viewing compatibility volumes after migrating</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Tells how to view existing files that have been migrated to EVMS.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>5. Obtaining interface display details</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Tells how to view detailed information about EVMS objects.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>6. Adding and removing a segment manager</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Discusses segments and explains how to add and remove a segment manager.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>7. Creating segments</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Explains when and how to create segments.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>8. Creating containers</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Discusses containers and explains when and how to create them.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>9. Creating regions</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Discusses regions and explains when and how to create them.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>10. Creating drive links</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Discusses the drive linking feature and tells how to create a drive link.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>11. Creating snapshots</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Discusses snapshotting and tells how to create a snapshot.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>12. Creating volumes</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Explains when and how to create volumes.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>13. FSIMs and file system operations</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Discusses the standard FSIMs shipped with EVMS and provides examples of adding file systems and coordinating file checks with the FSIMs.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>14. Clustering operations</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Describes EVMS clustering and how to create private and shared containers.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>15. Converting volumes</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Explains how to convert EVMS native volumes to compatibility volumes and compatibility volumes to EVMS native volumes.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>16. Expanding and shrinking volumes</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Tells how to expand and shrink EVMS volumes with the various EVMS user interfaces.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>17. Adding features to an existing volume</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Tells how to add additional features, such as drive linking, to an 
existing volume.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>18. Selectively activating volumes and objects</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Explains how to selectively activate and deactive volumes
and options.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>19. Mounting and unmounting volumes from within EVMS.</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Tells how to have EVMS mount and unmount volumes so you do not have to open a separate terminal session.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>20. Plug-in operations tasks</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Discusses the plug-in tasks that are available within the context of a particular plug-in.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>21. Deleting objects</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Tells how to safely delete EVMS objects.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>22. Replacing objects</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Tells how to change the 
configuration of a volume or storage object.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>23. Moving segment storage objects</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Discusses how to use
the move function for moving segments.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>A. The DOS plug-in</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Provides details about the DOS plug-in, which is a segment manager plug-in.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>B. The MD region manager</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Explains the Multiple Disks (MD) support in Linux that is a software implementation of RAID.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>C. The LVM plug-in</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Tells how the LVM plug-in is implemented and how to perform container operations.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>D. The LVM2 plug-in</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Tells how the LVM2 plug-in is implemented and how to perform container operations on
LVM2 containers.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>E. The CSM plug-in</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Explains how the Cluster Segment Manager (CSM) plug-in is implemented and how to perform CSM operations.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>F. JFS file system interface module</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Provides information about the JFS FSIM.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>G. XFS file system interface module</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Provides information about the XFS FSIM.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>H. ReiserFS file system interface module</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Provides information about the ReiserFS FSIM.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>I. Ext-2/3 file system interface module</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Provides information about the Ext-2/3 FSIM.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>J. OpenGFS file system interface module</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Provides information about the OpenGFS FSIM.</TD
></TR
><TR
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>K. NTFS file system interface module</TD
><TD
WIDTH="336"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Provides information about the NTFS FSIM.</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="intro"
></A
>Chapter 1. What is EVMS?</H1
><P
>EVMS brings a new model of volume management to Linux®. 
EVMS integrates all aspects of volume management, 
such as disk partitioning, Linux logical volume manager (LVM) and 
multi-disk (MD) management, and file system operations into a single 
cohesive package. 
With EVMS, various volume management technologies are accessible through 
one interface, and new technologies can be added as plug-ins as they are developed.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="cando"
></A
>1.1. Why choose EVMS?</H1
><P
>EVMS lets you manage storage space in a way that is more 
intuitive and flexible than many other Linux volume management systems. 
Practical tasks, such as migrating disks or adding new disks to your 
Linux system, become more manageable with EVMS because EVMS can  
recognize and read from different volume types and file systems. 
EVMS provides additional safety controls by not allowing commands that are
unsafe.
These controls help maintain the integrity of the data stored on the system.</P
><P
>You can use EVMS  to create and manage data storage. 
With EVMS, you can use multiple volume management technologies under one 
framework while ensuring your system still interacts correctly with 
stored data. 
With EVMS, you are can use drive linking, shrink and expand volumes, 
create snapshots of your volumes, and set up RAID 
(redundant array of independent devices) features for your system. 
You can also use many types of file systems and manipulate these storage pieces 
in ways that best meet the needs of your particular work environment.</P
><P
>EVMS also provides the capability to manage data on storage that is
physically shared by nodes in a cluster.  This shared storage allows data to
be highly available from different nodes in the cluster.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="uis"
></A
>1.2. The EVMS user interfaces</H1
><P
>There are currently three user interfaces available for EVMS: graphical (GUI), text mode (Ncurses), and the Command Line Interpreter (CLI). 
Additionally, you can use the EVMS Application Programming Interface to implement your own customized user interface. </P
><P
><A
HREF="#userinterf"
>Table 1-1</A
> tells more about each of the EVMS user interfaces.

</P
><DIV
CLASS="table"
><A
NAME="userinterf"
></A
><P
><B
>Table 1-1. EVMS user interfaces</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="96"
ALIGN="LEFT"
VALIGN="MIDDLE"
>User interface</TH
><TH
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Typical user</TH
><TH
WIDTH="96"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Types of use</TH
><TH
WIDTH="240"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Function</TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="MIDDLE"
>GUI</TD
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>All</TD
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="MIDDLE"
>All uses except automation</TD
><TD
WIDTH="240"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Allows you to choose from available options only, instead of having to sort through all the options, including ones that are not available at that point in the process. </TD
></TR
><TR
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Ncurses</TD
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Users who don't have GTK libraries or X Window Systems on their machines</TD
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="MIDDLE"
>All uses except automation</TD
><TD
WIDTH="240"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Allows you to choose from available options only, instead of having to sort through all the options, including ones that are not available at that point in the process. </TD
></TR
><TR
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Command Line</TD
><TD
WIDTH="144"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Expert</TD
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="MIDDLE"
>All uses</TD
><TD
WIDTH="240"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Allows easy automation of  tasks</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="terminology"
></A
>1.3. EVMS terminology</H1
><P
>To avoid confusion with other terms that describe volume 
	management in general, EVMS uses a specific set of terms. 
	These terms are listed, from most fundamental to most comprehensive, 
	as follows:
	</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Logical disk</DT
><DD
><P
>Representation of anything EVMS can access as a physical disk. 
		In EVMS, physical disks are logical disks.</P
></DD
><DT
>Sector</DT
><DD
><P
>The lowest level of addressability on a block
		device. This definition is in keeping with the standard
		meaning found in other management systems.</P
></DD
><DT
>Disk segment</DT
><DD
><P
>An ordered set of physically contiguous
		sectors residing on the same storage object. 
		The general analogy for a segment is to a traditional disk
		partition, such as DOS or OS/2 ®</P
></DD
><DT
>Storage region</DT
><DD
><P
>An ordered set of logically contiguous sectors
		that  are not necessarily physically contiguous. </P
></DD
><DT
>Storage object</DT
><DD
><P
>Any persistent memory structure in EVMS that can be used to 
		build objects or create a volume. Storage object is a  generic term for disks, segments, regions, and feature objects.</P
></DD
><DT
>Storage container</DT
><DD
><P
>A collection of storage objects. A storage
		container consumes one set of storage objects and produces new 
		storage objects. One common subset of storage containers is volume groups, 
		such as AIX®  or LVM.</P
><P
>Storage containers can be either of type private or cluster.</P
></DD
><DT
>Cluster storage container</DT
><DD
><P
>Specialized storage containers that consume only disk objects 
	that are physically accessible from all nodes of a cluster.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Private storage container</DT
><DD
><P
>A collection of disks that are physically accessible from all
	nodes of a cluster, managed as a single pool of storage, and owned and accessed
	by a single node of the cluster at any given time.</P
></DD
><DT
>Shared storage container</DT
><DD
><P
>A collection of disks that are physically accessible from all
	nodes of a cluster, managed as a single pool of storage, and owned and accessed
	by all nodes of the cluster simultaneously.</P
></DD
><DT
>Deported storage container</DT
><DD
><P
>A shared cluster container that is not owned by any node of the cluster.</P
></DD
></DL
></DIV
></DD
><DT
>Feature object</DT
><DD
><P
>A storage object that contains an EVMS native feature. 
		</P
><P
>An <I
CLASS="glossterm"
>EVMS Native Feature</I
> is a  function of volume management designed 
		and implemented by 
		EVMS. These features are not intended to be backward compatible with other 
		volume management technologies. </P
></DD
><DT
>Logical volume</DT
><DD
><P
>A volume that consumes a storage object and exports 
		something mountable. There are two varieties of logical volumes: <I
CLASS="glossterm"
>EVMS Volumes</I
> 
		and <I
CLASS="glossterm"
>Compatibility volumes</I
>.</P
><P
> <I
CLASS="glossterm"
>EVMS  Volumes</I
> contain EVMS native metadata and can support all 
		EVMS features. <TT
CLASS="filename"
>/dev/evms/my_volume</TT
> would be an example 
		of an EVMS Volume.</P
><P
><I
CLASS="glossterm"
>Compatibility volumes</I
> do not contain any EVMS native metadata. 
		Compatibility volumes are backward compatible to their particular scheme, but 
		they cannot support EVMS features. <TT
CLASS="filename"
>/dev/evms/md/md0</TT
> would 
		be an example of a compatibility  volume. </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN262"
></A
>1.4. What makes EVMS so flexible?</H1
><P
>There are numerous drivers in the Linux kernel, such as Device
Mapper and MD (software RAID), that implement volume management schemes.  EVMS is built
on top of these drivers to provide one framework for combining and
accessing the capabilities.</P
><P
>The EVMS Engine handles the creation,
configuration, and management of volumes, segments, and disks.
The EVMS Engine is a programmatic interface to the EVMS system.
User interfaces and programs that use EVMS must go through the Engine.</P
><P
>EVMS provides the capacity for plug-in modules to the Engine that
allow EVMS to perform specialized tasks without altering the core code.
These plug-in modules allow EVMS to be more extensible and customizable than
other volume management systems.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="LAYERDEF"
></A
>1.5. Plug-in layer definitions</H1
><P
>EVMS defines a layered architecture where plug-ins in each layer
		create abstractions of the layer or layers below. EVMS also allows most plug-ins
		to create abstractions of objects within the same layer. The following
		list defines these layers from the bottom up.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Device managers</DT
><DD
><P
>The first (bottom) layer consists
			of device managers.
			These plug-ins communicate with hardware device drivers to
			create the first EVMS objects. Currently, all devices are handled by a single plug-in.
			Future releases of EVMS might need additional device managers
			for network device management (for example, to manage
			disks on a storage area network (SAN)).</P
></DD
><DT
>Segment managers</DT
><DD
><P
>The second layer consists of segment 
			managers. These plug-ins
			 handle the segmenting, or partitioning,
			of disk drives. The Engine components can replace partitioning
			programs, such as <B
CLASS="command"
>fdisk</B
> and
			<SPAN
CLASS="application"
>Disk Druid</SPAN
>, and EVMS
			uses Device Mapper to replace the in-kernel disk
			partitioning code. 
			Segment managers can also be "stacked," meaning that 
			one segment manager
			can take as input the output from another segment 
			manager.</P
><P
> EVMS provides the following segment managers: 
			DOS, GPT, System/390® (S/390), Cluster, BSD,
			Mac, and BBR. Other segment manager
			plug-ins can be added to support other 
			partitioning schemes.</P
></DD
><DT
>Region managers</DT
><DD
><P
>The third layer consists of region 
			managers. 
			This layer provides a place for plug-ins that ensure
			compatibility with existing volume management schemes 
			in Linux and other operating systems. 
			Region managers are intended to model systems that 
			provide a logical abstraction above disks
			or partitions.</P
><P
>Like segment managers, region managers can 
			also be stacked. 
			Therefore, the input object(s) to a region manager can
			be disks, segments, or other regions.</P
><P
>There are currently three region manager plug-ins in EVMS: 
			Linux LVM, LVM2, and Multi-Disk (MD).
			<P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Linux LVM</DT
><DD
><P
>The Linux LVM plug-in provides compatibility with
				the Linux LVM and allows the creation of volume groups 
				(known in EVMS as containers) and logical volumes 
				(known in EVMS as regions). </P
></DD
><DT
>LVM2</DT
><DD
><P
>&#13;				The LVM2 plug-in provides compatibility with the
new volume format introduced by the LVM2 tools from Red Hat.  This plug-in
is very similar in functionality to the LVM plug-in.  The primary difference
is the new, improved metadata format.	
				</P
></DD
><DT
>MD</DT
><DD
><P
>The Multi-Disk (MD) plug-in for RAID provides 
				RAID levels linear, 0, 1, 4, and 5 in 
				software. MD is one plug-in that displays as four region
				managers that you can choose from.</P
></DD
></DL
></DIV
></P
></DD
><DT
>EVMS features</DT
><DD
><P
>The next layer consists of EVMS 
			features. This layer is
			where new EVMS-native functionality is implemented. EVMS
			features can be built on any object in the system, including
			disks, segments, regions, or other feature objects. 
			All EVMS features share a common type of metadata, 
			which makes discovery of feature objects much more 
			efficient, and recovery
			of broken features objects much more reliable. There are three 
			features currently available in EVMS: drive linking, Bad 
			Block Relocation, and snapshotting. </P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Drive Linking</DT
><DD
><P
>Drive linking allows any
			number of objects to be linearly concatenated together into a
			single object. A drive linked volume can be expanded by 
			adding another storage object to the end or shrunk by removing the last object.</P
></DD
><DT
>Bad Block Relocation</DT
><DD
><P
>Bad Block Relocation (BBR)
			monitors its I/O path and detects write failures (which can be
			caused by a damaged disk). In the event of such a failure, the
			data from that request is stored in a new location. BBR keeps
			track of this remapping. Additional I/Os to that
			location are redirected to the new location.</P
></DD
><DT
>Snapshotting</DT
><DD
><P
>The Snapshotting feature provides
			a mechanism for creating a "frozen" copy of a volume at a single
			instant in time, without having to take that volume off-line.
			This is useful for performing backups on a live system.
			Snapshots work with any volume (EVMS or compatibility), and can
			use any other available object as a backing store. After a
			snapshot is created and made into an EVMS volume, writes to the "original" volume cause the
			original contents of that location to be copied to the snapshot's
			storage object. Reads to the snapshot volume look like they
			come from the original at the time the snapshot was created.
</P
></DD
></DL
></DIV
></DD
><DT
>File System Interface Modules</DT
><DD
><P
>File System Interface Modules (FSIMs) 
			provide coordination with the
			file systems during certain volume management 
			operations. For
			instance, when expanding or shrinking a volume, 
			the file system
			must also be expanded or shrunk to the appropriate size.
			Ordering in this example is also important; 
			a file system cannot
			be expanded before the volume, and a volume cannot 
			be shrunk before the file system. 
			The FSIMs allow EVMS to ensure this
			coordination and ordering.</P
><P
>FSIMs also perform file system
			operations from one of the EVMS user interfaces. For instance,
			a user can make new file systems and check existing file systems
			by interacting with the FSIM.</P
></DD
><DT
>Cluster Manager Interface Modules</DT
><DD
><P
>Cluster Manager Interface Modules, also
		known as the EVMS Clustered Engine (ECE), interface
		with the local cluster manager installed on the system.
		The ECE provides a standardized ECE API to the Engine
		while hiding cluster manager details from the Engine.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="evmscmuse"
></A
>Chapter 2. Using the EVMS interfaces</H1
><P
>This chapter explains how to use the EVMS GUI, Ncurses, and CLI interfaces.
This chapter also
includes information about basic navigation and commands available through
the CLI. </P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="GUI"
></A
>2.1. EVMS GUI</H1
><P
>The EVMS GUI is a flexible and easy-to-use
	interface for administering volumes and storage objects. 
	Many users find the EVMS GUI easy to use because it displays which
	storage objects, actions, and plug-ins are acceptable for a
	particular task.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="GUITASKS"
></A
>2.1.1. Using context sensitive and action menus</H2
><P
>The EVMS GUI lets you accomplish most
		tasks in one of two ways: context sensitive menus or the
		<SPAN
CLASS="guimenu"
>Actions</SPAN
> menu.</P
><P
>Context sensitive menus are available from any
		of the main "views." Each view corresponds to a
		page in a notebook widget located on the EVMS
		GUI main window. These views are made up of different
		trees or lists that visually represent the organization of
		different object types, including volumes,
		feature objects, regions, containers, segments, or disks. </P
><P
>You can view the context
		sensitive menu for an object by right-clicking on that
		object. The actions that are available
		for that object display on
		the screen. The GUI will only present actions that are 
		acceptable for the selected object at that point in the 
		process. These actions are not always a complete set. </P
><P
>To use the <SPAN
CLASS="guimenuitem"
>Actions</SPAN
> menu,
		choose <SPAN
CLASS="guimenuitem"
>Action</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>&#60;the action you want
				to accomplish&#62;</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>&#60;options&#62;</SPAN
>. 
			The <SPAN
CLASS="guimenuitem"
>Actions</SPAN
> menu 
		provides a more guided path for
		completing a task than do context sensitive menus. The
			<SPAN
CLASS="guimenu"
>Actions</SPAN
> option is similar to the 
		wizard or druid approach used by many GUI applications.</P
><P
>All of the operations you need to
			perform as an administrator are available through
			the <SPAN
CLASS="guimenuitem"
>Actions</SPAN
> menu.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="COMMIT"
></A
>2.1.2. Saving changes</H2
><P
>All of the changes that you make while in the EVMS
		GUI are only in memory until you save the changes.
		In order to make your changes
		permanent, you must save
		all changes before exiting. If you
		forget to save the changes and decide to exit or close the
		EVMS GUI, you are reminded to save any
		pending changes.</P
><P
>To explicitly save all the changes you
		made, select <SPAN
CLASS="guimenu"
>Action</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Save</SPAN
>, and click
		the <SPAN
CLASS="guibutton"
>Save</SPAN
> button.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="refresh"
></A
>2.1.3. Refreshing changes</H2
><P
>The <SPAN
CLASS="guibutton"
>Refresh</SPAN
> button updates the view and allows 
you to see changes, like mount points, that might have changed outside of 
the GUI.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="guiplus"
></A
>2.1.4. Using the GUI "+"</H2
><P
>Along the left hand side of the panel views in the GUI is a "+" that resides
beside each item.  When you click the "+,"  the objects that are included
in the item are displayed.  If any of the objects that display also have a "+" beside them, you can expand them further by clicking on the "+" next to each object name.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN364"
></A
>2.1.5. Using the accelerator keys</H2
><P
>You can avoid using a mouse for navigating the EVMS GUI by using a series of
key strokes, or "accelerator keys," instead.  The following sections tell how to use
accelerator keys in the EVMS Main Window, the Selection Window, and the Configuration
Options Window.</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN367"
></A
>2.1.5.1. Main Window accelerator keys</H3
><P
>In the Main Window view, use the following keys to navigate:

<DIV
CLASS="table"
><A
NAME="AEN370"
></A
><P
><B
>Table 2-1. Accelerator keys in the Main Window</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Left and right arrow keys</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Navigate between the notebook tabs of the different views.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Down arrow and <B
CLASS="keycap"
>Spacebar</B
></TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Bring keyboard focus into the view.</TD
></TR
></TBODY
></TABLE
></DIV
>
</P
><P
>&#13;While in a view, use the following keys to navigate:

<DIV
CLASS="table"
><A
NAME="AEN384"
></A
><P
><B
>Table 2-2. Accelerator keys in the views</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>up and down arrows</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Allow movement around the window.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>"+"</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Opens an object tree.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>"-"</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Collapses an object tree.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>ENTER</B
></TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Brings up the context menu (on a row).</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Arrows</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Navigate a context menu.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>ENTER</B
></TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><P
>Activates an item.</P
></TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>ESC</B
></TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Dismisses the context menu.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Tab</B
></TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Gets you out of the view and moves you back up to the notebook tab.</TD
></TR
></TBODY
></TABLE
></DIV
>
 
</P
><P
>&#13;To access the action bar menu, press <B
CLASS="keycap"
>Alt</B
> and 
then the underlined
accelerator key for the menu choice (for example, "A" for the 
<SPAN
CLASS="guimenuitem"
>Actions</SPAN
>
dropdown menu).
</P
><P
>In a dropdown menu, you can use the up and down arrows
to navigate.  You could also just type the accelerator key for the menu
item, which is the character with the underscore.  For example, to initiate
a command to delete a container, type <B
CLASS="keycap"
>Alt</B
> + "A" + "D" + "C."</P
><P
>&#13;<B
CLASS="keycap"
>Ctrl-S</B
> is a shortcut to initiate saving changes.  
<B
CLASS="keycap"
>Ctrl-Q</B
> is a shortcut to initiate quitting the EVMS GUI.
</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN427"
></A
>2.1.5.2. Accelerator keys in the selection window</H3
><P
>&#13;A selection window typically contains a selection list, plus four to five
buttons below it.  Use the following keys to navigate in the selection window:

<DIV
CLASS="table"
><A
NAME="AEN430"
></A
><P
><B
>Table 2-3. Accelerator keys in the selection window</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Tab</B
></TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Navigates (changes keyboard focus) between the list and the buttons.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Up and down arrows</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Navigates within the selection list.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Spacebar</B
></TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Selects and deselects items in the selection list.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Enter</B
> on the button or type the accelerator character (if one exists)</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Activates a button</TD
></TR
></TBODY
></TABLE
></DIV
>

</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN451"
></A
>2.1.5.3. Configuration options window accelerator keys</H3
><P
>&#13;Use the following keys to navigate in the configuration options window:

<DIV
CLASS="table"
><A
NAME="AEN454"
></A
><P
><B
>Table 2-4. Accelerator keys in the configuration options window</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Tab</B
></TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Cycles focus between fields and buttons</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Left and right arrows</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Navigate the folder tabs if the window has a widget notebook.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Spacebar</B
> or the down arrow</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Switches focus to a different notebook page.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Enter</B
> or type the accelerator character (if one exists)</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Activates a button</TD
></TR
></TBODY
></TABLE
></DIV
>

</P
><P
>For widgets, use the following keys to navigate:

<DIV
CLASS="table"
><A
NAME="AEN476"
></A
><P
><B
>Table 2-5. Widget navigation keys in the configuration options window </B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Tab</B
></TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Cycles forward through a set of widgets</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="keycap"
>Shift-Tab</B
></TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Cycles backward through a set of widgets.</TD
></TR
></TBODY
></TABLE
></DIV
>

</P
><P
>&#13;The widget navigation, selection, and activation is the same in all dialog
windows.
</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="NCURSES"
></A
>2.2. EVMS Ncurses interface</H1
><P
>The EVMS Ncurses (<B
CLASS="command"
>evmsn</B
>) user interface is a menu-driven
	interface with characteristics similar to those of the EVMS GUI. 
	Like the EVMS GUI,
	<B
CLASS="command"
>evmsn</B
> can accommodate new plug-ins and features without requiring any code
	changes.</P
><P
>The EVMS Ncurses user interface
	allows you to manage volumes on systems that do not have the X
	and GTK+ libraries that are required by the EVMS GUI.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="NCURSESOVER"
></A
>2.2.1. Navigating through EVMS Ncurses</H2
><P
>The EVMS Ncurses user interface initially
	     	displays a list of logical volumes similar to the
	     logical volumes view in the EVMS GUI.  Ncurses also provides
		a menu bar similar to the menu bar in the EVMS GUI.</P
><P
>A general guide to navigating through the layout of the
		Ncurses window is listed below:</P
><P
></P
><UL
><LI
><P
><B
CLASS="keycap"
>Tab</B
> cycles you through the available 
			views.</P
></LI
><LI
><P
>Status messages and tips are displayed on
			the last line of the screen.</P
></LI
><LI
><P
>Typing the accelerator character (the
			letter highlighted in red) for any menu item activates
			that item.  For example, typing <B
CLASS="keycap"
>A</B
> in any view brings
			down the <SPAN
CLASS="guimenuitem"
>Actions</SPAN
> menu.</P
></LI
><LI
><P
>Typing <B
CLASS="keycap"
>A</B
> + <B
CLASS="keycap"
>Q</B
> in a view 
			quits the application.</P
></LI
><LI
><P
>Typing <B
CLASS="keycap"
>A</B
> + <B
CLASS="keycap"
>S</B
> in a view 
			saves changes
			made during an <B
CLASS="command"
>evmsn</B
> session.</P
></LI
><LI
><P
>Use the <B
CLASS="keycap"
>up</B
> and <B
CLASS="keycap"
>down</B
> 
			arrows to highlight an object in a view.  Pressing
			<B
CLASS="keycap"
>Enter</B
> while an object in a view is
			highlighted presents a context popup menu.</P
></LI
><LI
><P
>Dismiss a context popup menu by pressing
			<B
CLASS="keycap"
>Esc</B
> or by selecting a menu item with the
			<B
CLASS="keycap"
>up</B
> and <B
CLASS="keycap"
>down</B
> arrows and pressing 
			<B
CLASS="keycap"
>Enter</B
> to 
			activate the menu item.</P
></LI
></UL
><P
>Dialog windows are similar in design to the EVMS GUI
dialogs, which allow a user to navigate forward and backward through a series
of dialogs using <SPAN
CLASS="guibutton"
>Next</SPAN
> and <SPAN
CLASS="guibutton"
>Previous</SPAN
>.  A general
guide to dialog windows is listed below:</P
><P
></P
><UL
><LI
><P
><B
CLASS="keycap"
>Tab</B
> cycles you through the available buttons.  Note
that some buttons might not be available until a valid selection is made.</P
></LI
><LI
><P
>The <B
CLASS="keycap"
>left</B
> and <B
CLASS="keycap"
>right</B
> arrows can also be used
to move to an available button.</P
></LI
><LI
><P
>Navigate a selection list with the <B
CLASS="keycap"
>up</B
> and 
<B
CLASS="keycap"
>down</B
> arrows.</P
></LI
><LI
><P
>Toggle the selection of an item in a list with <B
CLASS="keycap"
>spacebar</B
>.</P
></LI
><LI
><P
>Activate a button that has the current focus with <B
CLASS="keycap"
>Enter</B
>.  If the button has
an accelerator character (highlighted in red), you can also activate the button
by typing the accelerator character regardless of whether the button has the current
focus.</P
></LI
></UL
><P
>The EVMS Ncurses user interface, like the EVMS GUI, provides context menus
for actions that are available only to the selected object in a view.  Ncurses also provides
context menus for items that are
available from the <SPAN
CLASS="guimenuitem"
>Actions</SPAN
> menu.  These context menus present
a list of commands available for a certain object.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="NCURCHANGES"
></A
>2.2.2. Saving changes</H2
><P
>All changes you make while in the EVMS
		Ncurses are only in memory until you save the changes.
		In order to make the changes permanent, save
		all changes before exiting. If you
		forget to save the changes and decide to exit the EVMS Ncurses
		interface, you will be reminded of the unsaved changes and
		be given the chance to save or discard the changes before exiting.</P
><P
>To explicitly save all changes,  press <B
CLASS="keycap"
>A</B
> + <B
CLASS="keycap"
>S</B
> and confirm
		that you want to save changes.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="COMMANDLINE"
></A
>2.3. EVMS Command Line Interpreter</H1
><P
>The EVMS Command Line Interpreter (EVMS CLI) provides a
	command-driven user interface for EVMS. The EVMS CLI 
	helps automate volume management tasks
	and provides an interactive mode in situations where the
	EVMS GUI is not available.</P
><P
>Because the EVMS CLI is an interpreter, it operates
	differently than command line utilities for the
	operating system. The options you specify 
	on the EVMS CLI command line to invoke the EVMS 
	CLI control how the EVMS CLI operates. For example, the 
	command line options tell the CLI where to go for commands to 
	interpret and how
	often the EVMS CLI must save changes to disk. 
	When invoked, the EVMS CLI prompts for commands. </P
><P
>The volume management commands the EVMS CLI understands
	are specified in the <TT
CLASS="filename"
>/usr/src/evms-2.2.0/engine2/ui/cli/grammar.ps</TT
> 
	file that accompanies the EVMS
	package.  These commands are described in detail in the EVMS
	man page, and help on these commands is available from within the EVMS
	CLI. </P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="CLITASKS"
></A
>2.3.1. Using the EVMS CLI</H2
><P
>Use the <B
CLASS="command"
>evms</B
> command to start
	  the EVMS CLI. If you do not enter an option with
	  <B
CLASS="command"
>evms</B
>, the EVMS CLI starts in
	  interactive mode. In interactive mode, the EVMS CLI prompts
	  you for commands. The result of each command is immediately saved
	  to disk. The EVMS CLI exits when you type <TT
CLASS="userinput"
><B
>exit</B
></TT
>. 
	You can modify this behavior by using
	  the following options with <B
CLASS="command"
>evms</B
>: 

	  <P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>-b</DT
><DD
><P
>This option indicates that you are running in
		batch mode and anytime there is a prompt for input from the user,
		the default value is accepted automatically.  This is the
		default behavior with the <B
CLASS="command"
>-f</B
> option.</P
></DD
><DT
>-c</DT
><DD
><P
>This option saves changes to disk
		only when EVMS CLI exits, not after
		each command.</P
></DD
><DT
>-f <TT
CLASS="replaceable"
><I
>filename</I
></TT
></DT
><DD
><P
>This option tells the EVMS CLI to use
		<TT
CLASS="replaceable"
><I
>filename</I
></TT
> as the source of
		commands. The EVMS CLI exits when it reaches the
		end of
		<TT
CLASS="replaceable"
><I
>filename</I
></TT
>.
		</P
></DD
><DT
>-p</DT
><DD
><P
>This option only parses commands; it does
		not execute them.
		When combined with the <B
CLASS="command"
>-f</B
> option, the 
		<B
CLASS="command"
>-p</B
> option detects syntax errors in 
		command files. </P
></DD
><DT
>-h</DT
><DD
><P
>This option displays help information
		for options used with the <B
CLASS="command"
>evms</B
>
		command.</P
></DD
><DT
>-rl</DT
><DD
><P
>This option tells the CLI that all remaining items on the 
		command line are replacement parameters for use with 
		EVMS commands. </P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Replacement parameters are accessed in EVMS commands using the 
		<TT
CLASS="option"
>$(x)</TT
> notation, where <TT
CLASS="replaceable"
><I
>x</I
></TT
> is the number identifying which 
		replacement parameter to use. Replacement parameters are assigned 
		numbers (starting with 1) as they are encountered on the command line. 
		Substitutions are not made within comments or quoted strings. </P
><P
>An example would be:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>evms -c -f testcase -rl sda sdb</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;		<TT
CLASS="option"
>sda</TT
> is the replacement for <TT
CLASS="replaceable"
><I
>parameter1</I
></TT
> and 
		<TT
CLASS="option"
>sdb</TT
> is the replacement for <TT
CLASS="replaceable"
><I
>parameter2</I
></TT
></P
></TD
></TR
></TABLE
></DIV
></DD
></DL
></DIV
></P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Information on less commonly used options is available 
		in the EVMS man page. </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="NOTECOMMAND"
></A
>2.3.2. Notes on commands and command files</H2
><P
>The EVMS CLI allows multiple commands to be displayed
		on a command line.  When you specify multiple commands on a
		single command line, separate the commands with
		a colon ( : ).  This is
		important for command files because the EVMS CLI sees
		a command file as a single long command line.  The
		EVMS CLI has no concept of lines in the file and
		ignores spaces. These features allow a command in
		a command file to span several lines and use whatever
		indentation or margins that are convenient. The only
		requirement is that the command separator (the colon) be present
		between commands.</P
><P
>The EVMS CLI ignores spaces unless they 
		occur within quote marks. Place in quotation marks a name that contains
		spaces or other non-printable or control characters.  If the name
		contains a quotation mark as part of the name, the
		quotation mark must be "doubled," as shown in the following 
		example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>"This is a name containing ""embedded"" quote marks."</PRE
></FONT
></TD
></TR
></TABLE
><P
>EVMS CLI keywords are not case sensitive, but EVMS
		names are case sensitive. Sizes can be input in any units with a unit label, such as KB, MB, GB, or TB.</P
><P
>Finally, C programming language style comments
		are supported by the EVMS CLI.  Comments can begin and
		end anywhere except within a quoted string, as shown in the
		following example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>/* This is a comment */
Create:Vo/*This is a silly place for a comment, but it is
allowed.*/lume,"lvm/Sample Container/My LVM
Volume",compatibility</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="debuglevels"
></A
>Chapter 3. The EVMS log file and error data collection</H1
><P
>This chapter discusses the EVMS information and error log file and the various logging levels.  It also explains how to change the logging level.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="FSIMsupp"
></A
>3.1. About the EVMS log file</H1
><P
>The EVMS Engine creates a log file called <TT
CLASS="filename"
>/var/log/evmsEngine.log</TT
> every time the Engine is opened.  The Engine also saves copies of up to nine previous Engine sessions in the files <TT
CLASS="filename"
>/var/log/evmsEngine.n.log</TT
>, where <TT
CLASS="filename"
>n</TT
> is the number of the session between 1 and 9.  </P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="loglevels"
></A
>3.2. Log file logging levels</H1
><P
>There are several possible logging levels that you can choose to be collected in <TT
CLASS="filename"
>/var/log/evmsEngine.log</TT
>.  The "lowest" logging level, <TT
CLASS="filename"
>critical</TT
>, collects only messages about serious system problems, whereas the "highest" level, <TT
CLASS="filename"
>everything</TT
>, collects all logging related messages.  When you specify a particular logging level, the Engine collects messages for that level and all the levels below it.  </P
><P
>The following table lists the allowable log levels and the information they provide:</P
><P
><DIV
CLASS="table"
><A
NAME="AEN645"
></A
><P
><B
>Table 3-1. EVMS logging levels</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Level name</TH
><TH
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Critical</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>The health of the system or the Engine is in jeopardy; for example, an operation has failed because there is not enough memory.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Serious</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>An operation did not succeed.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Error</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>The user has caused an error.  The error messages are provided to help the user correct the problem.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Warning</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>An error has occurred that the system might or might not be able to work around.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Default</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>An error has occurred that the system has already worked around.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Details</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Detailed information about the system.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Entry_Exit</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Traces the entries and exits of functions.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Debug</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Information that helps the user debug a problem.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Extra</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>More information that helps the user debug a problem than the "Debug" level provides.</TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Everything</TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Verbose output.</TD
></TR
></TBODY
></TABLE
></DIV
></P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="specifylevels"
></A
>3.3. Specifying the logging levels</H1
><P
>By default, when any of the EVMS interfaces is opened, the Engine logs the <TT
CLASS="filename"
>Default</TT
> level of messages into the <TT
CLASS="filename"
>/var/log/evmsEngine.log</TT
> file.  However, if your system is having problems and you want to see more of what is happening, you can change the logging level to be higher; if you want fewer logging messages, you can change the logging level to be lower.  To change the logging level, specify the <B
CLASS="command"
>-d</B
> parameter and the log level on the interface open call.  The following examples show how to open the various interfaces with the highest logging level (<TT
CLASS="filename"
>everything</TT
>):</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>GUI:		evmsgui -d everything</PRE
></FONT
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Ncurses:	evmsn -d everything</PRE
></FONT
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>CLI:		evms -d everything</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If you use the EVMS mailing list for help with a problem, providing to us
the log file that is created when you open one of the interfaces (as shown 
in the previous commands) makes it easier for us to help you.
</P
></TD
></TR
></TABLE
></DIV
><P
>The EVMS GUI lets you change the logging level during an Engine session.  To do so, follow these steps:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Settings</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Log Level</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Engine</SPAN
>.
	</P
></LI
><LI
><P
>Click the <SPAN
CLASS="guibutton"
>Level</SPAN
> you want.
	</P
></LI
></OL
></P
><P
>The CLI command, <B
CLASS="command"
>probe</B
>, opens and closes the Engine, which causes a new log to start.  The log that existed before the <B
CLASS="command"
>probe</B
> command was issued is renamed <TT
CLASS="filename"
>/var/log/evmsEngine.1.log</TT
> and the new log is named <TT
CLASS="filename"
>/var/log/evmsEngine.log</TT
>.</P
><P
>&#13;If you will be frequently using a different log level than the default,
you can specify the default logging level in 
<TT
CLASS="filename"
>/etc/evms.conf</TT
> rather than
having to use the <B
CLASS="command"
>-d</B
> option when starting the user interface.
The "debug_level" option in the "engine" section sets the default
logging level for when the Engine is opened.  
Using the <B
CLASS="command"
>-d</B
> option
during the command invocation overrides the setting in
<TT
CLASS="filename"
>/etc/evms.conf</TT
>.
</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="evmsmigrate"
></A
>Chapter 4. Viewing compatibility volumes after migrating</H1
><P
>Migrating to EVMS allows you to have the flexibility of EVMS without losing the integrity of your existing data. EVMS discovers existing volume management volumes as compatibility volumes. After you have installed EVMS, you can view your existing volumes with the interface of your choice. </P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="guimigrate"
></A
>4.1. Using the EVMS GUI</H1
><P
>If you are using the EVMS GUI as your preferred interface, you can view your migrated volumes by typing <B
CLASS="command"
>evmsgui</B
> at the command prompt. The following window opens, listing your migrated volumes. </P
><DIV
CLASS="figure"
><A
NAME="AEN726"
></A
><P
><B
>Figure 4-1. GUI start-up window</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="gui_active.png"></P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="ncurmigrate"
></A
>4.2. Using Ncurses</H1
><P
>If you are using the Ncurses interface, you can view your migrated volumes by 
	typing <B
CLASS="command"
>evmsn</B
> at the command prompt. The following window opens, listing your migrated volumes. </P
><DIV
CLASS="figure"
><A
NAME="AEN737"
></A
><P
><B
>Figure 4-2. Ncurses start-up window</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="ncurses_active.png"></P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="climigrate"
></A
>4.3. Using the CLI</H1
><P
>If you are using the Command Line Interpreter (CLI) interface, you can view 
	your migrated volumes by following these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Start the Command Line Interpreter by typing 
		<B
CLASS="command"
>evms</B
> at the command line.</P
></LI
><LI
><P
>Query the volumes by typing the following at the 
		<TT
CLASS="prompt"
>EVMS</TT
> prompt:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query:volumes</PRE
></FONT
></TD
></TR
></TABLE
><P
>Your migrated volumes are displayed as results of the 
		query. </P
></LI
></OL
><DIV
CLASS="figure"
><A
NAME="AEN756"
></A
><P
><B
>Figure 4-3. CLI volume query results</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="cli_active.png"></P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="displaydetails"
></A
>Chapter 5. Obtaining interface display details</H1
><P
>The EVMS interfaces let you view more detailed information about an EVMS object than 
what is readily available from the main views of the EVMS user interfaces.  The type and extent
of additional information available is dependent on the interface you use.  For example, the
EVMS GUI provides more in-depth information than does the CLI.</P
><P
>The following sections show how to find detailed information on the region
<TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>, which is part of
volume <TT
CLASS="filename"
>/dev/evms/Sample Volume</TT
> (created in section 10.2).</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="displaygui"
></A
>5.1. Using the EVMS GUI</H1
><P
>With the EVMS GUI, it is only possible to display additional details on an object through
the Context Sensitive Menus, as shown in the following steps:

<P
></P
><OL
TYPE="1"
><LI
><P
>Looking at the <SPAN
CLASS="guibutton"
>volumes view</SPAN
>, click the "+" next
to volume <TT
CLASS="filename"
>/dev/evms/Sample Volume</TT
>.  Alternatively, look at the <SPAN
CLASS="guimenu"
>regions</SPAN
> view.</P
></LI
><LI
><P
>Right click <TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>.</P
></LI
><LI
><P
>Point at <SPAN
CLASS="guibutton"
>Display Details...</SPAN
> and click.  A new window opens
with additional information about the selected region.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenu"
>More</SPAN
> by the <SPAN
CLASS="guibutton"
>Logical Extents box</SPAN
>.  Another window opens that displays the mappings of logical extents to physical extents.</P
></LI
></OL
>


</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="displaydatancurses"
></A
>5.2. Using Ncurses</H1
><P
>Follow these steps to display additional details on an object with Ncurses:

<P
></P
><OL
TYPE="1"
><LI
><P
>Press
	<B
CLASS="keycap"
>Tab</B
> to reach the Storage Regions view.
	</P
></LI
><LI
><P
>Scroll down using the <B
CLASS="keycap"
>down</B
> arrow until
	 <TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
> is highlighted.
	</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.
	</P
></LI
><LI
><P
>In the context menu, scroll down using the <B
CLASS="keycap"
>down</B
> arrow 
	to highlight "Display Details..."
	</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
> to activate the menu item.
	</P
></LI
><LI
><P
>In the Detailed Information dialog, use the <B
CLASS="keycap"
>down</B
> arrow to
	highlight the "Logical Extents" item and then use <B
CLASS="keycap"
>spacebar</B
> to open
	another window that displays the mappings of logical extents to physical extents.
	</P
></LI
></OL
>
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN812"
></A
>5.3. Using the CLI</H1
><P
>Use the
	<B
CLASS="command"
>query</B
> command (abbreviated <B
CLASS="command"
>q</B
>) with filters to display details about EVMS objects.  There are two filters that are especially helpful for navigating
within the command line: <B
CLASS="command"
>list options</B
> (abbreviated <B
CLASS="command"
>lo</B
>) and <B
CLASS="command"
>extended info</B
> (abbreviated <B
CLASS="command"
>ei</B
>). </P
><P
>The <B
CLASS="command"
>list options</B
> command tells you what can currently be done and what options you
can specify.  To use this command, first build a traditional query command starting with the command name <B
CLASS="command"
>query</B
>, followed by a colon (<B
CLASS="command"
>:</B
>), and then the type of object you
want to query (for example, volumes, objects, plug-ins).  Then, you can use filters to narrow
the search to only the area you are interested in.  For example, to determine the acceptable
actions at the current time on <TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>, enter the following command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query: regions, region="lvm/Sample Container/Sample Region", list options</PRE
></FONT
></TD
></TR
></TABLE
><P
>The <B
CLASS="command"
>extended info</B
> filter is the equivalent of Display Details in the EVMS GUI and Ncurses interfaces.  The command takes the following form: <B
CLASS="command"
>query</B
>, followed by a colon (<B
CLASS="command"
>:</B
>), the filter (<B
CLASS="command"
>extended info</B
>), a comma (<B
CLASS="command"
>,</B
>), and the object you want more information about.  The command returns a list containing the field names, titles, descriptions and values for each field defined for the object.  For example, to obtain details on <TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>, enter the following command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query: extended info, "lvm/Sample Container/Sample Region"</PRE
></FONT
></TD
></TR
></TABLE
><P
>Many of  the field names that are returned by the <B
CLASS="command"
>extended info</B
> filter can be expanded
further by specifying the field name or names at the end of the command, separated
by commas.  For example, if you wanted additional information about logical extents, the query would look like the following:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query: extended info, "lvm/Sample Container/Sample Region", Extents</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="evmsassignseg"
></A
>Chapter 6. Adding and removing a segment manager</H1
><P
> This chapter discusses when to use a segment manager, what the different types of segment managers are, how to add a segment manager to a disk, and how to remove a
segment manager. </P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="whenassign"
></A
>6.1. When to add a segment manager</H1
><P
>Adding a segment manager to a disk allows the disk to be subdivided into 
	smaller storage objects called disk segments. The 
	<B
CLASS="command"
>add</B
> command causes a 
	segment manager to create appropriate metadata and expose freespace 
	that the segment manager  
	finds on the disk. You need to add segment managers when you 
	have a new disk or 
	when you are switching from one partitioning scheme to another. </P
><P
>EVMS displays disk segments as the following types: </P
><P
></P
><UL
><LI
><P
>Data: a set of contiguous sectors that has been allocated 
		from a disk and can be used to construct a volume or object.</P
></LI
><LI
><P
>Freespace: a set of contiguous sectors that are unallocated 
		or not in use. Freespace can be used to create a segment.</P
></LI
><LI
><P
>Metadata: a set of contiguous sectors that contain 
		information needed by the segment manager.</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="smtypes"
></A
>6.2. Types of segment managers</H1
><P
>There are seven types of segment managers in EVMS: DOS, GPT, S/390, Cluster,  BSD, MAC, and BBR. </P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="defaultseg"
></A
>6.2.1. DOS Segment Manager</H2
><P
>The most
		commonly used segment manager is the DOS Segment Manager. This plug-in
		provides support for traditional DOS disk partitioning. The 
		DOS Segment Manager also recognizes and supports the following variations 
		of the DOS partitioning scheme:
		<P
></P
><UL
><LI
><P
>OS/2:  an OS/2 disk has additional metadata 
		sectors that contain information needed to reconstruct disk segments.</P
></LI
><LI
><P
>Embedded partitions: support for BSD, SolarisX86, and UnixWare  
			is sometimes found embedded in primary DOS partitions. 
			The DOS Segment Manager  recognizes and supports these 
			slices as disk segments.</P
></LI
></UL
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="gptseg"
></A
>6.2.2. GUID Partitioning Table (GPT) Segment Manager</H2
><P
>The GUID Partitioning Table (GPT) Segment Manager handles the 
		new GPT partitioning scheme 
		on IA-64 machines. The Intel 
		<I
CLASS="citetitle"
>Extensible Firmware Interface Specification</I
>
 		requires that firmware be able to discover partitions and produce logical devices that 
		correspond to disk partitions.  The partitioning scheme described in 
		the specification is called GPT due to the extensive use of 
		Globally Unique Identifier (GUID) tagging. GUID is a 128 bit long 
		identifier, also referred to as a Universally Unique Identifier (UUID).   
		As described in the Intel <I
CLASS="citetitle"
>Wired For Management Baseline Specification</I
>,  
		a GUID is a combination of  time and space fields that produce an 
		identifier that is unique across an entire UUID space.  
		These identifiers are used extensively on GPT partitioned disks 
		for tagging entire disks and individual partitions. 
		GPT partitioned disks serve several functions, such as:</P
><P
></P
><UL
><LI
><P
>keeping a primary and backup copy of metadata</P
></LI
><LI
><P
>replacing msdos partition nesting by allowing many partitions</P
></LI
><LI
><P
>using 64 bit logical block addressing</P
></LI
><LI
><P
>tagging partitions and disks with GUID descriptors</P
></LI
></UL
><P
>The GPT Segment Manager scales better to large disks. It provides more redundancy with added reliability and uses unique names. However, the GPT Segment Manager is not compatible with DOS, OS/2, or Windows®. </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="s390sm"
></A
>6.2.3. S/390 Segment Manager</H2
><P
>The S/390 Segment Manager is used exclusively on System/390 
		mainframes.  The S/390 Segment Manager has the ability to recognize 
		various disk layouts found on an S/390 machine, and provide 
		disk segment support for this architecture. The two most common disk 
		layouts are Linux Disk Layout (LDL) and Common Disk Layout (CDL). </P
><P
>The principle difference between LDL and CDL is that an LDL disk 
		cannot be further subdivided. An LDL disk will produce a single metadata 
		disk segment and a single data disk segment. There is no freespace on an 
		LDL disk, and you cannot delete or re-size the data segment. A CDL disk can 
		be subdivided into multiple data disk segments 
		because it contains metadata that is missing from an LDL disk, specifically 
		the Volume Table of Contents (vtoc) information.</P
><P
>The S/390 Segment  Manager is the only segment manager plug-in 
		capable of understanding the unique S/390 disk layouts. The S/390 Segment Manager 
		cannot be added or removed from a disk. </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN884"
></A
>6.2.4. Cluster segment manager</H2
><P
>The cluster segment manager (CSM) supports high availability clusters.  When the
CSM is added to a shared storage disk, it writes metadata on the disk that:</P
><P
></P
><UL
><LI
><P
>provides a unique disk ID (guid)</P
></LI
><LI
><P
>names the EVMS container the disk will reside within</P
></LI
><LI
><P
>specifies the cluster node (nodeid) that owns the disk</P
></LI
><LI
><P
>specifies the cluster (clusterid)</P
></LI
></UL
><P
>This metadata allows the CSM to build containers for supporting failover situations.
It does so by constructing an EVMS container object that consumes all shared disks
discovered by the CSM and belonging to the same container.  These shared storage
disks are consumed by the container and a single data segment is produced by the
container for each consumed disk.  A failover of the EVMS resource is
accomplished by simply reassigning the CSM container to the standby cluster node and
having that node re-run its discovery process.</P
><P
>Adding disks to CSM containers implies that only disk storage objects are
acceptable to the CSM.  This is an important aspect of the CSM.  Other segment
managers can be embedded within storage objects and used to further subdivide them. 
However, the CSM cannot add any other kind of storage object to a CSM container
because the container is meant to be a disk group and the entire disk group is
reassigned during a failover.  So, the CSM only accepts disks when constructing
containers.  This is important to remember when adding the CSM to a disk.  If you
choose <B
CLASS="command"
>Add</B
> and the CSM does not appear in the list of selectable plug-ins when you know you have a disk, you should look at the Volume list and see if the disk has
already been listed as a compatibility volume.  If you simply delete the volume, the disk will
become an available object and the CSM will then appear in the list of plug-ins
because it now has an available disk that it can add to a container.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN899"
></A
>6.2.5. BSD segment manager</H2
><P
>BSD refers to the Berkeley Software Distribution UNIX® operating system.  The EVMS
BSD segment manager is responsible for recognizing and producing EVMS segment
storage objects that map BSD partitions.  A BSD disk may have a slice table in the
very first sector on the disk for compatibility purposes with other operating systems.
For example, a DOS slice table might be found in the usual MBR sector.  The BSD disk
would then be found within a disk slice that is located using the compatibility slice table.
However, BSD has no need for the slice table and can fully dedicate the disk to
itself by placing the disk label in the very first sector.  This is called a "fully dedicated
disk" because BSD uses the entire disk and does not provide a compatibility slice table.
The BSD segment manager recognizes such "fully dedicated disks" and provides mappings for
the BSD partitions.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN902"
></A
>6.2.6. MAC segment manager</H2
><P
>Apple-partitioned disks use a disk label that is recognized by the MAC segment
manager.  The MAC segment manager recognizes the disk label during discovery and 
creates EVMS
segments to map the MacOS disk partitions.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN905"
></A
>6.2.7. BBR segment manager</H2
><P
>The bad block replacement (BBR) segment manager enhances the reliability of
a disk by remapping bad storage blocks.  When BBR is added to a disk, it writes
metadata on the disk that:</P
><P
></P
><UL
><LI
><P
>reserves replacement blocks</P
></LI
><LI
><P
>maps bad blocks to reserved blocks</P
></LI
></UL
><P
>Bad blocks occur when an I/O error is detected for a write operation.
When this happens, I/O normally fails and the failure code is returned to the
calling program code.  BBR detects failed write operations and remaps the I/O to a
reserved block on the disk.  Afterward, BBR restarts the I/O using the reserve block.</P
><P
>Every block of storage has an address, called a logical block address, or LBA.
When BBR is added to a disk, it provides two critical functions: remap and recovery.
When an I/O operation is sent to disk, BBR inspects the LBA in the I/O command to see
if the LBA has been remapped to a reserve block due to some earlier I/O error.
If BBR finds a mapping between the LBA and a reserve block, it updates the I/O
command with the LBA of the reserve block before sending it on to the disk.
Recovery occurs when BBR detects an I/O error and remaps the bad block to a 
reserve block.  The new LBA mapping is saved in BBR metadata so that subsequent
I/O to the LBA can be remapped.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="assignsegex"
></A
>6.3. Adding a segment manager to an existing disk</H1
><P
>When you add a segment manager to a disk, the segment manager 
	needs to change the basic 
	layout of the disk. This change means that some sectors are 
	reserved for metadata and the remaining sectors are
  made available for creating data disk segments. Metadata sectors 
	are written to disk to save information
	needed by the segment manager;  previous information found on the 
	disk is lost. Before adding a 
	segment manager to an existing disk, you must remove any existing 
	volume management structures, including any previous segment manager.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="assignsegnew"
></A
>6.4. Adding a segment manager to a new disk</H1
><P
>When a new disk is added to a system,
	the disk usually contains no data and has not
	  been partitioned. If this is the case, the disk shows up in EVMS as a compatibility volume because 
	  EVMS cannot tell if the disk is being used as a volume. To add a segment manager to the disk so that it 
	can be subdivided into smaller disk segment objects, tell EVMS that the disk is not a
	compatibility volume by deleting the volume information.</P
><P
>If the new disk was moved from another system, chances are good that the disk already contains 
	metadata. If the disk does contain metadata, the disk shows up in EVMS with storage objects that 
	were produced from the existing metadata. Deleting these objects will allow you to add a different 
	segment manager to the disk, and you lose any old data. </P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="assignex"
></A
>6.5. Example: add a segment manager</H1
><P
>This section shows how to add 
a segment manager with EVMS.</P
><P
>EVMS initially displays the
	physical disks it sees as volumes. Assume that you have added a new 
	disk to the system that EVMS 
	sees as <TT
CLASS="filename"
>sde</TT
>. 
	This disk contains no data and has not been subdivided 
	(no partitions). EVMS assumes that this 
	disk is a compatibility volume known as <TT
CLASS="filename"
>/dev/evms/sde</TT
>. </P
><A
NAME="AEN928"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN929"
></A
><P
><B
>Example 6-1. Add the DOS Segment Manager</B
></P
><P
>Add the DOS Segment Manager to disk <TT
CLASS="filename"
>sde</TT
>.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>In the following example, the DOS Segment
		Manager creates two segments on the disk:
		a metadata segment known as <TT
CLASS="filename"
>sde_mbr</TT
>, and a
		segment to represent the available space on
		the drive, <TT
CLASS="filename"
>sde_freespace1</TT
>. This freespace
		segment (<TT
CLASS="filename"
>sde_freespace1</TT
>) can be 
		divided into
		other segments because it represents space on
		the drive that is not in use.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="assignseggui"
></A
>6.5.1. Using the EVMS GUI</H2
><P
>To add the DOS Segment Manager to <TT
CLASS="filename"
>sde</TT
>, first 
remove the volume, <TT
CLASS="filename"
>/dev/evms/sde</TT
>:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Delete</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume</SPAN
>.</P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>/dev/evms/sde</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Delete</SPAN
>.</P
></LI
></OL
><P
>Alternatively, you can remove the volume through the GUI context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Volumes tab</SPAN
>, right click <TT
CLASS="filename"
>/dev/evms/sde</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Delete</SPAN
>.</P
></LI
></OL
><P
>After the volume is removed, add the DOS Segment Manager:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Add</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Segment Manager to Storage Object</SPAN
>.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guilabel"
>DOS Segment Manager</SPAN
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guilabel"
>sde</SPAN
></P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Add</SPAN
></P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="assignsegncur"
></A
>6.5.2. Using Ncurses</H2
><P
>To add the DOS Segment Manager to <TT
CLASS="filename"
>sde</TT
>, first remove the 
volume <TT
CLASS="filename"
>/dev/evms/sde</TT
>:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Delete</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Segment Manager to Storage Object</SPAN
>.</P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>/dev/evms/sde</TT
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Delete</SPAN
>.</P
></LI
></OL
><P
>Alternatively, you can remove the volume through the context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Logical Volumes view, press <B
CLASS="keycap"
>Enter</B
> on 
<TT
CLASS="filename"
>/dev/evms/sde</TT
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Delete</SPAN
>.</P
></LI
></OL
><P
>After the volume is removed, add the DOS Segment Manager:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Add</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Segment Manager to Storage Object</SPAN
></P
></LI
><LI
><P
>Select <SPAN
CLASS="guilabel"
>DOS Segment Manager</SPAN
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guilabel"
>sde</SPAN
>.
</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Add</SPAN
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="assignsegcli"
></A
>6.5.3. Using the CLI</H2
><P
>To add the DOS Segment Manager to sde, first tell EVMS that this disk is not a 
volume and is available for use:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Delete:/dev/evms/sde</PRE
></FONT
></TD
></TR
></TABLE
><P
>Next, add the DOS Segment Manager to sde by typing the following:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Add:DosSegMgr={},sde</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="removeseg"
></A
>6.6. Removing a segment manager</H1
><P
>When a segment manager is removed from a disk, the disk can be reused by
other plug-ins.  The <B
CLASS="command"
>remove</B
> command causes the segment manager to remove its
partition or slice table from the disk, leaving the raw disk storage object that then
becomes an available EVMS storage object.  As an available storage object,
the disk is free to be used by any plug-in when storage objects are created or expanded.
You can also add any of the segment managers to the available disk storage object
to subdivide the disk into segments.</P
><P
>Most segment manager plug-ins check to determine if any of the segments are still in
use by other plug-ins or are still part of volumes.  If a segment manager determines
that there are no disks from which it can safely remove itself, it will not be listed
when you use the <B
CLASS="command"
>remove</B
> command.  In this case, you should delete the
volume or storage object that is consuming segments from the disk you want to reuse.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="rmvex"
></A
>6.7. Example: remove a segment manager</H1
><P
>This section shows how to remove 
a segment manager with EVMS.</P
><A
NAME="AEN1048"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN1049"
></A
><P
><B
>Example 6-2. Remove the DOS Segment Manager</B
></P
><P
>Remove the DOS Segment Manager from disk <TT
CLASS="filename"
>sda</TT
>.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>In the following example, the DOS Segment
		Manager has one primary partition on disk <TT
CLASS="filename"
>sda</TT
>.
		The segment is a compatibility volume known as
		<TT
CLASS="filename"
>/dev/evms/sda1</TT
>.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="removeseggui"
></A
>6.7.1. Using the EVMS GUI context sensitive menu</H2
><P
>Follow these steps to remove a segment manager with the GUI context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Volumes</SPAN
> tab, right click <TT
CLASS="filename"
>/dev/evms/sda1</TT
>..</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Delete</SPAN
>.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Remove</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Segment Manager from Storage Object</SPAN
>.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>DOS Segment Manager, sda</SPAN
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Remove</SPAN
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="removesegcur"
></A
>6.7.2. Using Ncurses</H2
><P
>Follow these steps to remove a segment manager with the Ncurses interface:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Delete</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume</SPAN
>.</P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>/dev/evms/sda1</TT
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Delete</SPAN
>.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Remove</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Segment Manager from Storage Object</SPAN
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Remove</SPAN
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="removesegcli"
></A
>6.7.3. Using the CLI</H2
><P
>Follow these steps to remove a segment manager with the CLI:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Delete:/dev/evms/sda1</PRE
></FONT
></TD
></TR
></TABLE
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Remove: sda</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="evmscreateseg"
></A
>Chapter 7. Creating segments</H1
><P
>This chapter discusses when to use segments and how to create them using 
different EVMS interfaces.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="whyseg"
></A
>7.1. When to create a segment</H1
><P
>A disk can be subdivided into smaller storage objects called disk segments. A segment manager plug-in provides this capability. Another reason for creating disk segments is to maintain compatibility on a dual boot system where the other operating system requires disk partitions. Before creating a disk segment, you must choose a segment manager plug-in to manage the disk and assign 
the segment manager to the disk. An explanation of when and how to assign segment managers can be found in <A
HREF="#evmsassignseg"
>Chapter 6</A
>.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="crsegex"
></A
>7.2. Example: create a segment</H1
><P
> This section provides a detailed explanation of how to create a 
segment with EVMS by providing instructions to help you complete the following task:</P
><A
NAME="AEN1121"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN1122"
></A
><P
><B
>Example 7-1. Create a 100MB segment</B
></P
><P
>Create a 100MB segment from the freespace segment sde_freespace1. This
	freespace segment lies on a drive controlled by the DOS Segment Manager. </P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="guiseg"
></A
>7.2.1. Using the EVMS GUI</H2
><P
>To create a segment using the GUI, follow the steps below:
	<P
></P
><OL
TYPE="1"
><LI
><P
>Select
		<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Segment</SPAN
>
		to see a list of segment manager plug-ins.
		</P
></LI
><LI
><P
>Select
		<SPAN
CLASS="guimenuitem"
>DOS Segment Manager</SPAN
>.
		Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
><P
>The next dialog window lists
		the free space storage objects suitable for creating
		a new segment.</P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>sde_freespace1</TT
>. Click
		<SPAN
CLASS="guibutton"
>Next</SPAN
>. </P
><P
>The last dialog window
		presents the free space object you
		selected as well as the available
		configuration options for that
		object.</P
></LI
><LI
><P
>Enter 100 MB. Required fields are denoted by the
		"*" in front of the field description. The DOS Segment
		Manager provides default values, but you might want to change
		some of these values.</P
><P
>After you have filled in
		information for all the required
		fields, the <SPAN
CLASS="guibutton"
>Create</SPAN
>
		button becomes available.</P
></LI
><LI
><P
>Click 
		<SPAN
CLASS="guibutton"
>Create</SPAN
>.
		A window opens to display the
		outcome.</P
></LI
></OL
></P
><P
>Alternatively, you can perform some of the steps to create a segment from the GUI context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Segments</SPAN
> tab, right click 
on <TT
CLASS="filename"
>sde_freespace1</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Create Segment...</SPAN
></P
></LI
><LI
><P
>Continue beginning with step 4 of the GUI instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="ncurseg"
></A
>7.2.2. Using Ncurses</H2
><P
>To create a segment using Ncurses, follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Segment</SPAN
> to see a list of segment manager plug-ins.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>DOS Segment Manager</SPAN
>. 
	Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
><P
>The next dialog window
	lists free space
	storage objects suitable for creating
	a new segment. </P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>sde_freespace1</TT
>.  Activate <B
CLASS="keycap"
>Next</B
>.</P
></LI
><LI
><P
>Highlight the <SPAN
CLASS="guilabel"
>size field</SPAN
> and press <B
CLASS="keycap"
>spacebar</B
>.</P
></LI
><LI
><P
>At the "::" prompt enter <TT
CLASS="userinput"
><B
>100MB</B
></TT
>. 
	Press <B
CLASS="keycap"
>Enter</B
>. </P
></LI
><LI
><P
>After all required values have been completed, the <SPAN
CLASS="guibutton"
>Create</SPAN
>
	button becomes available.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Create</SPAN
>.</P
></LI
></OL
><P
>Alternatively, you can perform some of the steps to create a segment from the
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Segments view, press <B
CLASS="keycap"
>Enter</B
> on <TT
CLASS="filename"
>sde_freespace1</TT
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guimenuitem"
>Create Segment</SPAN
>.</P
></LI
><LI
><P
>Continue beginning with step 4 of the Ncurses instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="cliseg"
></A
>7.2.3. Using the CLI</H2
><P
>To create a data segment from a
	freespace segment, use the
	<B
CLASS="command"
>Create</B
> command. The arguments the
	<B
CLASS="command"
>Create</B
> command accepts vary
	depending on what is being created.  The first
	argument to the <B
CLASS="command"
>Create</B
>
	command indicates what is to be created, which
	in the above example is a segment. The
	remaining arguments are the freespace segment
	to allocate from and a list of options to pass
	to the segment manager. The command to
	accomplish this is:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Create: Segment,sde_freespace1, size=100MB</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <B
CLASS="command"
>Allocate</B
> command also works to create a segment. </P
></TD
></TR
></TABLE
></DIV
><P
>The previous example accepts the default values for all options you don't specify. To see the options for this command type:<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query:plugins,plugin=DosSegMgr,list options</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="evmscreatecont"
></A
>Chapter 8. Creating a container </H1
><P
>This chapter discusses when and how to create a container. </P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="whencont"
></A
>8.1. When to create a container</H1
><P
>Segments and disks can be combined to form a container. Containers allow 
	you to combine
	storage objects and then subdivide those combined storage objects 
	into new storage objects. You can 
	combine storage objects to implement the volume group concept
	as found in the AIX and Linux logical volume managers.</P
><P
>Containers are the beginning of more flexible 
volume management. You might want to create a container in order to account for flexibility in your future storage needs. For example, you might 
need to add additional disks when your applications or users need more storage. </P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="contex"
></A
>8.2. Example: create a container</H1
><P
>This section provides a detailed explanation of how to create a container with EVMS by providing instructions 
to help you complete the following task.</P
><A
NAME="AEN1230"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN1231"
></A
><P
><B
>Example 8-1. Create "Sample Container"</B
></P
><P
>Given a system with three available disk drives 
(<TT
CLASS="filename"
>sdc</TT
>, <TT
CLASS="filename"
>sdd</TT
>, <TT
CLASS="filename"
>hdc</TT
>),
 use the EVMS LVM Region Manager to combine these disk drives into a 
container called "Sample Container" with a PE size of 16 MB. </P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="guicont"
></A
>8.2.1. Using the EVMS GUI</H2
><P
>To create a container using the EVMS GUI, follow these steps:	
	<P
></P
><OL
TYPE="1"
><LI
><P
>Select
		<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
>
		to see a list plug-ins that support container creation.</P
></LI
><LI
><P
>Select the
		<SPAN
CLASS="guimenu"
>LVM Region Manager</SPAN
>. Click
		<SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
><P
>The next dialog window contains a list of storage objects
		that the LVM Region Manager can use to create a container. </P
></LI
><LI
><P
>Select <SPAN
CLASS="guilabel"
>sdc</SPAN
>, <SPAN
CLASS="guilabel"
>sdd</SPAN
>, and 
		<SPAN
CLASS="guilabel"
>hdc</SPAN
> from the list. Click
		<SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Enter the name <TT
CLASS="userinput"
><B
>Sample Container</B
></TT
> 
		for the container and <TT
CLASS="userinput"
><B
>16MB</B
></TT
> in the 
		<SPAN
CLASS="guilabel"
>PE size</SPAN
> field.</P
></LI
><LI
><P
>Click
		<SPAN
CLASS="guibutton"
>Create</SPAN
>.
		A window opens to display the
		outcome.</P
></LI
></OL
>
	</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="ncurcont"
></A
>8.2.2. Using Ncurses</H2
><P
>To create a container using the Ncurses interface, follow these 
steps:
	<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
>
		to see a list of plug-ins that support container creation.</P
></LI
><LI
><P
>Select the
 		<SPAN
CLASS="guimenuitem"
>LVM Region Manager</SPAN
>. Activate
 		<B
CLASS="keycap"
>Next</B
>. </P
><P
>The next dialog window contains a list
		of storage objects that the LVM Region Manager can use to
		create the container.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guilabel"
>sdc</SPAN
>, <SPAN
CLASS="guilabel"
>sdd</SPAN
>, and 
		<SPAN
CLASS="guilabel"
>hdc</SPAN
> from the list.  Activate
		<SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>spacebar</B
> to select the field for
		the container name.	</P
></LI
><LI
><P
>Type <TT
CLASS="userinput"
><B
>Sample Container</B
></TT
> at the "::" prompt. Press
		<B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Scroll down until <SPAN
CLASS="guilabel"
>PE Size</SPAN
> is highlighted. 
		Press <B
CLASS="keycap"
>spacebar</B
>.</P
></LI
><LI
><P
>Scroll down until <SPAN
CLASS="guilabel"
>16MB</SPAN
> is highlighted. 
		Press  <B
CLASS="keycap"
>spacebar</B
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>OK</SPAN
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Create</SPAN
>.</P
></LI
></OL
>
   </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="clicont"
></A
>8.2.3. Using the CLI</H2
><P
>The <B
CLASS="command"
>Create</B
> command 
	creates containers.  The first argument
	in the <B
CLASS="command"
>Create</B
> command is the type of object to
	produce, in this case a container.  The
	<B
CLASS="command"
>Create</B
> command then accepts
	the following arguments: the region manager to
	use along with any parameters it might need, and
	the segments or disks to create the container
	from. The command to complete the previous example is:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Create:Container,LvmRegMgr={name="Sample Container",pe_size=16MB},sdc,sdd,hdc
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The previous example accepts the default values for all options 
you don't specify. To see the options for this command type:
 <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query:plugins,plugin=LvmRegMgr,list options</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="evmscreatereg"
></A
>Chapter 9. Creating regions</H1
><P
>Regions can be created from containers, but they can also be created from other
regions, segments, or disks.  Most region managers that support containers create one or more
freespace regions to represent the freespace within the container. This function is
analogous to the way a segment manager creates a freespace segment to represent unused disk
space.  </P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1320"
></A
>9.1. When to create regions</H1
><P
>You can create regions because you want the features provided by 
a certain region manager or because you want the features provided by 
that region manager. You can also create regions to be compatible with 
other volume management technologies, such as MD or LVM. 
For example, if you wanted to make a volume that is compatible with Linux LVM, 
you would create a region out of a Linux LVM container and then a compatibility volume from that region.  </P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="crregex"
></A
>9.2. Example: create a region</H1
><P
>This section tells how to create a region with EVMS by 
providing instructions to help you complete the following task.</P
><A
NAME="AEN1326"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN1327"
></A
><P
><B
>Example 9-1. Create "Sample Region"</B
></P
><P
>Given the container "Sample Container," which has a freespace region of 
8799 MB, create a data region 1000 MB in size named "Sample Region."</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="guireg"
></A
>9.2.1. Using the EVMS GUI</H2
><P
>To create a region, follow these steps:
	<P
></P
><OL
TYPE="1"
><LI
><P
>Select
		<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Region</SPAN
>
</P
></LI
><LI
><P
>Select
		the <SPAN
CLASS="guisubmenu"
>LVM Region
		Manager</SPAN
>. Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>You might
		see additional region managers that were
			not in the selection list when you were creating the storage container
			 because not all region
			managers are required to support containers.</P
></TD
></TR
></TABLE
></DIV
></LI
><LI
><P
>Select the freespace region from
			the container you created in 
			<A
HREF="#evmscreatecont"
>Chapter 8</A
>.
			Verify that the region is named  
			<TT
CLASS="filename"
>lvm/Sample Container/Freespace</TT
>.
				Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
><P
>The fields in the next window are the options for the
				LVM Region Manager plug-in, the options marked with an "*" are required. </P
></LI
><LI
><P
>Fill in the name, <TT
CLASS="userinput"
><B
>Sample Region</B
></TT
>.</P
></LI
><LI
><P
>Enter <TT
CLASS="userinput"
><B
>1000MB</B
></TT
> in the <SPAN
CLASS="guilabel"
>size</SPAN
> field.</P
></LI
><LI
><P
>Click the
				<SPAN
CLASS="guibutton"
>Create</SPAN
> button to complete the
				operation. A window opens to display the outcome.</P
></LI
></OL
>
		      </P
><P
>Alternatively, you can perform some of the steps for creating a region with the GUI context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Regions</SPAN
> tab, right click 
	<TT
CLASS="filename"
>lvm/Sample Container/Freespace</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Create Region</SPAN
>.</P
></LI
><LI
><P
>Continue beginning with step 4 of the GUI instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="ncurreg"
></A
>9.2.2. Using Ncurses</H2
><P
>To create a region, follow these steps:
			<P
></P
><OL
TYPE="1"
><LI
><P
>Select
				<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Region</SPAN
>.</P
></LI
><LI
><P
>Select the
				<SPAN
CLASS="guimenuitem"
>LVM Region
				Manager</SPAN
>. Activate <B
CLASS="keycap"
>Next</B
>.</P
></LI
><LI
><P
>Select the freespace
				region from the container you created
				earlier in <A
HREF="#evmscreatecont"
>Chapter 8</A
>. Verify that
				the region is named 
				<TT
CLASS="filename"
>lvm/Sample Container/Freespace</TT
>.</P
></LI
><LI
><P
>Scroll to the <SPAN
CLASS="guilabel"
>Name</SPAN
> field, and press 
				<B
CLASS="keycap"
>spacebar</B
>.</P
></LI
><LI
><P
>Type <TT
CLASS="userinput"
><B
>Sample Region</B
></TT
> at the "::" prompt. 
				Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Scroll to the <SPAN
CLASS="guilabel"
>size</SPAN
> field, 
				and press <B
CLASS="keycap"
>spacebar</B
>.</P
></LI
><LI
><P
>Type <TT
CLASS="userinput"
><B
>1000MB</B
></TT
> at the "::" prompt. 
				Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Create</SPAN
>.</P
></LI
></OL
>
			</P
><P
>Alternatively, you can perform some of the steps for creating a region with the
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Storage Regions view, press <B
CLASS="keycap"
>Enter</B
> on
<TT
CLASS="filename"
>lvm/Sample Container/Freespace</TT
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Create Region</SPAN
> menu item.</P
></LI
><LI
><P
>Continue beginning with step 4 of the Ncurses instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="clireg"
></A
>9.2.3. Using the CLI</H2
><P
>Create regions with the <B
CLASS="command"
>Create</B
>
			command. Arguments to the <B
CLASS="command"
>Create </B
>command are
			the following: keyword Region, the name of the
			region manager to use, the region managers
			options, and the objects to consume. The form of this command is:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Create:region, LvmRegMgr={name="Sample Region", size=1000MB},
"lvm/Sample Container/Freespace"</PRE
></FONT
></TD
></TR
></TABLE
><P
>The LVM Region Manager supports many
			options for creating regions. To see the
			available options for creating regions and
			containers, use the following <B
CLASS="command"
>Query</B
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query:plugins,plugin=LvmRegMgr,list options</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="evmscreatedrivelinking"
></A
>Chapter 10. Creating drive links</H1
><P
>This chapter discusses the EVMS drive linking feature, which is
implemented by the drive link plug-in, and tells how to create, expand, shrink,
and delete a drive link.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="whatisdrivelinking"
></A
>10.1. What is drive linking?</H1
><P
>Drive linking linearly concatenates objects, allowing you to
create larger storage objects and volumes from smaller individual pieces.
For example, say you need a 1 GB volume but do
not have contiguous space available of that length.  Drive linking lets you 
link two or more objects together to form the 1 GB volume.</P
><P
>&#13;The types of objects that can be drive linked include disks, segments, 
regions, and other feature objects. 
</P
><P
>&#13;Any resizing of an existing drive link, whether to grow it or shrink it,
must be coordinated with the appropriate file system operations.
EVMS handles these file system operations automatically.
</P
><P
> 
Because drive linking is an EVMS-specific feature that contains EVMS metadata, 
it is not backward compatible with other volume-management schemes.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="howimp"
></A
>10.2. How drive linking is implemented</H1
><P
>The drive link plug-in consumes storage objects, called link
objects, which produce a larger drive link object whose address space spans
the link objects.
The drive link plug-in knows how to assemble the link objects so as to 
create the exact same address space every time.
The information required to do this is kept on each link child as persistent
drive-link metadata.
During discovery, the drive link plug-in inspects each known storage
object for this metadata.
The presence of this metadata identifies the storage object as a link object.
The information contained in the metadata is sufficient to:</P
><P
></P
><UL
><LI
><P
>Identify the link object itself.</P
></LI
><LI
><P
>Identify the drive link storage object that the link object belongs to.
</P
></LI
><LI
><P
>Identify all link objects belonging to the drive link storage.
object</P
></LI
><LI
><P
>Establish the order in which to combine the child link objects.</P
></LI
></UL
><P
>If any link objects are missing at the conclusion of the discovery
process, the drive link storage object contains gaps where the missing
link objects occur.
In such cases, the drive link plug-in attempts to fill in the gap with a
substitute link object and construct the drive link storage object in
read-only mode, which allows for recovery action.
The missing object might reside on removable storage that has been removed or
perhaps a lower layer plug-in failed to produce the missing object.
Whatever the reason, a read-only drive link storage object, together
logging errors, help you take the appropriate actions to recover the drive link.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1453"
></A
>10.3. Creating a drive link</H1
><P
>The drive link plug-in provides a list of acceptable objects from
which it can create a drive-link object.
When you create an EVMS storage object and then choose the drive
link plug-in, a list of acceptable objects is provided that you can choose
from.
The ordering of the drive link is implied by the order in which you pick 
objects from the provided list.
After you provide a name for the new drive-link object, the identified
link objects are consumed and the new drive-link object is produced. 
The name for the new object is the only option when creating a drive-link.
</P
><P
>Only the last object in a drive link
can be expanded, shrunk or removed.  Additionally, a new object can be added to the
end of an existing drive link only if the file system (if one exists) permits.
Any resizing of a drive link, whether to grow it or shrink it, must be coordinated with the
appropriate file system operations.  EVMS handles these file system operations
automatically.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="drivelinkex"
></A
>10.4. Example: create a drive link</H1
><P
> This section shows how to create a drive link with EVMS:</P
><A
NAME="AEN1460"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN1461"
></A
><P
><B
>Example 10-1. Create a drive link</B
></P
><P
>Create a new drive link consisting of <TT
CLASS="filename"
>sde4</TT
> and <TT
CLASS="filename"
>hdc2</TT
>, and call it "dl."</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="guidrivelinking"
></A
>10.4.1. Using the EVMS GUI</H2
><P
>To create the drive link using the GUI, follow these steps:
	<P
></P
><OL
TYPE="1"
><LI
><P
>Select
		<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Feature Object</SPAN
>
		to see a list of EVMS features.
		</P
></LI
><LI
><P
>Select
		<SPAN
CLASS="guimenuitem"
>Drive Linking Feature</SPAN
>.
		</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Click the objects you want to compose the drive link: 
		sde4 and hdc2.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Type <TT
CLASS="filename"
>dl</TT
> in the "name" field</P
></LI
><LI
><P
>Click
		<SPAN
CLASS="guibutton"
>Create</SPAN
>. </P
><P
>The last dialog window
		presents the free space object you
		selected as well as the available
		configuration options for that
		object.</P
></LI
></OL
></P
><P
>Alternatively, you can perform some of the steps to create a drive link with the GUI
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Available Objects</SPAN
> tab, 
	right click <TT
CLASS="filename"
>sde4</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Create Feature Object...</SPAN
></P
></LI
><LI
><P
>Continue creating the drive link beginning with step 2 of the GUI
	instructions.  In step 4, <TT
CLASS="filename"
>sde4</TT
> is selected for you.  You can also
	select <TT
CLASS="filename"
>hdc2</TT
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="ncursdrivelink"
></A
>10.4.2. Using Ncurses</H2
><P
>To create the drive link, follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Feature Object</SPAN
> to see a list of EVMS features.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>Drive Linking Feature</SPAN
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Use <B
CLASS="keycap"
>spacebar</B
> 
			 to select the objects you want to compose the drive
				link from: <TT
CLASS="filename"
>sde4</TT
> and <TT
CLASS="filename"
>hdc2</TT
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Press 
				<B
CLASS="keycap"
>spacebar</B
> to edit the Name field.</P
></LI
><LI
><P
>Type <TT
CLASS="userinput"
><B
>dl</B
></TT
> at the "::" prompt. 
				Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Create</SPAN
>.</P
></LI
></OL
><P
>Alternatively, you can perform some of the steps to create a drive link with the
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Available Objects view, press <B
CLASS="keycap"
>Enter</B
> on <TT
CLASS="filename"
>sde4</TT
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Create Feature Object</SPAN
> menu item.</P
></LI
><LI
><P
>Continue creating the drive link beginning with step 4 of the Ncurses
instructions.  <TT
CLASS="filename"
>sde4</TT
> will be pre-selected.  You can also select <TT
CLASS="filename"
>hdc2</TT
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="drlinkseg"
></A
>10.4.3. Using the CLI</H2
><P
>Use the
	<B
CLASS="command"
>create</B
> command to create a drive link through the CLI.  You pass the "object" keyword to the <B
CLASS="command"
>create</B
> command, followed by the plug-in and its options, and finally the objects.</P
><P
>To determine the options for the plug-in you are going to use, issue the following command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query: plugins, plugin=DriveLink, list options</PRE
></FONT
></TD
></TR
></TABLE
><P
>Now construct the <B
CLASS="command"
>create</B
> command, as follows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>create: object, DriveLink={Name=dl}, sde4, hdc2</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="expandpartitions"
></A
>10.5. Expanding a drive link</H1
><P
>&#13;A drive link is an aggregating storage object that is built by combining a number of
storage objects into a larger resulting object.  A drive link consumes link objects in order
to produce a larger storage object.  The ordering of the link objects as well as the
number of sectors they each contribute is described by drive link metadata.  The metadata
allows the drive link plug-in to recreate the drive link, spanning the link objects in a
consistent manner.  Allowing any of these link objects to expand would corrupt the
size and ordering of link objects; the ordering of link objects is vital to the correct
operation of the drive link.  However, expanding a drive link can be controlled by only
allowing sectors to be added at the end of the drive link storage object.  This does not
disturb the ordering of link objects in any manner and, because sectors are only added
at the end of the drive link, existing sectors have the same address (logical sector
number) as before the expansion.  Therefore, a drive link can be expanded by adding
additional sectors in two different ways:</P
><P
></P
><UL
><LI
><P
>&#13;By adding an additional storage object to the end of the drive link.
</P
></LI
><LI
><P
>&#13;By expanding the last storage object in the drive link.
</P
></LI
></UL
><P
>&#13;If the expansion point is the drive link storage object, you can perform the
expansion by adding an additional storage object to the drive link.  This is done
by choosing from a list of acceptable objects during the expand operation. Multiple objects 
can be selected and added to the drive link.
</P
><P
>&#13;If the expansion point is the last storage object in the drive link, then you expand the
drive link by interacting with the plug-in that produced the object.  For example, if
the link was a segment, then the segment manager plug-in that produced the storage
object expands the link object.  Afterwords, the drive link plug-in notices the size
difference and updates the drive link metadata to reflect the resize of the child object.</P
><P
>&#13;There are no expand options.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="shrinkdrivelink"
></A
>10.6. Shrinking a drive link</H1
><P
>&#13;Shrinking a drive link has the same restrictions as expanding a drive link.  A drive link
object can only be shrunk by removing sectors from the end of the drive link.  This can
be done in the following ways:
<P
></P
><UL
><LI
><P
>By removing link objects from the end of the drive link.</P
></LI
><LI
><P
>By shrinking the last storage object in the drive link.</P
></LI
></UL
>
</P
><P
>&#13;The drive link plug-in attempts to orchestrate the shrinking of a 
drive-link storage object by only listing the last link object.
If you select this object, the drive link plug-in then lists the next-to-last 
link object, and so forth, moving backward through the link
objects to satisfy the shrink command.
</P
><P
>If the shrink point is the last storage object in the drive link, then you shrink the
drive link by interacting with the plug-in that produced the object.</P
><P
>&#13;There are no shrink options.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="deletedrivelink"
></A
>10.7. Deleting a drive link</H1
><P
>&#13;A drive link can be deleted as long as it is not currently a
compatibility volume, an EVMS volume, or consumed by another EVMS plug-in.
</P
><P
>&#13;No options are available for deleting a drive link storage object.
</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="evmscreatesnap"
></A
>Chapter 11. Creating snapshots</H1
><P
>This chapter discusses snapshotting and tells how to create 
a snapshot.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="whatissnapshotting"
></A
>11.1. What is a snapshot?</H1
><P
>A snapshot represents a frozen image of a volume.  
The source of a snapshot is
called an "original."  
When a snapshot is created, it looks exactly like the original
at that point in time.  
As changes are made to the original, the snapshot remains the
same and looks exactly like the original at the time the snapshot was 
created.
</P
><P
>&#13;Snapshotting allows you to keep a volume online while a backup is created.
This method is much more convenient than a data backup where a volume
must be taken offline to perform a consistent backup.
When snapshotting, a snapshot of the volume is created and the backup
is taken from the snapshot, while the original remains in active use.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="createactivsnap"
></A
>11.2. Creating snapshot objects</H1
><P
>You can create a snapshot object from any unused storage object in EVMS
(disks, segments, regions, or feature objects).  
The size of this consumed object is
the size available to the snapshot object.  The snapshot object can be smaller
or larger than the original volume.  
If the object is smaller, the snapshot volume could fill up as data is copied
from the original to the snapshot, given sufficient activity on the original. 
In this situation, the snapshot is deactivated and additional 
I/O to the snapshot fails.
</P
><P
>Base the size of the snapshot object on the amount of activity that 
is likely to take place on the original during the lifetime of the snapshot.  
The more changes that occur on the
original and the longer the snapshot is expected to remain active, 
the larger the snapshot object should be.  
Clearly, determining this calculation is not simple and requires trial and 
error to determine the correct snapshot object size to use for a 
particular situation.  
The goal is to create a snapshot object large enough to prevent the 
shapshot from being
deactivated if it fills up, yet small enough to not waste disk space.  
If the snapshot
object is the same size as the original volume, or a little larger, 
to account for the snapshot mapping tables, the snapshot is 
never deactivated.
</P
><P
>After you've created the snapshot object and saved the changes, the
snapshot will be activated (as long as the snapshot child object is already active).
This is a change from snapshots in EVMS 2.3.x and earlier, where the snapshot
would not be activated until the object was made into an EVMS volume.  If you
wish to have an inactive snapshot, please add the name of the snapshot object
to the "activate.exclude" line in the EVMS configuration file (see section about
selective-activation for more details).  If at any point you decide to deactivate a
snapshot object while the original volume is still active, the snapshot will be reset.
The next time that the snapshot object is activated, it will reflect the state of the
original volume at that point in time, just as if the snapshot had just been created.</P
><P
>In order to mount the snapshot, the snapshot object must still be made into an
EVMS volume.  The name of this volume can be the same as or different than the
name of the snapshot object.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="snapshotex"
></A
>11.3. Example: create a snapshot</H1
><P
> This section shows how to create a snapshot with EVMS:</P
><A
NAME="AEN1606"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN1607"
></A
><P
><B
>Example 11-1. Create a snapshot of a volume</B
></P
><P
>Create a new snapshot of <TT
CLASS="filename"
>/dev/evms/vol</TT
> on 
<TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>, and call 
it "snap."</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="guisnapshot"
></A
>11.3.1. Using the EVMS GUI</H2
><P
>To create the snapshot using the GUI, follow these steps:
	<P
></P
><OL
TYPE="1"
><LI
><P
>Select
		<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Feature Object</SPAN
>
		to see a list of EVMS feature objects.
		</P
></LI
><LI
><P
>Select
		<SPAN
CLASS="guimenuitem"
>Snapshot Feature</SPAN
>.
		</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>lvm/Sample Container/Sample Region</SPAN
>. 			</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>/dev/evms/vol</SPAN
> from the list in the
		"Volume to be Snapshotted" field.</P
></LI
><LI
><P
>Type <TT
CLASS="filename"
>snap</TT
> in the "Snapshot Object Name" field.
		</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Create</SPAN
>.
		</P
></LI
></OL
></P
><P
>Alternatively, you can perform some of the steps to create a snapshot with the GUI
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Available Objects</SPAN
> tab, right click
	<SPAN
CLASS="guimenuitem"
>lvm/Sample Container/Sample Region</SPAN
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Create Feature Object...</SPAN
></P
></LI
><LI
><P
>Continue creating the snapshot beginning with step 2 of the
	GUI instructions.  You can skip steps 4 and 5 of the GUI instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="ncursnapshot"
></A
>11.3.2. Using Ncurses</H2
><P
>To create the snapshot, follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Feature Object</SPAN
>
			to see a list of EVMS feature objects.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>Snapshot Feature</SPAN
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>lvm/Sample Container/Sample Region.</TT
></P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Press 
				<B
CLASS="keycap"
>spacebar</B
> to edit the "Volume to be Snapshotted" field.</P
></LI
><LI
><P
>Highlight <TT
CLASS="filename"
>/dev/evms/vol</TT
> and press <B
CLASS="keycap"
>spacebar</B
> to select.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>OK</SPAN
>.</P
></LI
><LI
><P
>Highlight "Snapshot Object Name" and press <B
CLASS="keycap"
>spacebar</B
> to edit.</P
></LI
><LI
><P
>Type <TT
CLASS="userinput"
><B
>snap</B
></TT
> at the "::" prompt. 
				Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Create</SPAN
>.</P
></LI
></OL
><P
>Alternatively, you can perform some of the steps to create a snapshot with the
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Available Objects view, press <B
CLASS="keycap"
>Enter</B
> on <TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Create Feature Object</SPAN
> menu item.</P
></LI
><LI
><P
>Continue creating the snapshot beginning with step 6 of the Ncurses
instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="clisnapshot"
></A
>11.3.3. Using the CLI</H2
><P
>Use the
	<B
CLASS="command"
>create</B
> command to create a snapshot through the CLI.  You pass the "Object" keyword to the <B
CLASS="command"
>create</B
> command, followed by the plug-in and its options, and finally the objects. </P
><P
>To determine the options for the plug-in you are going to use, issue the following command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query: plugins, plugin=Snapshot, list options</PRE
></FONT
></TD
></TR
></TABLE
><P
>Now construct the <B
CLASS="command"
>create</B
> command, as follows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>create: object, Snapshot={original=/dev/evms/vol, snapshot=snap}, 
"lvm/Sample Container/Sample Region"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1717"
></A
>11.4. Reinitializing a snapshot</H1
><P
>Snapshots can be reinitialized. Reinitializing causes all of the 
saved data to be erased and
starts the snapshot from the current point in time.  
A reinitialized snapshot has the same
original, chunk size, and writeable flags as the original 
snapshot.</P
><P
>To reinitialize a snapshot, use the <B
CLASS="command"
>Reset</B
> 
command on the snapshot object
(not the snapshot volume).  
This command reinitializes the snapshot without requiring you to
manually deactivate and reactivate the volume.
The snapshot must be active but unmounted for it to be reinitialized.
</P
><P
>This section continues the example from the previous section, 
where a snapshot object and volume were created.  
The snapshot object is called "snap" and the volume
is called "/dev/evms/snap."</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1723"
></A
>11.4.1. Using the EVMS GUI or Ncurses</H2
><P
>To reinitialize a snapshot, follow these steps:
<P
></P
><OL
TYPE="1"
><LI
><P
>Select
		<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Other</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Storage Object Tasks</SPAN
>
		</P
></LI
><LI
><P
>Select the volume "snap."</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guibutton"
>Reset</SPAN
>.</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Reset</SPAN
> on the action panel.
		</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Reset</SPAN
> on the warning panel.</P
></LI
></OL
>

</P
><P
>Alternatively, you can perform these same steps with the context sensitive menus:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Feature Objects panel, right click (or press <B
CLASS="keycap"
>Enter</B
> on) 
the object <SPAN
CLASS="guimenuitem"
>snap</SPAN
>.
</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Reset</SPAN
> on the popup menu.</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Reset</SPAN
> on the action panel.</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Reset</SPAN
> on the warning panel.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1765"
></A
>11.4.2. Using the CLI</H2
><P
>Follow these steps to reinitialize a snapshot with the CLI:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Issue the following command to the CLI:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>task:reset,snap</PRE
></FONT
></TD
></TR
></TABLE
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
> to select "Reset" (the default choice) at the warning message.</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1775"
></A
>11.5. Expanding a snapshot</H1
><P
>&#13;As mentioned in <A
HREF="#createactivsnap"
>Section 11.2</A
>, as data is 
copied from the original volume to the snapshot, the space available
for the snapshot might fill up, causing the snapshot to be invalidated.
This situation might cause your data backup to end prematurely, as the
snapshot volume begins returning I/O errors after it is invalidated.
</P
><P
>&#13;To solve this problem, EVMS now has the ability to expand the storage
space for a snapshot object while the snapshot volume is active and mounted.
This feature allows you to initially create a small snapshot object and expand
the object as necessary as the space begins to fill up.
</P
><P
>&#13;In order to expand the snapshot object, the underlying object must
be expandable.
Continuing the example from the previous sections, the object "snap" is
built on the LVM region <TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>.
When we refer to expanding the "snap" object, the region
<TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
> is the 
object that actually gets
expanded, and the object "snap" simply makes use of the new space on
that region.
Thus, to have expandable snapshots, you will usually want to build
your snapshot objects on top of LVM regions that have extra freespace
available in their LVM container.  DriveLink objects and some disk
segments also work in certain situations.
</P
><P
>&#13;One notable quirk about expanding snapshots is that the snapshot
object and volume do not actually appear to expand after the operation
is complete.
Because the snapshot volume is supposed to be a frozen image of the original
volume, the snapshot volume always has the same size as the original,
even if the snapshot has been expanded.
However, you can verify that the snapshot object is using the
additional space by displaying the details for the snapshot object
and comparing the percent-full field before and after the expand operation.
</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1784"
></A
>11.5.1. Using the EVMS GUI or Ncurses</H2
><P
>To create the snapshot using the GUI or Ncurses, follow these steps:
	<P
></P
><OL
TYPE="1"
><LI
><P
>Select
		<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Expand</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume</SPAN
>
		to see a list of EVMS feature objects.
		</P
></LI
><LI
><P
>Select the volume <SPAN
CLASS="guimenuitem"
>/dev/evms/snap</SPAN
>.</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>lvm/Sample Container/Sample Region</SPAN
>.
		This object is the object that will actually be expanded.	</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select the options for expanding the LVM region,
		including the amount of extra space to add to the region.
		</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Expand</SPAN
>.
		</P
></LI
></OL
></P
><P
>Alternatively, you can perform the same steps using the context sensitive menus.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guilabel"
>Volumes</SPAN
> panel, right click (or press <B
CLASS="keycap"
>Enter</B
> on) 
<SPAN
CLASS="guimenuitem"
>/dev/evms/snap</SPAN
>.
</P
></LI
><LI
><P
>Select <SPAN
CLASS="guibutton"
>Expand</SPAN
> from the popup menu.</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select the region <SPAN
CLASS="guimenuitem"
>lvm/Sample Container/Sample Region</SPAN
>. This is the object that will
actually be expanded.</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select the options for expanding the LVM region, including the
amount of extra space to add to the region.</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Expand</SPAN
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1835"
></A
>11.5.2. Using the CLI</H2
><P
>The CLI expands volumes by targeting the object to be
expanded.
The CLI automatically handles expanding the volume and other objects above the volume
in the volume stock.  As with a regular expand operation, the options are determined
by the plug-in that owns the object being expanded.</P
><P
>Issue the following command to determine the expand options for the
region <TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query:region,region="lvm/Sample Container/Sample Region",lo</PRE
></FONT
></TD
></TR
></TABLE
><P
>The option to use for expanding this region is called "add_size."
Issue the following command to expand the snapshot by 100 MB:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>expand:"lvm/Sample Container/Sample Region", add_size=100MB</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1843"
></A
>11.6. Deleting a snapshot</H1
><P
>When a snapshot is no longer needed, you can remove it by deleting the EVMS
volume from the snapshot object, and then deleting the snapshot object.  Because the
snapshot saved the initial state of the original volume (and not the changed state),
the original is always up-to-date and does not need any modifications when a snapshot
is deleted.</P
><P
>No options are available for deleting snapshots.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1847"
></A
>11.7. Rolling back a snapshot</H1
><P
>Situations can arise where a user wants to restore the original volume to
the saved state of the snapshot.  This action is called a rollback.  One such scenario
is if the data on the original is lost or corrupted.  Snapshot rollback acts as a quick
backup and restore mechanism, and allows the user to avoid a more lengthy restore
operation from tapes or other archives.</P
><P
>Another situation where rollback can be particularly useful is when you are
testing new software.  Before you install a new software package, create a writeable
snapshot of the target volume.  You can then install the software to the snapshot
volume, instead of to the original, and then test and verify the new software on the
snapshot.  If the testing is successful, you can then roll back the snapshot to the
original and effectively install the software on the regular system.  If there is a problem
during the testing, you can simply delete the snapshot without harming the original
volume.</P
><P
>You can perform a rollback when the following conditions are met:
</P
><P
></P
><UL
><LI
><P
>&#13;Both the snapshot and the original volumes
are unmounted and otherwise not in use.  
</P
></LI
><LI
><P
>&#13;There is only a single snapshot of an original.</P
><P
>&#13;If an original has multiple snapshots,
all but the desired snapshot must be deleted before rollback can take place.
</P
></LI
></UL
><P
>No options are available for rolling back snapshots.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1859"
></A
>11.7.1. Using the EVMS GUI or Ncurses</H2
><P
>Follow these steps to roll back a snapshot with the EVMS GUI or Ncurses:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select 
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Other</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Storage Object Tasks</SPAN
>+.+
+ </P
></LI
><LI
><P
>Select the object "snap."</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guibutton"
>Rollback</SPAN
></P
>.</LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Rollback</SPAN
> on the action panel.
</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Rollback</SPAN
> on the warning panel.
</P
></LI
></OL
><P
>Alternatively, you can perform these same steps with the context-sensitive menus:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Feature Objects panel, right click (or press 
<B
CLASS="keycap"
>Enter</B
> on) the object "snap."</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Rollback</SPAN
> on the popup menu.</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Rollback</SPAN
> on the action panel.</P
></LI
><LI
><P
>Click or activate <SPAN
CLASS="guibutton"
>Rollback</SPAN
> on the warning panel.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1900"
></A
>11.7.2. Using the CLI</H2
><P
>Follow these steps to roll back a snapshot with the CLI:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Issue the following command to the CLI:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>task:rollback,snap</PRE
></FONT
></TD
></TR
></TABLE
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
> to select "Rollback" (the default choice) at the warning message.</P
></LI
></OL
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="evmscreatevol"
></A
>Chapter 12. Creating volumes</H1
><P
>This chapter discusses when and how to create volumes.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1913"
></A
>12.1. When to create a volume</H1
><P
>EVMS treats volumes and storage objects separately. 
A storage object does not automatically 
become a volume; it must be made into a volume.</P
><P
>Volumes are created from storage objects.
	Volumes are either EVMS native volumes or compatibility volumes.  Compatibility volumes
	are intended to be compatible with a volume manager other than EVMS, such as the Linux
	LVM, MD, OS/2 or AIX. Compatibility volumes might have restrictions on what EVMS can do with
	them.  EVMS native volumes have no such restrictions, but they can be used only by an
	EVMS equipped system. Volumes are mountable and can contain file systems.</P
><P
>EVMS native volumes contain EVMS-specific information to identify
	the volume name.  After this volume information is
	applied, the volume is no longer fully backward compatible
	with existing volume types.</P
><P
>Instead of
	adding EVMS metadata to an existing object, you can tell EVMS to make an object directly available as a volume. This type of
	volume is known as a compatibility volume. Using this method, the final product is fully
	backward-compatible with the desired system. </P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="crvolexcomp"
></A
>12.2. Example: create an EVMS native volume</H1
><P
>This section provides a detailed explanation of how to create an EVMS native
	volume with EVMS by providing instructions to help you complete the following task.</P
><A
NAME="AEN1922"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN1923"
></A
><P
><B
>Example 12-1. Create an EVMS native volume </B
></P
><P
>Create an EVMS native volume called "Sample Volume" from the region, <TT
CLASS="filename"
>/lvm/Sample Container/Region</TT
>, you created in <A
HREF="#evmscreatereg"
>Chapter 9</A
>.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="evmsguivol"
></A
>12.2.1. Using the EVMS GUI</H2
><P
>Follow these instructions to create an EVMS volume:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>EVMS Volume</SPAN
>.</P
></LI
><LI
><P
>Choose <TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>.
			</P
></LI
><LI
><P
>Type <TT
CLASS="userinput"
><B
>Sample Volume</B
></TT
> in the 
			<SPAN
CLASS="guilabel"
>name field</SPAN
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Create</SPAN
>.</P
></LI
></OL
><P
>Alternatively, you can perform some of the steps to create an EVMS
volume from the GUI context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Available Options</SPAN
> tab, right click
	<TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Create EVMS Volume...</SPAN
></P
></LI
><LI
><P
>Continue beginning with step 3 of the GUI instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="ncurevmsvol"
></A
>12.2.2. Using Ncurses</H2
><P
>To create a volume, follow these steps:
	<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>EVMS Volume</SPAN
>.</P
></LI
><LI
><P
>Enter <TT
CLASS="userinput"
><B
>Sample Volume</B
></TT
> at the "name" prompt. 
		Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Create</SPAN
>.</P
></LI
></OL
>
   	</P
><P
>Alternatively, you can perform some of the steps to create an EVMS volume
from the context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Available Objects view, press <B
CLASS="keycap"
>Enter</B
> on 
<TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Create EVMS Volume</SPAN
> menu item.</P
></LI
><LI
><P
>Continue beginning with step 3 of the Ncurses instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1987"
></A
>12.2.3. Using the CLI</H2
><P
>To create a volume, use the <B
CLASS="command"
>Create</B
> command. The arguments 
		the <B
CLASS="command"
>Create</B
> command accepts vary depending on what is being created. In 
		the case of the example, the first argument is the key word <TT
CLASS="option"
>volume</TT
> that
		specifies what is being created. The second argument is the object being made into a volume, 
		in this case <TT
CLASS="option"
>lvm/Sample Container/Sample Region</TT
>. 
		The third argument is type specific for an EVMS 
		volume, <TT
CLASS="option"
>Name=</TT
>, followed by what 
		you want to call the volume, in this case <TT
CLASS="option"
>Sample Volume</TT
>. The following command 
		creates the volume from the example. </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Create: Volume, "lvm/Sample Container/Sample Region", Name="Sample Volume"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="crvolexevms"
></A
>12.3. Example: create a compatibility volume</H1
><P
>This section provides a detailed explanation of how to create a compatibility 
	volume with EVMS by providing instructions to help you complete the following task.</P
><A
NAME="AEN2000"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN2001"
></A
><P
><B
>Example 12-2. Create a compatibility volume</B
></P
><P
>Create a compatibility volume called "Sample Volume" from 
	the region, <TT
CLASS="filename"
>/lvm/Sample Container/Region</TT
>, you created in <A
HREF="#evmscreatereg"
>Chapter 9</A
>.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="guicompvol"
></A
>12.3.1. Using the GUI</H2
><P
>To create a compatibility volume, follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select 
			<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Compatibility Volume</SPAN
>.
			</P
></LI
><LI
><P
>Choose the region <TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
> 
			from the list.</P
></LI
><LI
><P
>Click the <SPAN
CLASS="guibutton"
>Create</SPAN
> button.</P
></LI
><LI
><P
>Click the <SPAN
CLASS="guilabel"
>Volume</SPAN
> tab in the GUI to
			see a volume named <TT
CLASS="filename"
>/dev/evms/lvm/Sample Container/Sample Region</TT
>. 
			This volume is your compatibility volume.</P
></LI
></OL
><P
>Alternatively, you can perform some of the steps to create a compatibility volume from
the GUI context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Available Objects</SPAN
> tab, right click
	<TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Create Compatibility Volume...</SPAN
></P
></LI
><LI
><P
>Continue beginning with step 3 of the GUI instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="ncurcompatvol"
></A
>12.3.2. Using Ncurses</H2
><P
>To create a compatibility volume, follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Compatibility Volume</SPAN
>.</P
></LI
><LI
><P
>Choose the region <TT
CLASS="filename"
>lvm/Sample Container/Storage Region</TT
> from the list.. 
			</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Create</SPAN
>.</P
></LI
></OL
><P
>Alternatively, you can perform some of the steps to create a compatibility volume from
the context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Available Objects view, press <B
CLASS="keycap"
>Enter</B
> on 
<TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Create Compatibility Volume</SPAN
> menu item.</P
></LI
><LI
><P
>Continue beginning with step 3 of the Ncurses instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2064"
></A
>12.3.3. Using the CLI</H2
><P
>To create a volume, use the <B
CLASS="command"
>Create</B
> command. The arguments 
		the <B
CLASS="command"
>Create</B
> command accepts vary depending on what is being created. In 
		the case of the example, the first argument is the key word <TT
CLASS="option"
>volume</TT
> that
		specifies what is being created. The second argument is the object being made into a volume, 
		in this case <TT
CLASS="option"
>lvm/Sample Container/Sample Region</TT
>. 
		The third argument, <TT
CLASS="option"
>compatibility</TT
>, indicates that this is a compatibility 
		volume and should be named as such. </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Create:Volume,"lvm/Sample Container/Sample Region",compatibility</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="evmsfsimops"
></A
>Chapter 13. FSIMs and file system operations</H1
><P
>This chapter discusses the seven File System Interface Modules (FSIMs) shipped with EVMS, and then provides examples of adding file systems and coordinating file system checks with the FSIMs.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="FSIMsuppevms"
></A
>13.1. The FSIMs supported by EVMS</H1
><P
>EVMS currently ships with seven FSIMs.  These file system modules allow EVMS to interact with file system utilities such as <B
CLASS="command"
>mkfs</B
> and <B
CLASS="command"
>fsck</B
>.  Additionally, the FSIMs ensure that EVMS safely performs operations, such as expanding and shrinking file systems, by coordinating these actions with the file system. </P
><P
>You can invoke operations such as <B
CLASS="command"
>mkfs</B
> and <B
CLASS="command"
>fsck</B
> through the various EVMS user interfaces.  Any actions you initiate through an FSIM are not saved to disk until the changes are saved in the user interface.  Later in this chapter we provide examples of creating a new file system and coordinating file system checks through the EVMS GUI, Ncurses, and command-line interfaces.</P
><P
>The FSIMs supported by EVMS are:</P
><P
></P
><UL
><LI
><P
>JFS</P
></LI
><LI
><P
>XFS</P
></LI
><LI
><P
>ReiserFS</P
></LI
><LI
><P
>Ext2/3</P
></LI
><LI
><P
>SWAPFS</P
></LI
><LI
><P
>OpenGFS</P
></LI
><LI
><P
>NTFS</P
></LI
></UL
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="fsimjfs"
></A
>13.1.1. JFS</H2
><P
>&#13;The JFS module supports the IBM journaling file system (JFS). 
Current support includes <B
CLASS="command"
>mkfs</B
>, <B
CLASS="command"
>unmkfs</B
>, 
<B
CLASS="command"
>fsck</B
>, and online file system expansion.   
You must
have at least version 1.0.9 of the JFS utilities for your system
to work with this EVMS FSIM.  You can download the latest utilities
from the <A
HREF="http://oss.software.ibm.com/jfs"
TARGET="_top"
>JFS for Linux</A
> 
site.  
</P
><P
>&#13;For more information on the JFS FSIM, refer to <A
HREF="#jfsfsim"
>Appendix F</A
>.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="fsimxfs"
></A
>13.1.2. XFS</H2
><P
>&#13;The XFS FSIM supports the XFS file system from SGI.
Command support includes <B
CLASS="command"
>mkfs</B
>, <B
CLASS="command"
>unmkfs</B
>, 
<B
CLASS="command"
>fsck</B
>, and online expansion.  Use version 1.2 or higher, which you can download from <A
HREF="ftp://oss.sgi.com/projects/xfs/download"
TARGET="_top"
>the SGI open source FTP directory.</A
>
</P
><P
>&#13;For more information on the XFS FSIM, refer to <A
HREF="#xfsfsim"
>Appendix G</A
>.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="fsimreiserfs"
></A
>13.1.3. ReiserFS</H2
><P
>&#13;The ReiserFS module supports the ReiserFS journaling file system.
This module supports <B
CLASS="command"
>mkfs</B
>, <B
CLASS="command"
>unmkfs</B
>, <B
CLASS="command"
>fsck</B
>, online and offline 
expansion and offline shrinkage.  You need version 3.x.1a or higher
of the ReiserFS utilities for use with the EVMS FSIM modules.  You can download
the ReiserFS utilities from <A
HREF="http://www.namesys.com/"
TARGET="_top"
>The Naming 
System Venture (Namesys) </A
> Web site.
</P
><P
>&#13;For more information on the ReiserFS FSIM, refer to <A
HREF="#reiserfsim"
>Appendix H</A
>.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="fsimext23"
></A
>13.1.4. Ext2/3</H2
><P
>&#13;The EXT2/EXT3 FSIM supports both the ext2 and ext3 file system formats.
The FSIM supports <B
CLASS="command"
>mkfs</B
>, <B
CLASS="command"
>unmkfs</B
>, 
<B
CLASS="command"
>fsck</B
>, and offline shrinkage and expansion.
</P
><P
>&#13;For more information on the Ext2/3 FSIM, refer to <A
HREF="#ext23fsim"
>Appendix I</A
>.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="fsimswapfs"
></A
>13.1.5. SWAPFS</H2
><P
>&#13;The SWAPFS FSIM supports Linux swap devices.  The FSIM lets you create
and delete swap devices, and supports <B
CLASS="command"
>mkfs</B
>, 
<B
CLASS="command"
>unmkfs</B
>, shrinkage and expansion.  
Currently, you are responsible for issuing the
<B
CLASS="command"
>swapon</B
> and <B
CLASS="command"
>swapoff</B
> commands either in 
the startup scripts or manually.
You can resize swap device with the SWAPFS FSIM as long as the device is
not in use.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="fsimopengfs"
></A
>13.1.6. OpenGFS</H2
><P
>&#13;The OpenGFS module supports the OpenGFS clustered journaling file system.
This module supports <B
CLASS="command"
>mkfs</B
>, <B
CLASS="command"
>unmkfs</B
>,
<B
CLASS="command"
>fsck</B
>, and online expansion.
You need the OpenGFS utilities for use with the EVMS FSIM module.
You can download the OpenGFS utilities from the 
<A
HREF="http://sourceforge.net/projects/opengfs"
TARGET="_top"
>OpenGFS project on SourceForge</A
>.
</P
><P
>&#13;For more information on the OpenGFS FSIM, refer to <A
HREF="#gfsfsim"
>Appendix J</A
>.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="fsimntfs"
></A
>13.1.7. NTFS</H2
><P
>&#13;The NTFS FSIM supports the NTFS file system format.
The FSIM supports <B
CLASS="command"
>mkfs</B
>, <B
CLASS="command"
>unmkfs</B
>,
and offline shrinkage and expansion.
It also has support for running the <B
CLASS="command"
>ntfsfix</B
> and
<B
CLASS="command"
>netfsclone</B
> from the <B
CLASS="command"
>ntfsprogs</B
> utilities.
You can download the <B
CLASS="command"
>ntfsprogs</B
> utilities from the
<A
HREF="http://linux-ntfs.sourceforge.net/"
TARGET="_top"
>Linux NTFS project web site</A
>.
</P
><P
>&#13;For more information on the NTFS FSIM, refer 
to <A
HREF="#ntfsfsim"
>Appendix K</A
>.
</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="fsimmkfs"
></A
>13.2. Example: add a file system to a volume</H1
><P
>After you have made an EVMS or compatibility volume, add a file system to the volume before mounting it.  You can add a file system to a volume through the EVMS interface of your choice.</P
><A
NAME="AEN2166"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN2167"
></A
><P
><B
>Example 13-1. Add a JFS File System to a Volume</B
></P
><P
>This example creates a new JFS file system, named <TT
CLASS="filename"
>jfs_vol</TT
>, on volume <TT
CLASS="filename"
>/dev/evms/my_vol</TT
>.
</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="fsimmkfsgui"
></A
>13.2.1. Using the EVMS GUI</H2
><P
>Follow these steps to create a JFS file system with the EVMS GUI:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>File Systems</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Make</SPAN
>.
	</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenu"
>JFS File System Interface Module</SPAN
>.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenu"
>/dev/evms/my_vol</SPAN
>.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Type  <TT
CLASS="userinput"
><B
>jfs_vol</B
></TT
> in the "Volume Label" 
	field. Customize any other options you are interested in.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Make</SPAN
>.
	</P
></LI
><LI
><P
>The operation is completed when you save.</P
></LI
></OL
>
</P
><P
>Alternatively, you can perform some of the steps to create a file system with the GUI
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Volumes</SPAN
> tab, right click 
	<TT
CLASS="filename"
>/dev/evms/my_vol</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Make Filesystem...</SPAN
></P
></LI
><LI
><P
>Continue creating the file system beginning with step 2 of the
	GUI instructions.  You can skip steps 4 and 5 of the GUI instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="fsimmkfsncurses"
></A
>13.2.2. Using Ncurses</H2
><P
>Follow these steps to create a JFS file system with Ncurses:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>File Systems</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Make</SPAN
>.
	</P
></LI
><LI
><P
>Select JFS File System Interface Module.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>/dev/evms/my_vol</TT
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Scroll down using the <B
CLASS="keycap"
>down</B
> arrow until
	 <SPAN
CLASS="guimenuitem"
>Volume Label</SPAN
> is highlighted.
	</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Spacebar</B
>.
	</P
></LI
><LI
><P
>At the "::" prompt enter <TT
CLASS="userinput"
><B
>jfs_vol</B
></TT
>.
	</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Make</SPAN
>.</P
></LI
></OL
>
</P
><P
>Alternatively, you can perform some of the steps to create a file system with the
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Volumes view, press <B
CLASS="keycap"
>Enter</B
> on 
<TT
CLASS="filename"
>/dev/evms/my_vol</TT
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Make Filesystem</SPAN
> menu item.</P
></LI
><LI
><P
>Continue creating the file system beginning with step 2 of the
Ncurses instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="fsimmkfscli"
></A
>13.2.3. Using the CLI</H2
><P
>Use the
	<B
CLASS="command"
>mkfs</B
> command to create the new file system.  
The arguments to <B
CLASS="command"
>mkfs</B
> include the FSIM type (in our example, JFS), followed
by any option pairs, and then the volume name.  The command to accomplish
this is:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>mkfs: JFS={vollabel=jfs_vol}, /dev/evms/my_vol</PRE
></FONT
></TD
></TR
></TABLE
><P
>The command is completed upon saving.</P
><P
>If you are interested in other options that <B
CLASS="command"
>mkfs</B
> can 
use, look at the results of the following query:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query: plugins, plugin=JFS, list options</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="fsimmkfsaex"
></A
>13.3. Example: check a file system</H1
><P
>You can also coordinate file system checks from the EVMS user interfaces.</P
><A
NAME="AEN2276"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN2277"
></A
><P
><B
>Example 13-2. Check a JFS File System</B
></P
><P
>This example shows how to perform a file system check on a JFS file system, named <TT
CLASS="filename"
>jfs_vol</TT
>, on volume <TT
CLASS="filename"
>/dev/evms/my_vol</TT
>, with verbose output.
</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="FSIMmkfsgui"
></A
>13.3.1. Using the EVMS GUI</H2
><P
>Follow these steps to check a JFS file system with the EVMS GUI:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>File Systems</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Check/Repair</SPAN
>.
	</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenu"
>/dev/evms/my_vol</SPAN
>.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Click the <B
CLASS="keycap"
>Yes</B
>  button by <SPAN
CLASS="guimenu"
>Verbose Output</SPAN
>.  
	 Customize any other options you are interested in.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Check</SPAN
>.
	</P
></LI
><LI
><P
>The operation is completed when you save.</P
></LI
></OL
>
</P
><P
>Alternatively, you can perform some of the steps to check a file system with the GUI context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Volumes</SPAN
> tab, right click
	<TT
CLASS="filename"
>/dev/evms/my_vol</TT
>.</P
></LI
><LI
><P
>Click <TT
CLASS="filename"
>Check/Repair File System...</TT
>
	</P
></LI
><LI
><P
>Continue checking the file system beginning with step 3 of the
	GUI instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="fsimfsckncurses"
></A
>13.3.2. Using Ncurses</H2
><P
>Follow these steps to check a JFS file system with Ncurses:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>File System</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Check/Repair</SPAN
>
	</P
></LI
><LI
><P
>Select
	<TT
CLASS="filename"
> /dev/evms/my_vol</TT
>.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Scroll down using the <B
CLASS="keycap"
>down</B
> arrow until
	<SPAN
CLASS="guimenuitem"
>Verbose Output</SPAN
> is highlighted.
	</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Spacebar</B
> to change <SPAN
CLASS="guimenuitem"
>Verbose Output</SPAN
> to <B
CLASS="keycap"
>Yes</B
>.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Check</SPAN
>.
	</P
></LI
></OL
>
</P
><P
>Alternatively, you can perform some of the steps to check a file system with the
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Volumes view, press <B
CLASS="keycap"
>Enter</B
> on <TT
CLASS="filename"
>/dev/evms/my_vol</TT
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Check/Repair File System</SPAN
> menu item.</P
></LI
><LI
><P
>Continue checking the file system beginning with step 3 of the Ncurses
instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="FSIMmkfscli"
></A
>13.3.3. Using the CLI</H2
><P
>The CLI <B
CLASS="command"
>check</B
> command takes a volume name and options as
	 input.  The command to check the file system on <TT
CLASS="filename"
>/dev/evms/my_vol</TT
> is the following:
	</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>check: /dev/evms/my_vol, verbose=TRUE</PRE
></FONT
></TD
></TR
></TABLE
><P
>Currently, a query command for viewing additional options is not available.</P
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="clusterops"
></A
>Chapter 14. Clustering operations</H1
><P
>This chapter discusses how to configure cluster storage containers (referred to throughout
this chapter as "cluster containers"), a feature provided by the EVMS Cluster Segment
Manager (CSM).</P
><P
>Disks that are physically accessible from all of the nodes of the cluster can be
grouped together as a single manageable entity.  EVMS storage objects can then be
created using storage from these containers.</P
><P
>Ownership is assigned to a container to make the container either private or shared.
A container that is owned by any one node of the cluster is called a private container.
EVMS storage objects and storage volumes created using space from a private
container are accessible from only the owning node.</P
><P
>A container that is owned by all the nodes in a cluster is called a shared container.
EVMS storage objects and storage volumes created using space from a shared
container are accessible from all nodes of the cluster simultaneously.</P
><P
>EVMS provides the tools to convert a private container to a shared container, and
a shared container to a private container.  EVMS also provides the flexibility to
change the ownership of a private container from one cluster node to another
cluster node.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN2372"
></A
>14.1. Rules and restrictions for creating cluster containers</H1
><P
>Note the following rules and limitations for creating cluster containers:
</P
><P
></P
><UL
><LI
><P
>Do not assign non-shared disks to a cluster container.
</P
></LI
><LI
><P
>Storage objects and volumes created on a cluster container must not 
span across multiple cluster containers.  
The EVMS Engine enforces this rule by disallowing such configurations.
</P
></LI
><LI
><P
>Do not assign RAID-1, RAID-5, BBR, or snapshotting
to storage objects on a shared cluster container. These plug-ins
can be used on private cluster containers.
</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN2382"
></A
>14.2. Example: create a private cluster container</H1
><P
>This section tells how to create a sample private
container and provides instructions for completing the following task:</P
><A
NAME="AEN2385"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN2386"
></A
><P
><B
>Example 14-1. Create a private cluster container</B
></P
><P
>Given a system with three available shared disks 
(<TT
CLASS="filename"
>sdd</TT
>, <TT
CLASS="filename"
>sde</TT
>, and 
<TT
CLASS="filename"
>sdf</TT
>),
use the EVMS Cluster Segment Manager to combine these disk drives into a
container called <TT
CLASS="filename"
>Priv1</TT
> owned by <TT
CLASS="filename"
>node1</TT
>.
</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2394"
></A
>14.2.1. Using the EVMS GUI</H2
><P
>To create a container with the EVMS GUI, follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select 
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
> to see a list of plug-ins that support container creation.
</P
></LI
><LI
><P
>Select the <SPAN
CLASS="guimenuitem"
>Cluster Segment Manager</SPAN
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
><P
>The next dialog window contains a list of storage objects that
the CSM can use to create a container.</P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>sdd</TT
>, <TT
CLASS="filename"
>sde</TT
>, and <TT
CLASS="filename"
>sdf</TT
> from the list.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>In the first pull-down menu, select the "Node Id" of the cluster node that
owns this container (<SPAN
CLASS="guimenuitem"
>node1</SPAN
>).  Select "Storage Type" as 
<SPAN
CLASS="guimenuitem"
>private</SPAN
> from the second pull-down menu.</P
></LI
><LI
><P
>Enter the name <TT
CLASS="userinput"
><B
>Priv1</B
></TT
> for the Container Name.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Create</SPAN
>.</P
><P
>A window opens that displays the outcome.</P
></LI
><LI
><P
>Commit the changes.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2432"
></A
>14.2.2. Using Ncurses</H2
><P
>To create the private container with the Ncurses interface, follow these steps:
</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
> to see a list 
of plug-ins that support container creation.</P
></LI
><LI
><P
>Scroll down with the <B
CLASS="keycap"
>down</B
> arrow and select Cluster Segment Manager by
pressing <B
CLASS="keycap"
>spacebar</B
>.  The plug-in you selected is marked with an "x."  </P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.</P
><P
>The next submenu contains a list of disks that the Cluster Segment Manager finds
acceptable to use for the creation of a container.</P
></LI
><LI
><P
>Use <B
CLASS="keycap"
>spacebar</B
> to select <TT
CLASS="filename"
>sdd</TT
>, <TT
CLASS="filename"
>sde</TT
>, 
and <TT
CLASS="filename"
>sdf</TT
> from the list.  The disks you select are marked with an "x."</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>On the Create Storage Container - Configuration Options menu, press 
<B
CLASS="keycap"
>spacebar</B
> on the Node Id, which will provide a list of nodes from
which to select.</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>spacebar</B
> on the node <TT
CLASS="filename"
>node1</TT
> and 
then press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Scroll down with the <B
CLASS="keycap"
>down</B
> arrow and press <B
CLASS="keycap"
>spacebar</B
> on the
Storage Type.  A list of storage types opens.</P
></LI
><LI
><P
>Scroll down with the <B
CLASS="keycap"
>down</B
> arrow to 
<SPAN
CLASS="guimenuitem"
>private entry</SPAN
> and press <B
CLASS="keycap"
>spacebar</B
>.</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Scroll down with the <B
CLASS="keycap"
>down</B
> arrow to 
<SPAN
CLASS="guimenuitem"
>Container Name</SPAN
> and press <B
CLASS="keycap"
>spacebar</B
>.</P
><P
>The Change Option Value menu opens and asks for the Container Name.  Type
in the name of the container as <TT
CLASS="userinput"
><B
>Priv1</B
></TT
>, and press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
> to complete the operation.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2490"
></A
>14.2.3. Using the CLI</H2
><P
>An operation to create a private cluster container with the CLI takes three parameters: the name 
of the container, the type of the container, and the nodeid to which the container belongs.
</P
><P
>On the CLI, type the following command to create the private container
<TT
CLASS="filename"
>Priv1</TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>create: container,CSM={name="Priv1",type="private",nodeid="node1"},sdd,sde,sdf</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN2496"
></A
>14.3. Example: create a shared cluster container</H1
><P
>This section tells how to create a sample shared container and provides
instructions to help you complete the following task:</P
><A
NAME="AEN2499"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN2500"
></A
><P
><B
>Example 14-2. Create a shared cluster container</B
></P
><P
>Given a system with three available shared disks 
(<TT
CLASS="filename"
>sdd</TT
>, <TT
CLASS="filename"
>sde</TT
>, and 
<TT
CLASS="filename"
>sdf</TT
>),
use the EVMS Cluster Segment Manager to combine these disk drives into a shared
container called <TT
CLASS="filename"
>Shar1</TT
>.
</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2507"
></A
>14.3.1. Using the EVMS GUI</H2
><P
>To create a shared cluster container with the EVMS GUI, follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select 
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
> to see a list of plug-ins that support container creation.
</P
></LI
><LI
><P
>Select the <SPAN
CLASS="guimenuitem"
>Cluster Segment Manager</SPAN
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
><P
>The next dialog window contains a list of storage objects that
the CSM can use to create a container.</P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>sdd</TT
>, <TT
CLASS="filename"
>sde</TT
>, and <TT
CLASS="filename"
>sdf</TT
> from the list.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>You do not need to change the "Node Id" field. Select 
Storage Type as 
<SPAN
CLASS="guimenuitem"
>shared</SPAN
> from the second pull-down menu.</P
></LI
><LI
><P
>Enter the name <TT
CLASS="userinput"
><B
>Shar1</B
></TT
> for the Container Name.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Create</SPAN
>.  A window opens to display the outcome.</P
></LI
><LI
><P
>Commit the changes.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2543"
></A
>14.3.2. Using Ncurses</H2
><P
>To create a shared cluster contained with the Ncurses interface, follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
> to see a list of plug-ins that support container creation.</P
></LI
><LI
><P
>Scroll down with the <B
CLASS="keycap"
>down</B
> arrow and select Cluster Segment Manager by
pressing <B
CLASS="keycap"
>spacebar</B
>.  The plug-in you selected is marked with an "x."  </P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.</P
><P
>The next submenu contains a list of disks that the Cluster Segment Manager finds
acceptable to use for the creation of a container.</P
></LI
><LI
><P
>Use <B
CLASS="keycap"
>spacebar</B
> to select <TT
CLASS="filename"
>sdd</TT
>, <TT
CLASS="filename"
>sde</TT
>, 
and <TT
CLASS="filename"
>sdf</TT
> from the list.  The disks you select are marked with an "x."</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>The Create Storage Container - Configuration Options menu open;
ignore the "Node Id" menu.</P
></LI
><LI
><P
>Scroll down with the <B
CLASS="keycap"
>down</B
> arrow and press <B
CLASS="keycap"
>spacebar</B
> on the
Storage Type.  A list of storage types opens.</P
></LI
><LI
><P
>Scroll down with the <B
CLASS="keycap"
>down</B
> arrow to 
<SPAN
CLASS="guimenuitem"
>shared entry</SPAN
> and press <B
CLASS="keycap"
>spacebar</B
>.</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Scroll down with the <B
CLASS="keycap"
>down</B
> arrow to 
<SPAN
CLASS="guimenuitem"
>Container Name</SPAN
> and press <B
CLASS="keycap"
>spacebar</B
>.</P
><P
>The Change Option Value menu opens and asks for the Container Name.  Type
in the name of the container as <TT
CLASS="userinput"
><B
>Shar1</B
></TT
>, and press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
> to complete the operation.</P
></LI
><LI
><P
>Quit Ncurses and run <B
CLASS="command"
>evms_activate</B
> on each of the cluster 
nodes.  This process will be automated in future releases of EVMS.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2598"
></A
>14.3.3. Using the CLI</H2
><P
>An operation to create a shared cluster container with the CLI takes two parameters:
the name of the container and the type of the container.</P
><P
>On the CLI,  type the following command to create shared container <TT
CLASS="filename"
>Shar1</TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>create: container,CSM={name="Shar1",type="shared"},sdd,sde,sdf</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN2604"
></A
>14.4. Example: convert a private container to a shared container</H1
><P
>This section tells how to convert a sample private container to a shared
container and provides instructions for completing the following task:</P
><A
NAME="AEN2607"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN2608"
></A
><P
><B
>Example 14-3. Convert a private container to shared</B
></P
><P
>Given a system with a private storage container <TT
CLASS="filename"
>Priv1</TT
> owned 
by <TT
CLASS="filename"
>evms1</TT
>, convert
<TT
CLASS="filename"
>Priv1</TT
> to a shared storage container with the same name.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>CAUTION</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Ensure that no application
is using the volumes on the container on any node of the cluster.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2617"
></A
>14.4.1. Using the EVMS GUI</H2
><P
>Follow these steps to convert a private cluster container to a shared cluster 
container with the EVMS GUI:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Modify</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
> to see a list of containers.</P
></LI
><LI
><P
>Select the container <SPAN
CLASS="guimenuitem"
>Priv1</SPAN
> and press <B
CLASS="keycap"
>Next</B
>.</P
><P
>A Modify Properties dialog box opens.</P
></LI
><LI
><P
>Change "Type" to "shared" and click <B
CLASS="keycap"
>Modify</B
>.</P
><P
>A window opens that displays the outcome.</P
></LI
><LI
><P
>Commit the changes.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2638"
></A
>14.4.2. Using Ncurses</H2
><P
>Follow these steps to convert a private cluster container to a shared cluster
container with the Ncurses interface:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Modify</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
> to see a list of containers.</P
></LI
><LI
><P
>The Modify Container Properties dialog opens.  Select the container 
<TT
CLASS="filename"
>Priv1</TT
> by
pressing <B
CLASS="keycap"
>spacebar</B
>.  The container you selected is marked with an "x."</P
><P
>Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Use <B
CLASS="keycap"
>spacebar</B
> to select <TT
CLASS="filename"
>sdd</TT
>, <TT
CLASS="filename"
>sde</TT
>, 
and <TT
CLASS="filename"
>sdf</TT
> from the list.  The disks you select are marked with an "x."</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>The Modify Container Properties - Configuration Options" dialog opens. Scroll down with the <B
CLASS="keycap"
>down</B
> arrow and press <B
CLASS="keycap"
>spacebar</B
> on "Type".</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>spacebar</B
>.</P
></LI
><LI
><P
>The Change Option Value dialog opens.  Type <TT
CLASS="userinput"
><B
>shared</B
></TT
> and press <B
CLASS="keycap"
>Enter</B
>.</P
><P
>The changed value now displays in the Modify Container Properties -
Configuration Options dialog.</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.</P
><P
>The outcome of the command is displayed at the bottom of the screen.</P
></LI
><LI
><P
>Save the changes by clicking <B
CLASS="keycap"
>Save</B
> in the <SPAN
CLASS="guimenuitem"
>Actions</SPAN
> pulldown menu.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2683"
></A
>14.4.3. Using the CLI</H2
><P
>The <B
CLASS="command"
>modify</B
> command modifies the properties of a container.  The first argument
of the command is the object to modify, followed by its new properties.  The command
to convert the private container to a shared container in the example is:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>modify: Priv1,type=shared</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN2688"
></A
>14.5. Example: convert a shared container to a private container</H1
><P
>This section tells how to convert a sample shared container to a private
container and provides instructions for completing the following task:</P
><A
NAME="AEN2691"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN2692"
></A
><P
><B
>Example 14-4. Convert a shared container to private</B
></P
><P
>Given a system with a shared storage container <TT
CLASS="filename"
>Shar1</TT
>, convert
<TT
CLASS="filename"
>Shar1</TT
> to a private storage container owned by node <TT
CLASS="filename"
>node1</TT
> (where
<TT
CLASS="filename"
>node1</TT
> is the nodeid of one of the cluster nodes).</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>CAUTION</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Ensure that no application
is using the volumes on the container of any node in the cluster.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2702"
></A
>14.5.1. Using the EVMS GUI</H2
><P
>Follow these steps to convert a shared cluster container to a private cluster 
container with the EVMS GUI:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Modify</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
> to see a list of containers.</P
></LI
><LI
><P
>Select the container <SPAN
CLASS="guimenuitem"
>Shar1</SPAN
> and press <B
CLASS="keycap"
>Next</B
>.</P
><P
>A Modify Properties dialog opens.</P
></LI
><LI
><P
>Change "Type" to "private" and the "Node" field to <TT
CLASS="filename"
>node1</TT
>.  Click <B
CLASS="keycap"
>Modify</B
>.</P
><P
>A window opens that displays the outcome.</P
></LI
><LI
><P
>Commit the changes.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2724"
></A
>14.5.2. Using Ncurses</H2
><P
>Follow these steps to convert a shared cluster container to a private cluster
container with the Ncurses interface:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Modify</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
></P
></LI
><LI
><P
>The Modify Container Properties dialog opens.  Select the container 
<TT
CLASS="filename"
>Shar1</TT
> by
pressing <B
CLASS="keycap"
>spacebar</B
>.  The container you selected is marked with an "x."</P
><P
>Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>The Modify Container Properties - Configuration Options" dialog opens. Scroll down with the <B
CLASS="keycap"
>down</B
> arrow and press <B
CLASS="keycap"
>spacebar</B
> on the "Type" field.</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>spacebar</B
>.</P
></LI
><LI
><P
>The Change Option Value dialog opens.  Select <TT
CLASS="userinput"
><B
>private</B
></TT
> and press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>The Modify Container Properties -
Configuration Options dialog opens.  Scroll down the list to <SPAN
CLASS="guimenuitem"
>NodeId</SPAN
> 
with the <B
CLASS="keycap"
>down</B
> arrow 
and press <B
CLASS="keycap"
>spacebar</B
>.</P
></LI
><LI
><P
>The Change Option Value dialog opens.  Select <TT
CLASS="userinput"
><B
>node1</B
></TT
> and press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>The changed values now display in the Modify Container Properties -
Configuration Options dialog.  Press <B
CLASS="keycap"
>Enter</B
>. </P
><P
>The outcome of the command is displayed at the bottom of the screen.</P
></LI
><LI
><P
>Save the changes by clicking <B
CLASS="keycap"
>Save</B
> in the <SPAN
CLASS="guimenuitem"
>Actions</SPAN
> pulldown.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2768"
></A
>14.5.3. Using the CLI</H2
><P
>The <B
CLASS="command"
>modify</B
> command modifies the properties of a container.  The first argument
of the command is the object to modify, followed by its new properties.  The command
to convert the shared container to a private container in the example is:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>modify: Shar1,type=private,node=node1</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN2773"
></A
>14.6. Example: deport a private or shared container</H1
><P
>&#13;When a container is deported, the node disowns the container and deletes
all the objects created in memory that belong to that container.  
No node in
the cluster can discover objects residing on a deported container or
create objects for a deported container.
This section explains how to deport a private or shared container.  
</P
><A
NAME="AEN2776"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN2777"
></A
><P
><B
>Example 14-5. Deport a cluster container</B
></P
><P
>Given a system with a private or shared  storage container named 
<TT
CLASS="filename"
>c1</TT
>, deport <TT
CLASS="filename"
>c1</TT
>.
</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2782"
></A
>14.6.1. Using the EVMS GUI</H2
><P
>&#13;To deport a container with the EVMS GUI, follow these steps:
</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select 
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Modify</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
>.
</P
></LI
><LI
><P
>Select the container <TT
CLASS="filename"
>c1</TT
> and press 
<B
CLASS="keycap"
>Next</B
>.
</P
><P
>&#13;A Modify Properties dialog opens.
</P
></LI
><LI
><P
>Change "Type" to "deported."  Click <B
CLASS="keycap"
>Modify</B
>.
</P
><P
>&#13;A window opens that displays the outcome.
</P
></LI
><LI
><P
>Commit the changes.
</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2803"
></A
>14.6.2. Using Ncurses</H2
><P
>&#13;To deport a container with Ncurses, follow these steps: 
</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Scroll down the list with the <B
CLASS="keycap"
>down</B
> arrow to
<SPAN
CLASS="guimenuitem"
>Modify</SPAN
>.  Press <B
CLASS="keycap"
>Enter</B
>.
</P
><P
>&#13;A submenu is displayed.
</P
></LI
><LI
><P
>Scroll down until Container is highlighted.  Press <B
CLASS="keycap"
>Enter</B
>.
</P
><P
>&#13;The Modify Container Properties dialog opens.
</P
></LI
><LI
><P
>Select the container <TT
CLASS="filename"
>csm/c1</TT
> by pressing
<B
CLASS="keycap"
>spacebar</B
>.  The container you selected is marked with an "x."
</P
></LI
><LI
><P
>&#13;Press <B
CLASS="keycap"
>Enter</B
>.
</P
><P
>&#13;The Modify Container Properties - Configuration Options dialog opens.
</P
></LI
><LI
><P
>Scroll down and press <B
CLASS="keycap"
>spacebar</B
> on the "Type" field.  
</P
></LI
><LI
><P
>&#13;Press <B
CLASS="keycap"
>spacebar</B
>.
</P
><P
>&#13;The Change Option Value dialog opens.
</P
></LI
><LI
><P
>Type <TT
CLASS="userinput"
><B
>deported</B
></TT
> and press <B
CLASS="keycap"
>Enter</B
>.
</P
><P
>&#13;The changed value is displayed in the Modify Container Properties -
Configuration Options dialog.
</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.
</P
><P
>&#13;The outcome of the command is displayed at the bottom of the screen.
</P
></LI
><LI
><P
>Commit the changes by clicking <B
CLASS="keycap"
>Save</B
> in the 
<SPAN
CLASS="guimenuitem"
>Actions</SPAN
> pulldown.
</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2845"
></A
>14.6.3. Using the CLI</H2
><P
>&#13;To deport a container from the CLI, execute the following command
at the CLI prompt:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;modify: c1,type=deported
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN2849"
></A
>14.7. Deleting a cluster container</H1
><P
>&#13;The procedure for deleting a cluster container is the same for deleting
any container.  See <A
HREF="#examdelrecur"
>Section 21.2</A
>





</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN2853"
></A
>14.8. Failover and Failback of a private container on Linux-HA</H1
><P
>EVMS supports the Linux-HA cluster manager in EVMS V2.0 and later.  Support for 
the RSCT cluster
manager is also available as of EVMS V2.1, but is not as widely tested.</P
><P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Ensure that <B
CLASS="command"
>evms_activate</B
> is called in one of the startup scripts
before the <B
CLASS="command"
>heartbeat</B
> startup script is called. If <B
CLASS="command"
>evms_activate</B
> is not called, failover
might not work correctly. </P
></TD
></TR
></TABLE
></DIV
></P
><P
>Follow these steps to set up failover and failback of a private container:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Add an entry in <TT
CLASS="filename"
>/etc/ha.d/haresources</TT
> for each 
private container to be failed over.  For example, if <TT
CLASS="filename"
>container1</TT
> and 
<TT
CLASS="filename"
>container2</TT
> are to
be failed over together to the same node with <TT
CLASS="filename"
>node1</TT
> as the owning node, add the
following entry to <TT
CLASS="filename"
>/etc/ha.d/haresources</TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>node1 evms_failover::container1 evms_failover::container2</PRE
></FONT
></TD
></TR
></TABLE
><P
><TT
CLASS="filename"
>node1</TT
> is the cluster node that owns this resource.  The resource is failed over
to the other node when <TT
CLASS="filename"
>node1</TT
> dies.</P
><P
>Similarly, if <TT
CLASS="filename"
>container3</TT
> and <TT
CLASS="filename"
>container4</TT
> are to be failed over together to the same
node with <TT
CLASS="filename"
>node2</TT
> as the owning node, then add the following entry to 
<TT
CLASS="filename"
>/etc/ha.d/haresources</TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>node2 evms_failover::container3 evms_failover::container4</PRE
></FONT
></TD
></TR
></TABLE
><P
>Refer to 
<A
HREF="http://www.linux-ha.org/download/GettingStarted.html"
TARGET="_top"
>http://www.linux-ha.org/download/GettingStarted.html</A
> for more details on the
semantics of resource groups.</P
></LI
><LI
><P
>Validate that the <TT
CLASS="filename"
>/etc/ha.d</TT
>, <TT
CLASS="filename"
>/etc/ha.cf</TT
> and <TT
CLASS="filename"
>/etc/ha.d/haresources</TT
> files are the same
on all the nodes of the cluster.</P
></LI
><LI
><P
>The heartbeat cluster manager must be restarted, as follows, after the
<TT
CLASS="filename"
>/etc/ha.d/haresources</TT
> file has been changed:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>/etc/init.d/heartbeat restart</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>&#13;Do not add shared containers to the list of failover resources; doing so causes
EVMS to respond unpredictably.</P
></TD
></TR
></TABLE
></DIV
></LI
></OL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN2896"
></A
>14.9. Remote configuration management</H1
><P
>EVMS supports the administration of cluster nodes by any node in the cluster.  For
example, storage on remote cluster node <TT
CLASS="filename"
>node1</TT
> can be administered from cluster node
<TT
CLASS="filename"
>node2</TT
>.  The following sections show how to set up remote administration
through the various EVMS user interfaces.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2901"
></A
>14.9.1. Using the EVMS GUI</H2
><P
>To designate <TT
CLASS="filename"
>node2</TT
> as the node to administer from the GUI, follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Settings</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Node Administered...</SPAN
></P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>node2</TT
>.</P
></LI
><LI
><P
>Click <B
CLASS="keycap"
>Administer</B
> to switch to the new node.</P
></LI
></OL
><P
>&#13;The GUI gathers information about the objects, containers, and volumes on 
the other node. The status
bar displays the message "Now administering node node2," which indicates
that the GUI is switched over to node node2.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2918"
></A
>14.9.2. Using Ncurses</H2
><P
>To designate <TT
CLASS="filename"
>node2</TT
> as the node to administer from Ncurses, follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Go to the <SPAN
CLASS="guimenuitem"
>Settings</SPAN
> pulldown menu.</P
></LI
><LI
><P
>Scroll down with the <B
CLASS="keycap"
>down</B
> arrow to the "Node Administered" option and
press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>The Administer Remote Node dialog opens.  Select <TT
CLASS="filename"
>node2</TT
> and press
<B
CLASS="keycap"
>spacebar</B
>.</P
><P
>The node you selected is marked with an "x."</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>After a while, you will be switched over to 
the node <TT
CLASS="filename"
>node2</TT
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2941"
></A
>14.9.3. Using the CLI</H2
><P
>To designate <TT
CLASS="filename"
>node2</TT
> as a node administrator from the CLI, issue this command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>evms -n node2</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN2946"
></A
>14.10. Forcing a cluster container to be active</H1
><P
>&#13;A private container and its objects are made active on a node if:</P
><P
></P
><UL
><LI
><P
>&#13;the private container is owned by the node
</P
></LI
><LI
><P
>&#13;the container is not deported
</P
></LI
><LI
><P
>&#13;the node is in a cluster membership that currently has quorum
</P
></LI
></UL
><P
>&#13;Similarly, a shared container and its objects are made active on a node if
the node is in a cluster that currently has quorum. 
However, the administrator can force the
activation of private and shared containers by overriding these rules.
</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>&#13;Use extreme caution when performing this operation by ensuring that the
node on which the cluster container resides is the only active node in the
cluster.  Otherwise, the data in volumes on shared and private containers
on the node can get corrupted.
</P
></TD
></TR
></TABLE
></DIV
><P
></P
><OL
TYPE="1"
><LI
><P
>&#13;Enabling maintenance mode in the <TT
CLASS="filename"
>/etc/evms.conf</TT
> file.
The option to modify in the <TT
CLASS="filename"
>/etc/evms.conf</TT
> file is the 
following:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;# cluster segment manager section
csm {
#	admin_mode=yes	# values are: yes or no
				# The default is no. Set this key to
				# yes when you wish to force the CSM
				# to discover objects from all cluster
				# containers, allowing you to perform
				# configuration and maintenance.  Setting
				# admin_mode to yes will cause the CSM
				# to ignore container ownership, which
				# will allow you to configure storage
				# in a maintenance mode.
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;</P
></LI
><LI
><P
>&#13;Running <B
CLASS="command"
>evms_activate</B
> on the node.
</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="evmsconvert"
></A
>Chapter 15. Converting volumes</H1
><P
> This chapter discusses converting compatibility volumes to EVMS
volumes and converting EVMS volumes to compatibility volumes. For a discussion 
of the differences between compatibility and EVMS volumes, see <A
HREF="#evmscreatevol"
>Chapter 12</A
>.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN2974"
></A
>15.1. When to convert volumes</H1
><P
>There are several different scenarios that might help you determine 
what type of volumes you need. 
For example, if you wanted persistent names or to make full use of 
EVMS features, such as Drive Linking or Snapshotting, you would convert 
your compatibility volumes to EVMS volumes. 
In another situation, you might decide that a volume needs to be 
read by a system that understands the underlying volume management scheme. 
In this case, you would convert your EVMS volume to a 
compatibility volume.</P
><P
>A volume can only be converted when it is offline.  
This means the volume must be unmounted and otherwise not in use.  
The volume must be unmounted because the conversion operation changes both 
the name and the device number of the volume.  
Once the volume is converted, you can remount it using its new name.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="comptoevms"
></A
>15.2. Example: convert compatibility volumes to EVMS volumes</H1
><P
>A compatibility volume 
can be converted to an EVMS volume in the following situations:
<P
></P
><UL
><LI
><P
>The compatibility volume has no file system (FSIM) on it.</P
></LI
><LI
><P
>The compatibility volume has a file system, but the file system can be shrunk (if necessary) to make 
room for the EVMS metadata.</P
></LI
></UL
></P
><P
>This section provides a detailed explanation of how to convert compatibility 
	volumes to EVMS volumes and provides instructions to help you complete the following task.  </P
><A
NAME="AEN2987"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN2988"
></A
><P
><B
>Example 15-1. Convert a compatibility volume</B
></P
><P
>You have a compatibility volume <TT
CLASS="filename"
>/dev/evms/hda3</TT
>
	that you want to make into an EVMS volume named <TT
CLASS="filename"
>my_vol</TT
>.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="c2egui"
></A
>15.2.1. Using the EVMS GUI</H2
><P
>Follow these steps to convert a compatibility volume with the EVMS GUI:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Choose <SPAN
CLASS="guimenu"
>Action</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Convert </SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Compatibility Volume to EVMS</SPAN
>.  </P
></LI
><LI
><P
>Select  <TT
CLASS="filename"
>/dev/evms/hda3</TT
> 
		from the list of available volumes.</P
></LI
><LI
><P
>Type <TT
CLASS="filename"
>my_vol</TT
> in the name field.</P
></LI
><LI
><P
>Click the <SPAN
CLASS="guibutton"
>Convert</SPAN
> button 
		to convert the volume.</P
></LI
></OL
><P
>Alternatively, you can perform some of the steps to convert the volume from the GUI
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Volumes</SPAN
> tab, right click 
	on <TT
CLASS="filename"
>/dev/evms/hda3</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Convert to EVMS Volume...</SPAN
></P
></LI
><LI
><P
>Continue to convert the volume beginning with step 3 of the GUI 
	instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="c2encur"
></A
>15.2.2. Using Ncurses</H2
><P
>Follow these instructions to convert a compatibility volume to an EVMS volume
	with the Ncurses
	interface:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Choose <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Convert</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Compatibility Volume to EVMS Volume</SPAN
></P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>/dev/evms/hda3</TT
> from the list
		of available volumes.</P
></LI
><LI
><P
>Type <TT
CLASS="userinput"
><B
>my_vol</B
></TT
> when prompted for the name.
		Press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Convert</SPAN
>.</P
></LI
></OL
><P
>Alternatively, you can perform some of the steps to convert the volume from the
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Volumes view, press <B
CLASS="keycap"
>Enter</B
> on <TT
CLASS="filename"
>/dev/evms/hda3</TT
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Convert to EVMS Volume</SPAN
> menu item.</P
></LI
><LI
><P
>Continue to convert the volume beginning with step 3 of the Ncurses
instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN3054"
></A
>15.2.3. Using the CLI</H2
><P
>To convert a volume, use the <B
CLASS="command"
>Convert</B
> command. 
		The <B
CLASS="command"
>Convert</B
> command takes the name of a volume as its first argument, and 
		then <TT
CLASS="option"
>name=</TT
> for what you want to name the new volume 
		as the second argument. To complete the example and convert a volume, type the 
		following command at the <TT
CLASS="prompt"
>EVMS:</TT
> prompt:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>convert: /dev/evms/hda3, Name=my_vol</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="evmstocomp"
></A
>15.3. Example: convert EVMS volumes to compatibility volumes</H1
><P
>An EVMS volume can be converted to a compatibility volume only if the volume does not have EVMS 
	features on it. This section provides a detailed explanation of how to convert EVMS volumes to compatibility volumes 
	by providing instructions to help you complete the following task. </P
><A
NAME="AEN3065"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN3066"
></A
><P
><B
>Example 15-2. Convert an EVMS volume</B
></P
><P
>You have an EVMS volume, <TT
CLASS="filename"
>/dev/evms/my_vol</TT
>,
	that you want to make a compatibility volume.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="e2cgui"
></A
>15.3.1. Using the EVMS GUI</H2
><P
>Follow these instructions to convert an EVMS volume to a compatibility
	volume with the EVMS GUI:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Choose <SPAN
CLASS="guimenu"
>Action</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Convert </SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>EVMS Volume to Compatibility Volume</SPAN
>.  </P
></LI
><LI
><P
>Select  <TT
CLASS="filename"
>/dev/evms/my_vol</TT
> 
		from the list of available volumes.</P
></LI
><LI
><P
>Click the <SPAN
CLASS="guibutton"
>Convert</SPAN
> button 
		to convert the volume.</P
></LI
></OL
><P
>Alternatively, you can perform some of the steps to convert the volume through
	the GUI context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Volumes</SPAN
> tab, right click 
	<TT
CLASS="filename"
>/dev/evms/my_vol</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Convert to Compatibility Volume...</SPAN
></P
></LI
><LI
><P
>Continue converting the volume beginning with step 3 of the
	GUI instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="e2cncur"
></A
>15.3.2. Using Ncurses</H2
><P
>Follow these instructions to convert an EVMS volume to a compatibility volume
with the Ncurses interface:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Choose <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Convert</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>EVMS Volume to 
		Compatibility Volume</SPAN
></P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>/dev/evms/my_vol</TT
> from the
		list of available volumes.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Convert</SPAN
>. 
		</P
></LI
></OL
><P
>Alternatively, you can perform some of the steps to convert the volume through
the context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Volumes view, press <B
CLASS="keycap"
>Enter</B
> on <TT
CLASS="filename"
>/dev/evms/my_vol</TT
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Convert to Compatibility Volume</SPAN
> menu item.</P
></LI
><LI
><P
>Continue to convert the volume beginning with step 3 of the Ncurses
instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="e2ccli"
></A
>15.3.3. Using the CLI</H2
><P
>To convert a volume use the <B
CLASS="command"
>Convert</B
> command. 
		The <B
CLASS="command"
>Convert</B
> command takes the name of a volume as its first argument, and 
		the keyword <TT
CLASS="option"
>compatibility</TT
> to indicate  a change to a compatibility volume  
		as the second argument. To complete the example and convert a volume, type the 
		following command at the <TT
CLASS="prompt"
>EVMS:</TT
> prompt:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>convert: /dev/evms/my_vol, compatibility</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="expandshrink"
></A
>Chapter 16. Expanding and shrinking volumes</H1
><P
>This chapter tells how to expand and shrink EVMS volumes with the EVMS 
GUI, Ncurses, and CLI interfaces.  Note that you can also expand and shrink compatibility volumes and EVMS objects.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="whyexpandshrink"
></A
>16.1. Why expand and shrink volumes?</H1
><P
>Expanding and shrinking volumes are common volume operations on most systems.  For example, it might be necessary to shrink a particular volume to create
free space for another volume to expand into or to create a new volume.</P
><P
>EVMS simplifies the process for expanding and shrinking volumes, and
protects the integrity of your data, by coordinating expand and shrink
operations with the volume's file system.  For example, when shrinking a
volume, EVMS first shrinks the underlying file system appropriately to protect
the data.  When expanding a volume, EVMS expands the file system automatically
when new space becomes available.</P
><P
>Not all file system interface modules (FSIM) types supported by EVMS 
allow shrink and expand operations, and some only perform the operations when
the file system is mounted ("online").  The following table details the 
shrink and expand options available for each type of FSIM.
</P
><P
><DIV
CLASS="table"
><A
NAME="AEN3141"
></A
><P
><B
>Table 16-1. FSIM support for expand and shrink operations</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>FSIM type</TH
><TH
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Shrinks</TH
><TH
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Expands</TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>JFS</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>No</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Online only</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>XFS</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>No</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Online only</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>ReiserFS</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Offline only</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Offline and online</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>ext2/3</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Offline only</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Offline only</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>SWAPFS</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Offline only</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Offline only</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>OpenGFS</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>No</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Online only</TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>NTFS</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Offline only</TD
><TD
WIDTH="33%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>Offline only</TD
></TR
></TBODY
></TABLE
></DIV
>

</P
><P
>You can perform all of the supported shrink and expand operations with each of the EVMS user interfaces.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="exshrink"
></A
>16.2. Example: shrink a volume</H1
><P
>This section tells how to shrink a compatibility volume by 500 MB.</P
><A
NAME="AEN3185"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN3186"
></A
><P
><B
>Example 16-1. Shrink a volume</B
></P
><P
>Shrink the volume 
<TT
CLASS="filename"
>/dev/evms/lvm/Sample Container/Sample Region</TT
>, which
is the compatibility volume that was created in the chapter entitled 
"Creating Volumes," by 500 MB.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="shrinkgui"
></A
>16.2.1. Using the EVMS GUI</H2
><P
>Follow these steps to shrink the volume with the EVMS GUI:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Shrink</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume...</SPAN
></P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenu"
>/dev/evms/lvm/Sample Container/Sample Region</SPAN
> 
	from the list of volumes.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenu"
>/lvm/Sample Container/Sample Region</SPAN
> from the list of volumes.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Enter <TT
CLASS="userinput"
><B
>500MB</B
></TT
> in the "Shrink by Size" field.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Shrink</SPAN
>.</P
></LI
></OL
>
</P
><P
>Alternatively, you can perform some of the steps to shrink the volume with the GUI
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Volumes</SPAN
> tab, right click
	<TT
CLASS="filename"
>/dev/evms/lvm/Sample Container/Sample Region</TT
></P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Shrink...</SPAN
></P
></LI
><LI
><P
>Continue the operation beginning with step 3 of the GUI
	instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="shrinkncurses"
></A
>16.2.2. Using Ncurses</H2
><P
>Follow these steps to shrink a volume with Ncurses:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Shrink</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume</SPAN
>.
	</P
></LI
><LI
><P
>Select
	 <SPAN
CLASS="guimenuitem"
>/dev/evms/lvm/Sample Container/Sample Region</SPAN
> from the
	list of volumes.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Select
	 <SPAN
CLASS="guimenuitem"
>lvm/Sample Container/Sample Region</SPAN
> from the
	shrink point selection list.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Scroll down using the <B
CLASS="keycap"
>down</B
> arrow until
	<SPAN
CLASS="guimenuitem"
>Shrink by Size</SPAN
> is highlighted.
	</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>spacebar</B
>.
	</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.
	</P
></LI
><LI
><P
>At the "::" prompt enter <TT
CLASS="userinput"
><B
>500MB</B
></TT
>.
	</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Shrink</SPAN
>.
	</P
></LI
></OL
>
</P
><P
>&#13;Alternatively, you can perform some of the steps to shrink the volume with the
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Volumes view, press <B
CLASS="keycap"
>Enter</B
> on <TT
CLASS="filename"
>/dev/evms/lvm/Sample Container/Sample Region</TT
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Shrink</SPAN
> menu item.</P
></LI
><LI
><P
>Continue the operation beginning with step 3 of the Ncurses instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="shrinkcli"
></A
>16.2.3. Using the CLI</H2
><P
>The <B
CLASS="command"
>shrink</B
> command takes a shrink point followed by an optional name
value pair or an optional shrink object.  To find the shrink point, use the <B
CLASS="command"
>query</B
> command with the shrink points filter on the object or volume you plan to shrink.  For example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query: shrink points, "/dev/evms/lvm/Sample Container/Sample Region"</PRE
></FONT
></TD
></TR
></TABLE
><P
>Use a list options filter on the object of the shrink point to determine the name-value pair to use, as follows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query: objects, object="lvm/Sample Container/Sample Region", list options</PRE
></FONT
></TD
></TR
></TABLE
><P
>With the option information that is returned, you can construct the command, as follows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>shrink: "lvm/Sample Container/Sample Region", remove_size=500MB</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="mkfs"
></A
>16.3. Example: expand a volume</H1
><P
>This section tells how to expand a volume a compatibility volume by 500 MB.</P
><A
NAME="AEN3296"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN3297"
></A
><P
><B
>Example 16-2. Expand a volume</B
></P
><P
>Expand the volume <TT
CLASS="filename"
>/dev/evms/lvm/Sample Container/Sample Region</TT
>, which is the compatibility volume that was created in the chapter entitled "Creating Volumes," by 500 MB.
</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="expandgui"
></A
>16.3.1. Using the EVMS GUI</H2
><P
>Follow these steps to expand the volume with the EVMS GUI:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select
	<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Expand</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume...</SPAN
>
	</P
></LI
><LI
><P
>Select 
	<SPAN
CLASS="guimenu"
>/dev/evms/lvm/Sample Container/Sample Region</SPAN
>
	from the list of volumes.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenu"
>lvm/Sample Container/Sample Region</SPAN
>  from the list as the expand point.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Enter <TT
CLASS="userinput"
><B
>500MB</B
></TT
> in the "Additional Size" field.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Expand.</SPAN
></P
></LI
></OL
>
</P
><P
>Alternatively, you can perform some of the steps to expand the volume with the GUI
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Volumes</SPAN
> tab, right click
	<TT
CLASS="filename"
>/dev/evms/lvm/Sample Container/Sample Region</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Expand...</SPAN
></P
></LI
><LI
><P
>Continue the operation to expand the volume beginning with step 3
	of the GUI instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="expandncurses"
></A
>16.3.2. Using Ncurses</H2
><P
>Follow these steps to expand a volume with Ncurses:

	<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Expand</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume</SPAN
>.
	</P
></LI
><LI
><P
>Select
	 <SPAN
CLASS="guimenuitem"
>/dev/evms/lvm/Sample Container/Sample Region</SPAN
> from the
	list of volumes.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Select	<SPAN
CLASS="guimenuitem"
>lvm/Sample Container/Sample Region</SPAN
> from
	the list of expand points.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>spacebar</B
> on the <SPAN
CLASS="guimenuitem"
>Additional Size</SPAN
> field.
	</P
></LI
><LI
><P
>At the "::" prompt enter <TT
CLASS="userinput"
><B
>500MB</B
></TT
>.
	</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Expand</SPAN
>.
	</P
></LI
></OL
>


</P
><P
>Alternatively, you can perform some of the steps to shrink the volume with the
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Volumes view, press <B
CLASS="keycap"
>Enter</B
> on /<SPAN
CLASS="guimenuitem"
>dev/evms/lvm/Sample Container/Sample Region</SPAN
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Expand</SPAN
> menu item.</P
></LI
><LI
><P
>Continue the operation beginning with step 3 of the Ncurses instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="expandcli"
></A
>16.3.3. Using the CLI</H2
><P
>The <B
CLASS="command"
>expand</B
> command takes an expand point followed by an optional name
value pair and an expandable object.  To find the expand point, use the <B
CLASS="command"
>query</B
> command with the Expand Points filter on the object or volume you plan to expand.  For example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query: expand points, "/dev/evms/lvm/Sample Container/Sample Region"</PRE
></FONT
></TD
></TR
></TABLE
><P
>Use a list options filter on the object of the expand point to determine the name-value pair to use, as follows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query: objects, object="lvm/Sample Container/Sample Region", list options</PRE
></FONT
></TD
></TR
></TABLE
><P
>The free space in your container is the container name plus <TT
CLASS="filename"
>/Freespace</TT
>.</P
><P
>With the option information that is returned, you can construct the command, as follows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>expand: "lvm/Sample Container/Sample Region", add_size=500MB, 
"lvm/Sample Container/Freespace"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="addfeatures"
></A
>Chapter 17. Adding features to an existing volume</H1
><P
>This chapter tells how to add additional EVMS features to an
already existing EVMS volume.
</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="whyadd"
></A
>17.1. Why add features to a volume?</H1
><P
>EVMS lets you add features such as drive linking to 
a volume that already exists.  By adding features, you avoid having to potentially
destroy the volume and recreate it from scratch.  For example, take the
scenario of a volume that contains important data but is almost full.
If you wanted to add more data to that volume but no free space existed on the
disk immediately after the segment, you could add a drive link to the volume.
The drive link concatenates another object to the end of the volume and 
continues seamlessly.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="exaddfeature"
></A
>17.2. Example: add drive linking to an existing volume</H1
><P
> The following example shows how to add drive linking to a volume with
the EVMS GUI, Ncurses, and CLI interfaces.
</P
><A
NAME="AEN3409"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN3410"
></A
><P
><B
>Example 17-1. Add drive linking to an existing volume</B
></P
><P
>The following sections show how to add a drive link to volume
<TT
CLASS="filename"
>/dev/evms/vol</TT
> and call the drive link "DL."  

</P
></DIV
><P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Drive linking can be done only on
EVMS volumes; therefore, <TT
CLASS="filename"
>/dev/evms/vol</TT
> must be converted to an EVMS volume if it is not
already. </P
></TD
></TR
></TABLE
></DIV
></P
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="addfeaturegui"
></A
>17.2.1. Using the EVMS GUI</H2
><P
>Follow these steps to add a drive link to the volume with the EVMS GUI:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Add</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Feature to Volume</SPAN
>.
	</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>/dev/evms/vol</SPAN
>
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.  
	</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>Drive Linking Feature</SPAN
>. 
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Type <TT
CLASS="userinput"
><B
>DL</B
></TT
> in the Name Field.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Add</SPAN
>.</P
></LI
></OL
>
</P
><P
>Alternatively, you can perform some of the steps to add a drive link with the GUI
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Volumes</SPAN
> tab, right click
	<TT
CLASS="filename"
>/dev/evms/vol</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Add feature...</SPAN
></P
></LI
><LI
><P
>Continue adding the drive link beginning with step 3 of the
	GUI instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="addfeaturesncurses"
></A
>17.2.2. Using Ncurses</H2
><P
>Follow these steps to add a drive link to a volume with Ncurses:

	<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Add</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Feature to Volume</SPAN
>.

	</P
></LI
><LI
><P
>Select
	 <SPAN
CLASS="guimenuitem"
>/dev/evms/vol</SPAN
>.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Select 
	<SPAN
CLASS="guimenuitem"
>Drive Linking Feature</SPAN
>.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Spacebar</B
> to edit the Name field.
	</P
></LI
><LI
><P
>At the "::" prompt enter <TT
CLASS="userinput"
><B
>DL</B
></TT
>.
	</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Add</SPAN
>.</P
></LI
></OL
>
</P
><P
>Alternatively, you can perform some of the steps to add a drive link with the
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Volumes view, press <B
CLASS="keycap"
>Enter</B
> on <SPAN
CLASS="guimenuitem"
>/dev/evms/vol</SPAN
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Add feature</SPAN
> menu item.</P
></LI
><LI
><P
>Continue adding the drive link beginning with step 3 of the Ncurses instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="addfeaturescli"
></A
>17.2.3. Using the CLI</H2
><P
>Use the
	<B
CLASS="command"
>add feature</B
> to add a feature to an existing volume.
	Specify the command name followed by a colon, followed by any options
	and the volume to operate on.  To determine the options for a given
	feature, use the following query:
	</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query: plugins, plugin=DriveLink, list options</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;The option names and descriptions are listed to help you construct
your command.  For our example, the command would look like the following:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>add feature: DriveLink={ Name="DL }, /dev/evms/vol</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="selectact"
></A
>Chapter 18. Selectively activating volumes and objects</H1
><P
>This chapter discusses selective activation and
deactivation of EVMS volumes and objects.
</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="initialactivation"
></A
>18.1. Initial activation using /etc/evms.conf</H1
><P
>&#13;There is a section in the EVMS configuration file,
<TT
CLASS="filename"
>/etc/etc/evms.conf</TT
>, named "activate."  
This section has two entries: "include" and "exclude."  The
"include" entry lists the volumes and objects that should be activated.
The "exclude" entry lists the volumes and objects that should not be
activated.
</P
><P
>&#13;Names in either of the entries can be specified using "*", "?", and
"[...]" notation.  For example, the following entry will activate
all the volumes:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;include = [/dev/evms/*]
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;The next entry specifies that objects sda5 and sda7 not be activated:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;exclude = [ sda[57] ]
</PRE
></FONT
></TD
></TR
></TABLE
><P
>When EVMS is started, it first reads the include entry and builds a list
of the volumes and objects that it should activate.  It then reads the
exclude entry and removes from the list any names found in the exclude list.
For example, an activation section that activates all of the volumes
except <TT
CLASS="filename"
>/dev/evms/temp</TT
> looks like this:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;activate {
	include = [/dev/evms/*]
	exclude = [/dev/evms/temp]
}
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;If <TT
CLASS="filename"
>/etc/evms.conf</TT
> does not contain an activate
section, the default behavior is to activate everything.  This
behavior is consistent with versions of EVMS prior to 2.4.
</P
><P
>&#13;Initial activation via <TT
CLASS="filename"
>/etc/evms.conf</TT
> does not
deactivate any volumes or objects.  It only determines which ones
should be active.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN3528"
></A
>18.2. Activating and deactivating volumes and objects</H1
><P
>&#13;The EVMS user interfaces offer the ability to activate or deactivate
a particular volume or object.  The volume or object will be
activated or deactivated when the changes are saved.
</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN3531"
></A
>18.2.1. Activation</H2
><P
>&#13;You can activate inactive volumes and objects using the various EVMS
user interfaces.
</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>&#13;EVMS does not currently update the EVMS configuration file
(<TT
CLASS="filename"
>/etc/evms.conf</TT
>) when volumes and objects are
activated.  If you activate a volume or object that is not initially
activated and do not make the corresponding change in
<TT
CLASS="filename"
>/etc/evms.conf</TT
>, the volume or object will not be
activated the next time the system is booted and you run
<B
CLASS="command"
>evms_activate</B
> or one of the user interfaces.
</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3540"
></A
>18.2.1.1. Using the EVMS GUI</H3
><P
>To activate volumes or objects with the GUI, follow these steps:
<P
></P
><OL
TYPE="1"
><LI
><P
>Select  
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Activation</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Activate...</SPAN
>
</P
></LI
><LI
><P
>Select the volume(s) and object(s) you want to activate.
</P
></LI
><LI
><P
>&#13;Click <SPAN
CLASS="guibutton"
>Activate</SPAN
>.
</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Save</SPAN
> to save the changes and
activate the volume(s) and object(s).
</P
></LI
></OL
>

</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3558"
></A
>18.2.1.2. Using the EVMS GUI context-sensitive menu</H3
><P
>To activate with the GUI context-sensitive menu, follow these steps:

<P
></P
><OL
TYPE="1"
><LI
><P
>&#13;Right click the volume or object you want to activate.
</P
></LI
><LI
><P
>&#13;Click "Activate."
</P
></LI
><LI
><P
>&#13;Click <SPAN
CLASS="guibutton"
>Activate</SPAN
>.
</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Save</SPAN
> to save the changes and
activate the volume(s) and object(s).
</P
></LI
></OL
>

</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3572"
></A
>18.2.1.3. Using Ncurses</H3
><P
>To activate a volume or object with Ncurses, follow these steps:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select  
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Activation</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Activate...</SPAN
>
</P
></LI
><LI
><P
>Select the volume(s) and object(s) you want to activate.
</P
></LI
><LI
><P
>&#13;Select <SPAN
CLASS="guibutton"
>Activate</SPAN
>.
</P
></LI
><LI
><P
>Select 
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Save</SPAN
> 
to save the changes and
activate the volume(s) and object(s).
</P
></LI
></OL
>

</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3592"
></A
>18.2.1.4. Using the Ncurses context-sensitive menu</H3
><P
>To enable activation on a volume or object with the 
Ncurses context-sensitive menu, follow these steps:

<P
></P
><OL
TYPE="1"
><LI
><P
>&#13;Highlight the volume or object you want to activate and press
<B
CLASS="keycap"
>Enter</B
>.
</P
></LI
><LI
><P
>&#13;Select "Activate."
</P
></LI
><LI
><P
>&#13;Select <SPAN
CLASS="guibutton"
>Activate</SPAN
>.
</P
></LI
><LI
><P
>Select 
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Save</SPAN
> 
to save the changes and
activate the volume(s) and object(s).
</P
></LI
></OL
>

</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3609"
></A
>18.2.1.5. Using the CLI</H3
><P
>To activate a volume or object with the CLI, 
issue the following command to the CLI (where "name" is the name of
the volume or object you want to activate):</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;Activate:name
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN3613"
></A
>18.2.2. Deactivation</H2
><P
>&#13;You can deactivate active volumes and objects using the various EVMS
user interfaces.
</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>&#13;EVMS does not currently update the EVMS configuration file
(<TT
CLASS="filename"
>/etc/evms.conf</TT
>) when a volume or object is
deactivated.
If you deactivate a volume or object that is initially activated and
do not make the corresponding change in <TT
CLASS="filename"
>/etc/evms.conf</TT
>,
then the volume or object will be activated the next time you run
<B
CLASS="command"
>evms_activate</B
> or one of the user interfaces.
</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3622"
></A
>18.2.2.1. Using the EVMS GUI</H3
><P
>To deactivate a volume or object with the GUI, follow these steps:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select  
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Activation</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Deactivate...</SPAN
>
</P
></LI
><LI
><P
>Select the volume(s) and object(s) you want to deactivate.
</P
></LI
><LI
><P
>&#13;Click <SPAN
CLASS="guibutton"
>Deactivate</SPAN
>.
</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Save</SPAN
> to save the changes and
activate the volume(s) and object(s).
</P
></LI
></OL
>

</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3640"
></A
>18.2.2.2. Using the EVMS GUI context-sensitive menu</H3
><P
>To deactivate a volume or object with the GUI 
context-sensitive menu, follow these steps:

<P
></P
><OL
TYPE="1"
><LI
><P
>&#13;Right click the volume or object you want to deactivate.
</P
></LI
><LI
><P
>&#13;Click "Deactivate."
</P
></LI
><LI
><P
>&#13;Click <SPAN
CLASS="guibutton"
>Deactivate</SPAN
>.
</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Save</SPAN
> to save the changes and
activate the volume(s) and object(s).
</P
></LI
></OL
>

</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3654"
></A
>18.2.2.3. Using Ncurses</H3
><P
>To deactive a volume or object with Ncurses, follow these steps:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select  
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Activation</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Deactivate...</SPAN
>
</P
></LI
><LI
><P
>Select the volume(s) and object(s) you want to deactivate.
</P
></LI
><LI
><P
>&#13;Select <SPAN
CLASS="guibutton"
>Deactivate</SPAN
>.
</P
></LI
><LI
><P
>Select 
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Save</SPAN
>
to save the changes and
deactivate the volume(s) and object(s).
</P
></LI
></OL
>

</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3674"
></A
>18.2.2.4. Using the Ncurses context-sensitive menu</H3
><P
>To deactivate a volume or object with the 
Ncurses context-sensitive menu, follow these steps:

<P
></P
><OL
TYPE="1"
><LI
><P
>&#13;Highlight the volume or object you want to deactivate and press
<B
CLASS="keycap"
>Enter</B
>.
</P
></LI
><LI
><P
>&#13;Select "Deactivate."
</P
></LI
><LI
><P
>&#13;Select <SPAN
CLASS="guibutton"
>Deactivate</SPAN
>.
</P
></LI
><LI
><P
>Select 
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Save</SPAN
> 
to save the changes and
deactivate the volume(s) and object(s).
</P
></LI
></OL
>

</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3691"
></A
>18.2.2.5. Using the CLI</H3
><P
>To deactivate a volume or object with the CLI, 
issue the following command to the CLI (where "name" is the name of
the volume or object you want to deactivate):</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;Deactivate:name
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN3695"
></A
>18.2.3. Activation and deactivation dependencies</H2
><P
>&#13;In order for a volume or object to be active, all of its children
must be active.  When you activate a volume or object, EVMS will
activate all the objects that the volume or object comprises.
</P
><P
>&#13;Similarly, in order for an object to be inactive, all of its
parents cannot be activate.  When you deactivate an object, EVMS
will deactivate all of the objects and volumes that are built from
that object.
</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3699"
></A
>18.2.3.1. Dependencies during initial activation</H3
><P
>&#13;As discussed in <A
HREF="#initialactivation"
>Section 18.1</A
>, 
when EVMS starts, it builds an initial list of
volumes and objects whose names match the "include" entry in the
activation section of <TT
CLASS="filename"
>/etc/evms.conf</TT
>.  Because those
volumes and objects cannot be active unless the objects they comprise are
active, EVMS then adds to the list all the objects that are comprised by
the volumes and objects that were found in the initial match.
</P
><P
>&#13;EVMS then removes from the list the volumes and objects whose names
match the "exclude" entry in the activation section of
<TT
CLASS="filename"
>/etc/evms.conf</TT
>.  Because any volumes or objects
that are built from the excluded ones cannot be active, EVMS removes
them from the list as well.
</P
><P
>&#13;The enforcement of the dependencies can result in behavior that is not
immediately apparent.
Let's say, for example, that segment hda7 is made into volume
<TT
CLASS="filename"
>/dev/evms/home</TT
>. and the activation section in
<TT
CLASS="filename"
>/etc/evms.conf</TT
> looks like this:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;activate {
	include = [*]
	exclude = [hda*]
}
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;When EVMS builds the list of volumes and objects to activate,
everything is included.  EVMS next removes all objects whose names
start with "hda."  hda7 will be removed from the list.
Next, because volume <TT
CLASS="filename"
>/dev/evms/home</TT
> is built
from hda7, it will also be removed from the list and will not be
activated.
So, although volume <TT
CLASS="filename"
>/dev/evms/home</TT
> is not
explicitly in the exclude list, it is not activated because it
depends on an object that will not be activated.
</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3713"
></A
>18.2.3.2. Dependencies for compatibility volumes</H3
><P
>&#13;Compatibility volumes are made directly from the volume's object.
That is, the device node for the volume points directly to the device
for the volume's object.
Because a compatibility volume is inseparable from its object, a
compatibility volume itself cannot be deactivated.
To deactivate a compatibility volume you must deactivate the volume's object.
</P
><P
>&#13;Similarly, if a compatibility volume and its object are not active
and you activate the volume's object, the compatibility volume will be
active as well.
</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="mountunmount"
></A
>Chapter 19. Mounting and unmounting volumes from within EVMS</H1
><P
>&#13;Some volume operations, such as expanding and shrinking, may require that
the volume be mounted or unmounted before you can perform the operation.
EVMS lets you mount and unmount volumes from within EVMS without having
to go to a separate terminal session.
</P
><P
>&#13;EVMS performs the mount and unmount operations immediately.
It does not wait until the changes are saved.
</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="mntvol"
></A
>19.1. Mounting a volume</H1
><P
>This section tells how to mount a volume through the various EVMS
user interfaces.
</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="mntgui"
></A
>19.1.1. Using the EVMS GUI</H2
><P
>Follow these steps to mount a volume with the EVMS GUI:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>File System</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Mount</SPAN
>.
	</P
></LI
><LI
><P
>Select the volume you want to mount.
	</P
></LI
><LI
><P
>In the Mount Point box, enter the directory
	on which you want to mount the volume.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Options</SPAN
> if you
	want to enter additional options for the mount.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Mount</SPAN
>.
	</P
></LI
></OL
>
</P
><P
>Alternatively, you can mount a volume from the EVMS GUI
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Right click the volume you want to mount.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Mount...</SPAN
></P
></LI
><LI
><P
>In the Mount Point box, enter the directory
	on which you want to mount the volume.
	</P
></LI
><LI
><P
>&#13;	Click <SPAN
CLASS="guibutton"
>Options</SPAN
> if you want to enter
	additional options for the mount.</P
></LI
><LI
><P
>&#13;	Click <SPAN
CLASS="guibutton"
>Mount</SPAN
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="mountncurses"
></A
>19.1.2. Using Ncurses</H2
><P
>Follow these steps to mount a volume with Ncurses:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>File System</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Mount...</SPAN
>.
	</P
></LI
><LI
><P
>Select the volume you want to mount.</P
></LI
><LI
><P
>At the Mount Point prompt, enter the directory
on which you want to mount the volume and press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>Mount Options</SPAN
> 
if you want to enter
additional options for the mount.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guibutton"
>Mount</SPAN
>.</P
></LI
></OL
>
</P
><P
>Alternatively, you can mount a volume with the Ncurses
context-sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Highlight the volume you want to mount and press <B
CLASS="keycap"
>Enter</B
>.
</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>Mount File System</SPAN
>.</P
></LI
><LI
><P
>At the Mount Point prompt, enter the directory on which you
want to mount the volume and press <B
CLASS="keycap"
>Enter</B
>.
</P
></LI
><LI
><P
>&#13;Select <SPAN
CLASS="guimenuitem"
>Mount Options</SPAN
> if you want to enter 
additional options for the mount.
</P
></LI
><LI
><P
>&#13;Select <SPAN
CLASS="guimenuitem"
>Mount</SPAN
>.
</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN3797"
></A
>19.1.3. Using the CLI</H2
><P
>To mount a volume with the CLI, use the following command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>mount:&#60;volume&#62;, &#60;mount point&#62;, [ &#60;mount options&#62; ]</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#60;volume&#62; is the name of the volume to be mounted.</P
><P
>&#60;mount point&#62; is the name of the directory on which to mount the volume.</P
><P
>&#60;mount options&#62; is a string of options to be passed to the &#60;command&#62;mount&#60;/command&#62;
command.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN3804"
></A
>19.2. Unmounting a volume</H1
><P
>This section tells how to unmount a volume through the various EVMS user interfaces.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN3807"
></A
>19.2.1. Using the EVMS GUI</H2
><P
>Follow these steps to unmount a volume with the EVMS GUI:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>File System</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Unmount</SPAN
>.
	</P
></LI
><LI
><P
>Select the volume you want to unmount.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Unmount</SPAN
>.
	</P
></LI
></OL
>
</P
><P
>Alternatively, you can unmount a volume from the EVMS GUI
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Right click the volume you want to unmount.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Unmount...</SPAN
></P
></LI
><LI
><P
>&#13;	Click <SPAN
CLASS="guibutton"
>Unmount</SPAN
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="unmountncurses"
></A
>19.2.2. Using Ncurses</H2
><P
>Follow these steps to unmount a volume with Ncurses:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>File System</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Unmount...</SPAN
>.
	</P
></LI
><LI
><P
>Select the volume you want to unmount.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guibutton"
>Unmount</SPAN
>.</P
></LI
></OL
>
</P
><P
>Alternatively, you can unmount a volume with the Ncurses
context-sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Highlight the volume you want to unmount and press <B
CLASS="keycap"
>Enter</B
>.
</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>Unmount File System....</SPAN
>.</P
></LI
><LI
><P
>&#13;Select <SPAN
CLASS="guimenuitem"
>Unmount</SPAN
>.
</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN3858"
></A
>19.2.3. Using the CLI</H2
><P
>To unmount a volume with the CLI, use the following command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>unmount:&#60;volume&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#60;volume&#62; is the name of the volume to be unmounted.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN3863"
></A
>19.3. The SWAPFS file system</H1
><P
>A volume with the SWAPFS file system is not mounted or unmounted.
Rather, swapping is turned on for the volume using the 
<B
CLASS="command"
>sbin/swapon</B
> command and turned off using the
&#60;command&#62;sbin/swapoff&#60;/command&#62;.  EVMS lets you turn swapping on or off
for a volume from within EVMS without having to go to a separate terminal session.</P
><P
>As with mounting and unmounting, EVMS performs the swapon and swapoff
operations immediately.  It does not wait until the changes are saved.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN3868"
></A
>19.3.1. Turning swap on</H2
><P
>This section tells how to turn swap on using the various EVMS user interfaces.</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3871"
></A
>19.3.1.1. Using the EVMS GUI</H3
><P
>Follow these steps to turn swap on with the EVMS GUI:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Other</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume tasks...</SPAN
>.
	</P
></LI
><LI
><P
>Select the volume you want to turn on swapping and click <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Select "Swap on" and click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select the priority for the swap.  If you select "High" you will 
	get an additional prompt for the priority level.  
	The priority level must be a number in the range of 0 to 32767.  
	The default is 0.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Swap on</SPAN
>.</P
></LI
></OL
>
</P
><P
>Alternatively, you can turn swap on from the EVMS GUI
context-sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Right click the volume with the SWAPFS you want to turn on.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Swap on...</SPAN
></P
></LI
><LI
><P
>Select the priority for the swap.  If you select "High" you will get an
	additional prompt for the priority level.  The priority level must be a number
	in the range of 0 to 32767.  The default is 0.</P
></LI
><LI
><P
>&#13;	Click <SPAN
CLASS="guibutton"
>Swap on</SPAN
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3904"
></A
>19.3.1.2. Using Ncurses</H3
><P
>Follow these steps to turn swap on with Ncurses:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Other</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume tasks...</SPAN
>.
	</P
></LI
><LI
><P
>Select the volume on which you want to turn on swapping and select
<SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select "Swap on" and select <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select the priority for the swap.  If you select "High" you will get an
	additional prompt for the priority level.  The priority level must be a number in
	the range of 0 to 32767.  The default is 0.</P
></LI
><LI
><P
>Select "Swap on."</P
></LI
></OL
>
</P
><P
>Alternatively, you can turn swap on with the Ncurses
context-sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Highlight the volume with the SWAPFS you want to turn on.
</P
></LI
><LI
><P
>Select "Swap on...."</P
></LI
><LI
><P
>&#13;Select the priority for the swap.  If you select "High" you will get an
	additional prompt for the priority level.  The priority level must be a number in
	the range of 0 to 32767.  The default is 0.
</P
></LI
><LI
><P
>Select "Swap on."</P
></LI
></OL
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3934"
></A
>19.3.1.3. Using the CLI</H3
><P
>To turn swap on with the CLI, use the following command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;Task: swapon, &#60;volume&#62;[, priority=low | , priority=high [level=0..32767]]
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#60;volume&#62; is the name of the volume with SWAPFS you want to turn on.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN3939"
></A
>19.3.2. Turning swap off</H2
><P
>This section tells how to turn swap off using the various EVMS user interfaces.</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3942"
></A
>19.3.2.1. Using the EVMS GUI</H3
><P
>Follow these steps to turn swap off with the EVMS GUI:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Other</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume tasks...</SPAN
>.
	</P
></LI
><LI
><P
>Select the volume you want to turn off swapping and click <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Select "Swap off" and click <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Swap off</SPAN
>.</P
></LI
></OL
>
</P
><P
>Alternatively, you can turn swap off from the EVMS GUI
context-sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Right click the volume with the SWAPFS you want to turn off.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Swap off...</SPAN
></P
></LI
><LI
><P
>&#13;	Click <SPAN
CLASS="guibutton"
>Swap off</SPAN
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3971"
></A
>19.3.2.2. Using Ncurses</H3
><P
>Follow these steps to turn swap off with Ncurses:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Other</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume tasks...</SPAN
>.
	</P
></LI
><LI
><P
>Select the volume on which you want to turn off swapping and select
<SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select "Swap off" and select <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>Select "Swap off."</P
></LI
></OL
>
</P
><P
>Alternatively, you can turn swap on with the Ncurses
context-sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Highlight the volume with the SWAPFS you want to turn off.
</P
></LI
><LI
><P
>Select "Swap off...."</P
></LI
><LI
><P
>Select "Swap off."</P
></LI
></OL
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN3997"
></A
>19.3.2.3. Using the CLI</H3
><P
>To turn swap on with the CLI, use the following command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;Task: swapoff, &#60;volume&#62;
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#60;volume&#62; is the name of the volume with SWAPFS you want to turn off.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="plugintasks"
></A
>Chapter 20. Plug-in operations tasks</H1
><P
>This chapter discusses plug-in operations tasks and shows how to complete a plug-in task with the EVMS GUI, Ncurses, and CLI interfaces.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="aboutplugintasks"
></A
>20.1. What are plug-in tasks?</H1
><P
>Plug-in tasks are functions that are available only within the context of a particular plug-in.  These functions are not common to all plug-ins.  For example, tasks to add spare disks to a RAID array make sense only in the context of the MD plug-in, and tasks to reset a snapshot make sense only in the context of the Snapshot plug-in.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="pluginexample"
></A
>20.2. Example: complete a plug-in operations task</H1
><P
> This section shows how to complete a plug-in operations task with the EVMS GUI, Ncurses, and CLI interfaces.</P
><A
NAME="AEN4011"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN4012"
></A
><P
><B
>Example 20-1. Add a spare disk to a compatibility volume made from an MDRaid5 region</B
></P
><P
>This example adds disk <TT
CLASS="filename"
>sde</TT
> as a spare disk onto volume <TT
CLASS="filename"
>/dev/evms/md/md0</TT
>, which is a compatibility volume that was created from an MDRaid5 region.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="plugingui"
></A
>20.2.1. Using the EVMS GUI</H2
><P
>Follow these steps to add <TT
CLASS="filename"
>sde</TT
> to <TT
CLASS="filename"
>/dev/evms/md/md0</TT
>  with the EVMS GUI:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Other</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Storage Object Tasks...</SPAN
>
	</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenu"
>md/md0</SPAN
>.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Add spare object</SPAN
>.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenu"
>sde</SPAN
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Add</SPAN
>.
	</P
></LI
><LI
><P
>The operation is completed when you save.</P
></LI
></OL
>
</P
><P
>Alternatively, you could use context-sensitive menus to 
complete the task, as follows:		

<P
></P
><OL
TYPE="1"
><LI
><P
>View the region <TT
CLASS="filename"
>md/md0</TT
>.  You can view the region either 
	by clicking on the small plus sign beside the volume name 
	(<TT
CLASS="filename"
>/dev/evms/md/md0</TT
>) on the <SPAN
CLASS="guimenu"
>volumes tab</SPAN
>, 
	or by selecting the <SPAN
CLASS="guimenu"
>regions tab</SPAN
>.</P
></LI
><LI
><P
>Right click the region (<TT
CLASS="filename"
>md/md0</TT
>).  A list of acceptable
	Actions and Navigational shortcuts displays.  The last items on the
	list are the tasks that are acceptable at this time.</P
></LI
><LI
><P
>Point to <SPAN
CLASS="guimenu"
>Add spare object</SPAN
> and 
	left click.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenu"
>sde</SPAN
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Add</SPAN
>.</P
></LI
></OL
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="plugintasksncurses"
></A
>20.2.2. Using Ncurses</H2
><P
>Follow these steps to add <TT
CLASS="filename"
>sde</TT
> to <TT
CLASS="filename"
>/dev/evms/md/md0</TT
> with Ncurses:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Other</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Storage Object Tasks</SPAN
>
	</P
></LI
><LI
><P
>Select
	<SPAN
CLASS="guimenuitem"
>md/md0</SPAN
>.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Select
	<SPAN
CLASS="guimenuitem"
>Add spare object</SPAN
>.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.
	</P
></LI
><LI
><P
>Select
	<SPAN
CLASS="guimenuitem"
>sde</SPAN
>.
	</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Add</SPAN
>.
	</P
></LI
></OL
>
</P
><P
>Alternatively, you can use the context sensitive menu to complete the task:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Regions view, press <B
CLASS="keycap"
>Enter</B
> on <SPAN
CLASS="guimenuitem"
>md/md0</SPAN
>.</P
></LI
><LI
><P
>Activate the <SPAN
CLASS="guimenuitem"
>Add spare object</SPAN
> menu item.</P
></LI
><LI
><P
>Select <SPAN
CLASS="guimenuitem"
>sde</SPAN
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Add</SPAN
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="plugincli"
></A
>20.2.3. Using the CLI</H2
><P
>With the EVMS CLI, all plug-in tasks must be 
accomplished with the <B
CLASS="command"
>task</B
> command.  Follow these steps 
to add <TT
CLASS="filename"
>sde</TT
> to <TT
CLASS="filename"
>/dev/evms/md/md0</TT
> 
with the CLI:
	
	<P
></P
><OL
TYPE="1"
><LI
><P
>The following query command with the list 
	options filter to determines 
	the acceptable tasks for a particular object and the name-value 
	pairs it supports. The command returns information about which
	plug-in tasks are available at the current time and provides
	the information necessary for you to complete the command.
	</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query: objects, object=md/md0, list options</PRE
></FONT
></TD
></TR
></TABLE
></LI
><LI
><P
>The command takes the name of the task 
	(returned from the previous query), the object to operate on 
	(in this case, md/md0), any required options (none in this case) 
	and, if necessary, another object to be manipulated 
	(in our example, <TT
CLASS="filename"
>sde</TT
>, which is the spare disk 
	we want to add):

	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>task: addspare, md/md0, sde</PRE
></FONT
></TD
></TR
></TABLE
>

	The command is completed upon saving.</P
></LI
></OL
></P
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="deleterecurs"
></A
>Chapter 21. Deleting objects</H1
><P
>This chapter tells how to delete EVMS objects through the delete and
delete recursive operations.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="howtodel"
></A
>21.1. How to delete objects: delete and delete recursive</H1
><P
>There are two ways in EVMS that you can destroy objects that you 
no longer want: Delete and Delete Recursive.  
The Delete option destroys only the specific object you specify.  
The Delete Recursive option destroys the object you specify and its 
underlying objects, down to the container, if one exists, or else 
down to the disk.  
In order for a volume to be deleted, it must not be mounted.  
EVMS verifies that the volume you are attempting to delete is not 
mounted and does not perform the deletion if the volume is mounted.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="examdelrecur"
></A
>21.2. Example: perform a delete recursive operation</H1
><P
> The following example shows how to destroy a volume and the objects below it with the EVMS GUI, Ncurses, and CLI interfaces.</P
><A
NAME="AEN4142"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><DIV
CLASS="example"
><A
NAME="AEN4143"
></A
><P
><B
>Example 21-1. Destroy a volume and the region and container below it</B
></P
><P
>This example uses the delete recursive operation to destroy volume <TT
CLASS="filename"
>/dev/evms/Sample Volume</TT
> and the region and container below it.  Volume <TT
CLASS="filename"
>/dev/evms/Sample Volume</TT
> is the volume that was created in earlier.  Although we could also use the delete option on each of the objects, the delete recursive option takes fewer steps.  Note that because we intend to delete the container as well as the volume, the operation needs to be performed in two steps: one to delete the volume and its contents, and one to delete the container and its contents.
</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="mkfsgui"
></A
>21.2.1. Using the EVMS GUI</H2
><P
>Follow these steps to delete the volume and the container with the EVMS GUI:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Delete</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume</SPAN
>.
	</P
></LI
><LI
><P
>Select volume <SPAN
CLASS="guimenuitem"
>/dev/evms/Sample Volume</SPAN
>
	from the list.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Recursive Delete</SPAN
>.  This step deletes the volume 
	and the region <TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>.  If you want to 
	keep the 
	underlying pieces or want to delete each piece separately, you would click 
	<SPAN
CLASS="guibutton"
>Delete</SPAN
> instead of <SPAN
CLASS="guibutton"
>Delete Recursive</SPAN
>.
	</P
></LI
><LI
><P
>Assuming you chose Delete Recursive (if not, delete the region before
	continuing with these steps), select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Delete</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
>.
	</P
></LI
><LI
><P
>Select container <SPAN
CLASS="guimenuitem"
>lvm/Sample Container</SPAN
> from the list.
	</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Recursive Delete</SPAN
> to destroy the container and anything
	under it.  Alternatively, click <SPAN
CLASS="guibutton"
>Delete</SPAN
> to destroy only the container (if you built the container on
	 disks as in the example, either command has the same effect).
	</P
></LI
></OL
>
</P
><P
>Alternatively, you can perform some of the volume deletion steps with the GUI context
sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Volumes</SPAN
> tab, right click 
	<TT
CLASS="filename"
>/dev/evms/Sample Volume</TT
>.</P
></LI
><LI
><P
>Click <SPAN
CLASS="guimenuitem"
>Delete...</SPAN
></P
></LI
><LI
><P
>Continue with the operation beginning with step 3 of the
	GUI instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="mkfsncurses"
></A
>21.2.2. Using Ncurses</H2
><P
>Follow these steps to delete the volume and the container with Ncurses:

<P
></P
><OL
TYPE="1"
><LI
><P
>Select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Delete</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Volume</SPAN
>.
	</P
></LI
><LI
><P
>Select volume
	 <SPAN
CLASS="guimenuitem"
>/dev/evms/Sample Volume</SPAN
> from the list.
	</P
></LI
><LI
><P
>Activate 
	<SPAN
CLASS="guibutton"
>Delete Volume Recursively</SPAN
>. 
	This step deletes the volume and the region 
	<TT
CLASS="filename"
>lvm/Sample Container/Sample Region</TT
>.  If you want to keep the 
	underlying pieces or want to delete each piece separately, activate 
	<SPAN
CLASS="guibutton"
>Delete</SPAN
> instead of <SPAN
CLASS="guibutton"
>Delete Recursive</SPAN
>.
	</P
></LI
><LI
><P
>Assuming you chose <SPAN
CLASS="guimenuitem"
>Delete Volume Recursively</SPAN
> 
	(if not, delete the region before continuing with 
	these steps), select <SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Delete</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
>.
	</P
></LI
><LI
><P
>Select container
	<SPAN
CLASS="guimenuitem"
>lvm/Sample Container</SPAN
> from the list.
	</P
></LI
><LI
><P
>Click 
	<SPAN
CLASS="guimenuitem"
>Recursive Delete</SPAN
> to destroy the container and
	everything under it.  Alternatively, activate <SPAN
CLASS="guibutton"
>Delete</SPAN
> to delete
	only the container (if you built the container on disks as in the
	example, either command has the same effect).</P
></LI
><LI
><P
>Press <B
CLASS="keycap"
>Enter</B
>.
	</P
></LI
></OL
>
</P
><P
>Alternatively, you can perform some of the volume deletion steps with the
context sensitive menu:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the Volumes view, press <B
CLASS="keycap"
>Enter</B
> on <SPAN
CLASS="guimenuitem"
>/dev/evms/Sample Volume</SPAN
>.</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Delete</SPAN
>.</P
></LI
><LI
><P
>Continue with the operation beginning with step 3 of the Ncurses instructions.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="deleterecurcli"
></A
>21.2.3. Using the CLI</H2
><P
>Use the
	<B
CLASS="command"
>delete</B
> and <B
CLASS="command"
>delete recursive</B
> 
	commands to destroy EVMS objects.
	Specify the command name followed by a colon, and then specify the 
	volume, object, or container name.  For example: 

<P
></P
><OL
TYPE="1"
><LI
><P
>Enter this command to perform the delete recursive 
operation:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>delete recursive: "/dev/evms/Sample Volume"</PRE
></FONT
></TD
></TR
></TABLE
><P
>This step deletes the volume and the region 
<TT
CLASS="filename"
>/lvm/Sample Container/Sample Region</TT
>.  If you wanted to keep the
underlying pieces or wanted to delete each piece separately, use the <B
CLASS="command"
>delete</B
> command, as follows:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>delete: "/dev/evms/Sample Volume"</PRE
></FONT
></TD
></TR
></TABLE
></LI
><LI
><P
>Assuming you chose <SPAN
CLASS="guimenuitem"
>Delete Volume Recursively</SPAN
> (if not, delete the region before
continuing with these steps) enter the following to destroy the container and everything under it:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>delete recursive: "lvm/Sample Container"</PRE
></FONT
></TD
></TR
></TABLE
><P
>To destroy only the container, enter the following:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>delete: "lvm/Sample Container"</PRE
></FONT
></TD
></TR
></TABLE
></LI
></OL
>
</P
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="evmsreplaceobjects"
></A
>Chapter 22. Replacing objects</H1
><P
>This chapter discusses how to replace objects.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="whatisobjectreplace"
></A
>22.1. What is object-replace?</H1
><P
>Occasionally, you might wish to change the configuration of a volume or
storage object.  For instance, you might wish to replace one of the disks in a
drive-link or RAID-0 object with a newer, faster disk.  As another example, you
might have an EVMS volume created from a simple disk segment, and want to
switch that segment for a RAID-1 region to provide extra data redundancy.  
Object-replace accomplishes such tasks.</P
><P
>&#13;Object-replace gives you the ability to swap one object for another object.
The new object is added while the original object is still in place.  The data is
then copied from the original object to the new object.  When this is complete,
the original object is removed.  This process can be performed while the volume is
mounted and in use.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="replacedlchildobj"
></A
>22.2. Replacing a drive-link child object</H1
><P
>For this example, we will start with a drive-link object named <TT
CLASS="filename"
>link1</TT
>, 
which is composed of two disk segments named sda1 and sdb1.  The goal is to replace
sdb1 with another segment named sdc1.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The drive-linking plug-in allows the target object (sdc1 in this
example) to be the same size or larger than the source object.
If the target is larger, the extra space will be unused.  Other plug-ins
have different restrictions and might require that both objects be the 
same size.
</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="guiobjectreplace"
></A
>22.2.1. Using the EVMS GUI or Ncurses</H2
><P
>Follow these steps to replace sdb1 with sdc1:
	<P
></P
><OL
TYPE="1"
><LI
><P
>Select
		<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Replace.</SPAN
>
		</P
></LI
><LI
><P
>In the "Replace Source Object" panel select
		<SPAN
CLASS="guimenuitem"
>sdb1</SPAN
>.
		</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Next</SPAN
>.</P
></LI
><LI
><P
>In the "Select Replace Target Object" panel, select 
		<SPAN
CLASS="guimenuitem"
>sdc1</SPAN
>. 			</P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Replace</SPAN
>.</P
></LI
></OL
></P
><P
>Alternatively, you can perform these same steps with the
context sensitive menus:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the "Disk Segments" panel, right click (or Press
	<B
CLASS="keycap"
>Enter</B
> on) the object 
	<SPAN
CLASS="guimenuitem"
>sdb1</SPAN
>.</P
></LI
><LI
><P
>Choose <SPAN
CLASS="guimenuitem"
>Replace</SPAN
> on the popup menu.</P
></LI
><LI
><P
>In the "Select Replace Target Object" panel, select
	<SPAN
CLASS="guimenuitem"
>sdc1.</SPAN
></P
></LI
><LI
><P
>Activate <SPAN
CLASS="guibutton"
>Replace</SPAN
>.</P
></LI
></OL
><P
>When you save changes, EVMS begins to copy the data from sdb1 to sdc1.
The status bar at the bottom of the UI will reflect the percent-complete of the
copy operation.  The UI must remain open until the copy is finished.  At that time,
the object sdb1 will be moved to the "Available Objects" panel.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="clireplace"
></A
>22.2.2. Using the CLI</H2
><P
>Use the <B
CLASS="command"
>Replace</B
> to replace objects with
the CLI:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;Replace:source_object_name, target_object_name
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;"source_object_name" is the name of the object you wish to replace with
"target_object_name."  In the following example, sdb1 is replaced with
sdc1.
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;Replace:sdb1,sdc1
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="segstorobjs"
></A
>Chapter 23. Moving segment storage objects</H1
><P
>This chapter discusses how and why to move segments.
</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="segmovewhatis"
></A
>23.1. What is segment moving?</H1
><P
>A segment move is when a data segment is relocated to another
location on the underlying storage object.  The new location of
the segment cannot overlap with the current segment location.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="whymove"
></A
>23.2. Why move a segment?</H1
><P
>&#13;Segments are moved for a variety of reasons.  The most compelling among
them is to make better use of disk freespace.  Disk freespace is an unused
contiguous extent of sectors on a disk that has been identified by EVMS
as a freespace segment.  A data segment can only be expanded by adding
sectors to the end of the segment, moving the end of the data segment
up into the freespace that immediately follows the data segment.  However,
what if there is no freespace following the data segment?  A segment or
segments could
be be moved around to put freespace after the segment that is to be
expanded.  For example:
</P
><P
></P
><UL
><LI
><P
>The segment following the segment to be expanded can be moved
elsewhere on the disk, thus freeing up space after the segment that
is to be expanded.</P
></LI
><LI
><P
>The segment to be expanded can be moved into freespace where
there is more room for the segment to be expanded.
</P
></LI
><LI
><P
>The segment can be moved into freespace that precedes the
segment so that after the move the data segment can be expanded into the freespace
created by the move.</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN4331"
></A
>23.3. Which segment manager plug-ins implement the move function?</H1
><P
>The following segment manager plug-ins support the move function:
</P
><P
></P
><UL
><LI
><P
>&#13;DOS
</P
></LI
><LI
><P
>&#13;s390
</P
></LI
><LI
><P
>&#13;GPT
</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="movesegex"
></A
>23.4. Example: move a DOS segment</H1
><P
> This section shows how to move a DOS segment:</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Note</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>&#13;In the following example, the DOS segment manager has a single
primary partition on disk sda that is located at the very end of the disk.
We want to move it to the front of the drive because we want to expand
the segment but there is currently no freespace following the segment.
</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="guimoveseg"
></A
>23.4.1. Using the EVMS GUI context sensitive menu</H2
><P
>To move the DOS segment through the GUI context sensitive menu,
follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>From the <SPAN
CLASS="guimenuitem"
>Segments</SPAN
> 
		tab, right click
		<TT
CLASS="filename"
>sda1</TT
>.
		</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Move</SPAN
>.</P
></LI
><LI
><P
>Select <TT
CLASS="filename"
>sda_freespace1</TT
>.
		</P
></LI
><LI
><P
>Click <SPAN
CLASS="guibutton"
>Move</SPAN
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="ncursmoveseg"
></A
>23.4.2. Using Ncurses</H2
><P
>To move the DOS segment, follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Use <B
CLASS="keycap"
>Tab</B
> 
		 to select the Disk Segments view.
		</P
></LI
><LI
><P
>Scroll down with the down arrow and
		select <TT
CLASS="filename"
>sda1</TT
>.</P
></LI
><LI
><P
>Press 
		<B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Scroll down with the down arrow and
		select <SPAN
CLASS="guibutton"
>Move</SPAN
> by pressing
		<B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Use the spacebar to select
		<TT
CLASS="filename"
>sda_freespace1</TT
>.</P
></LI
><LI
><P
>Use <B
CLASS="keycap"
>Tab</B
> 
		 to select <SPAN
CLASS="guibutton"
>Move</SPAN
> and press
		<B
CLASS="keycap"
>Enter</B
>.
		</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="clisegmove"
></A
>23.4.3. Using the CLI</H2
><P
>Use the
	<B
CLASS="command"
>task</B
> command to move a DOS segment with the CLI.  
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>task:Move,sda1,sda_freespace1</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="appxdos"
></A
>Appendix A. The DOS plug-in</H1
><P
>The DOS plug-in is the most commonly used EVMS segment manager
plug-in.  The DOS plug-in supports DOS disk partitioning as well as:</P
><P
></P
><UL
><LI
><P
>OS/2 partitions that require extra metadata sectors.</P
></LI
><LI
><P
>Embedded partition tables: SolarisX86, BSD, and UnixWare.</P
></LI
></UL
><P
>The DOS plug-in reads metadata and constructs segment storage
objects that provide mappings to disk partitions.
</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="DOShow"
></A
>A.1. How the DOS plug-in is implemented</H1
><P
>The DOS plug-in provides compatibility with DOS partition tables.
The plug-in produces EVMS segment storage objects that map primary partitions
described by the MBR partition table and logical partitions
described by EBR partition tables.
</P
><P
>DOS partitions have names that are constructed from two pieces
of information:</P
><P
></P
><UL
><LI
><P
>The device they are found on.</P
></LI
><LI
><P
>The partition table entry that provided the information.</P
></LI
></UL
><P
>Take, for example, partition name <TT
CLASS="filename"
>hda1</TT
>, which 
describes a partition that is found on device <TT
CLASS="filename"
>hda</TT
> 
in the MBR partition table.
DOS partition tables can hold four entries.
Partition numbers 1-4 refer to MBR partition records.  Therefore, our
example is telling us that partition <TT
CLASS="filename"
>hda1</TT
> is described
by the very first partition record entry in the MBR partition table.
Logical partitions, however, are different than primary partitions.
EBR partition tables are scattered across a disk but are linked together
in a chain that is first located using an extended partition record found
in the MBR partition table.
Each EBR partition table contains a partition record that describes a logical
partition on the disk.
The name of the logical partition reflects its position in the EBR chain.
Because the MBR partition table reserves numerical names 1-4, the very
first logical partition is always named 5.
The next logical partition, found by following the EBR chain, is called 6,
and so forth.
So, the partition <TT
CLASS="filename"
>hda5</TT
> is a logical partition that is
described by a partition record in the very first EBR partition table.
</P
><P
>While discovering DOS partitions, the DOS plug-in also looks for
OS/2 DLAT metadata to further determine if the disk is an OS/2 disk.
An OS/2 disk has additional metadata and the metadata is validated during
recovery.
This information is important for the DOS plug-in to know because an OS/2 
disk must maintain additional partition information.  (This is why the 
DOS plug-in asks, when being assigned to a disk, if the disk is a
Linux disk or an OS/2 disk.)  The DOS plug-in needs to know how much
information must be kept on the disk and what kind of questions it should
ask the user when obtaining the information.
</P
><P
>&#13;An OS/2 disk can contain compatibility volumes as well as logical volumes.
A compatibility volume is a single partition with an assigned drive
letter that can be mounted.  An OS/2 logical volume is a drive link of 1
or more partitions that have software bad-block relocation at the
partition level.
</P
><P
>&#13;Embedded partitions, like those found on a SolarisX86 disk or a BSD
compatibility disk, are found within a primary partition.
Therefore, the DOS plug-in inspects primary partitions that it has
just discovered to further determine if any embedded partitions exist.
Primary partitions that hold embedded partition tables have partition
type fields that indicate this. 
For example, a primary partition of type 0xA9 probably has a BSD partition
table that subdivides the primary partition into BSD partitions.
The DOS plug-in looks for a BSD disk label and BSD data partitions in the
primary partition.
If the DOS plug-in finds a BSD disk label, it exports the BSD partitions.  Because
this primary partition is actually just a container that holds the BSD
partitions, and not a data partition itself, it is not exported by the
DOS plug-in.
Embedded partitions are named after the primary partition they were
discovered within.  As an example, <TT
CLASS="filename"
>hda3.1</TT
> is
the name of the first embedded partition found within primary partition
<TT
CLASS="filename"
>hda3</TT
>.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="assignDOS"
></A
>A.2. Assigning the DOS plug-in</H1
><P
>&#13;Assigning a segment manager to a disk means that you want the plug-in
to manage partitions on the disk.
In order to assign a segment manager to a disk, the plug-in needs to 
create and maintain the appropriate metadata, which is accomplished
through the "disk type" option.
When you specify the "disk type" option and choose
Linux or OS/2, the plug-in knows what sort of metadata it needs to keep
and what sort of questions it should ask when creating partitions.
</P
><P
>&#13;An additional OS/2 option is the "disk name" option, by which you can 
provide a name for the disk that will be saved in OS/2 metadata and that
will be persistent across reboots.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="creatingDOS"
></A
>A.3. Creating DOS partitions</H1
><P
>&#13;There are two basic DOS partition types:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>A primary partition, which is described by a partition record
in the MBR partition table.</P
></LI
><LI
><P
>A logical partition, which is described by a partition record
in the EBR partition table.</P
></LI
></OL
><P
>Every partition table has room for four partition records; however,
there are a few rules that impose limits on this.
</P
><P
>&#13;An MBR partition table can hold four primary partition records unless you
also have logical partitions.
In this case, one partition record is used to describe an extended
partition and the start of the EBR chain that in turn describes
logical partitions.
</P
><P
>&#13;Because all logical partitions must reside in the extended partition, you
cannot allocate room for a primary partition within the extended partition 
and you
cannot allocate room for a logical partition outside or adjacent to this area.
</P
><P
>&#13;Lastly, an EBR partition table performs two functions:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>It describes a logical partition and therefore uses a partition
record for this purpose.</P
></LI
><LI
><P
>It uses a partition record to locate the next EBR partition table.</P
></LI
></OL
><P
>&#13;EBR partition tables use at most two entries.</P
><P
>&#13;When creating a DOS partition, the options you are presented with depend
on the kind of disk you are working with.  However, both OS/2 disks and
Linux disks require that you choose a freespace segment on the disk
within which to create the new data segment.  The create options are:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>size</DT
><DD
><P
>The size of the partition you are creating.
Any adjustments that are needed for alignment are performed by the
DOS plug-in and the resulting size might differ slightly from the
value you enter.
</P
></DD
><DT
>offset</DT
><DD
><P
>Lets you skip sectors and
start the new partition within the freespace area by specifying a
sector offset.
</P
></DD
><DT
>type</DT
><DD
><P
>Lets you enter a partition type or choose from a list of
partition types; for example, native Linux.
</P
></DD
><DT
>primary</DT
><DD
><P
>Lets you  choose between creating a primary or logical partition.
Due to the rules outlined above, you might or might not have a choice.
The DOS plug-in can determine if a primary or logical partition can be
created in the freespace area you chose and disable this choice.
</P
></DD
><DT
>bootable</DT
><DD
><P
>Lets you  enable the sys_ind flag field in a primary partition
and disable it when creating a logical partition.
The sys_ind flag field identifies the active primary partition for booting.
</P
></DD
></DL
></DIV
><P
>&#13;Additional OS/2 options are the following:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>partition name</DT
><DD
><P
>&#13;An OS/2 partition can have a name, like Fred or Part1.
</P
></DD
><DT
>volume name</DT
><DD
><P
>&#13;OS/2 partitions belong to volumes, either
compatibility or logical, and volumes have names.  However, because
the DOS plug-in is not a logical volume manager, it cannot actually
create OS/2 logical volumes.
</P
></DD
><DT
>drive letter</DT
><DD
><P
>You can specify the drive letter for an OS/2 partition, but it
is not a required field.  Valid drive letters are: C,D...Z.
</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="expandDOS"
></A
>A.4. Expanding DOS partitions</H1
><P
>&#13;A partition is a physically contiguous run of sectors on a disk.
You can expand a partition by adding unallocated sectors to the initial
run of sectors on the disk.  Because the partition must remain physically
contiguous, a partition can only be expanded by growing into an unused
area on the disk.
These unused areas are exposed by the DOS plug-in as freespace segments.
Therefore, a data segment is only expandable if a freespace segment
immediately follows it.  Lastly, because a DOS partition must end on a
cylinder boundary, DOS segments are expanded in
cylinder size increments.  This means that if the DOS segment you want
to expand is followed by a freespace segment, you might be unable to
expand the DOS segment if the freespace segment is less than a cylinder
in size.
</P
><P
>&#13;There is one expand option, as follows:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>size</DT
><DD
><P
>&#13;This is the amount by which you want to expand the data segment.  The amount must
be a multiple of the disk's cylinder size.
</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="shrinkDOS"
></A
>A.5. Shrinking DOS partitions</H1
><P
>&#13;A partition is shrunk when sectors are removed from the end of the
partition.
Because a partition must end on a cylinder boundary, a partition is
shrunk by removing cylinder amounts from the end of the segment.</P
><P
>&#13;There is one shrink option, as follows:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>size</DT
><DD
><P
>The amount by which you want to reduce the size of the segment.
Because a segment ends on a cylinder boundary, this value must be
some multiple of the disk's cylinder size.
</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="deleteDOS"
></A
>A.6. Deleting partitions</H1
><P
>You can delete an existing DOS data segment as long as it is not
currently a compatibility volume, an EVMS volume, or consumed by another
EVMS plug-in.
No options are available for deleting partitions.
</P
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="appxmdreg"
></A
>Appendix B. The MD region manager</H1
><P
>&#13;The Multi-Disk (MD) driver in the Linux kernel and the MD plug-in in
EVMS provide a software implementation of RAID (Redundant Array of
Inexpensive Disks).  The basic idea of software RAID is to combine
multiple hard disks into an array of disks in order to improve capacity,
performance, and reliability.
</P
><P
>&#13;The RAID standard defines a wide variety of methods for combining disks
into a RAID array.
In Linux, MD implements a subset of the full RAID standard, including
RAID-0, RAID-1, RAID-4, and RAID-5.  In addition, MD also supports
additional combinations called Linear-RAID and Multipath.
</P
><P
>&#13;In addition to this appendix, more information about RAID and the
Linux MD driver can be found in the Software RAID HOWTO at
<A
HREF="../../../HOWTO/Software-RAID-HOWTO.html"
TARGET="_top"
>www.tldp.org/HOWTO/Software-RAID-HOWTO.html</A
>.
</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="characraidlvls"
></A
>B.1. Characteristics of Linux RAID levels</H1
><P
>&#13;All RAID levels are used to combine multiple devices into a single MD
array.
The MD plug-in is a region-manager, so EVMS refers to MD arrays as "regions."
MD can create these regions using disks, segments or other regions.
This means that it's possible to create RAID regions using other RAID
regions, and thus combine multiple RAID levels within a single volume stack.
</P
><P
>&#13;The following subsections describe the characteristics of each Linux RAID
level.
Within EVMS, these levels can be thought of as sub-modules of the MD plug-in.
</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="linearmode"
></A
>B.1.1. Linear mode</H2
><P
>&#13;Linear-RAID regions combine objects by appending them to each other.
Writing (or reading) linearly to the MD region starts by writing to the
first child object.
When that object is full, writes continue on the second child object, and so
on until the final child object is full.
Child objects of a Linear-RAID region do not have to be the same size.
</P
><P
>&#13;Advantage:
</P
><P
></P
><UL
><LI
><P
>&#13;Linear-RAID provides a simple method for building very large regions
using several small objects.
</P
></LI
></UL
><P
>&#13;Disadvantages:
</P
><P
></P
><UL
><LI
><P
>&#13;Linear-RAID is not "true" RAID, in the sense that there is no data
redundancy.  If one disk crashes, the RAID region will be unavailable,
and will result in a loss of some or all data on that region.
</P
></LI
><LI
><P
>&#13;Linear-RAID provides little or no performance benefit.
The objects are combined in a simple, linear fashion that doesn't allow
for much (if any) I/O in parallel to multiple child objects.
The performance of a Linear-RAID will generally be equivalent to
the performance of a single disk.
</P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="raid0"
></A
>B.1.2. RAID-0</H2
><P
>&#13;RAID-0 is usually referred to as "striping."
This means that data in a RAID-0 region is evenly distributed and
interleaved on all the child objects.
For example, when writing 16 KB of data to a RAID-0 region with
three child objects and a chunk-size of 4 KB, the data would be written
as follows:
</P
><P
></P
><UL
><LI
><P
>&#13;4 KB to object 0
</P
></LI
><LI
><P
>&#13;4 KB to object 1
</P
></LI
><LI
><P
>&#13;4 KB to object 2
</P
></LI
><LI
><P
>&#13;4 KB to object 0
</P
></LI
></UL
><P
>&#13;Advantages:
</P
><P
></P
><UL
><LI
><P
>&#13;Like Linear-RAID, RAID-0 provides a simple method for building very
large regions using several small objects.
</P
></LI
><LI
><P
>&#13;In general, RAID-0 provides I/O performance improvements, because it can
break large I/O requests up and submit them in parallel across
several disks.
</P
></LI
></UL
><P
>&#13;Disadvantage:
</P
><P
></P
><UL
><LI
><P
>&#13;Also like Linear-RAID, RAID-0 is not "true" RAID, in the sense that there
is no data redundancy (hence the name RAID "zero").  If one disk crashes,
the RAID region will be unavailable, and will likely result in a loss of all
data on that region.
</P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="raid1"
></A
>B.1.3. RAID-1</H2
><P
>&#13;RAID-1 is usually referred to as "mirroring."  Each child object in a
RAID-1 region contains an identical copy of the data in the region.
A write to a RAID-1 region results in that data being written
simultaneously to all child objects.
A read from a RAID-1 region can result in reading the data from any
one of the child objects.
Child objects of a RAID-1 region do not have to be the same size, but the
size of the region will be equal to the size of the smallest child object.
</P
><P
>&#13;Advantages:
</P
><P
></P
><UL
><LI
><P
>&#13;RAID-1 provides complete data redundancy. In a RAID-1 region made from
N child objects, up to N-1 of those objects can crash and the region will
still be operational, and can retrieve data from the remaining objects.
</P
></LI
><LI
><P
>&#13;RAID-1 can provide improved performance on I/O-reads.  Because all child
objects contain a full copy of the data, multiple read requests can be
load-balanced among all the objects.
</P
></LI
></UL
><P
>Disadvantages:</P
><P
></P
><UL
><LI
><P
>&#13;RAID-1 can cause a decrease in performance on I/O-writes.
Because each child object must have a full copy of the data, each
write to the region must be duplicated and sent to each object.
A write request cannot be completed until all duplicated writes to
the child objects are complete.
</P
></LI
><LI
><P
>&#13;A RAID-1 region with N disks costs N times as much as a single disk, but
only provides the storage space of a single disk.
</P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="raid45"
></A
>B.1.4. RAID-4/5</H2
><P
>&#13;RAID-4/5 is often referred to as "striping with parity."  Like RAID-0,
the data in a RAID-4/5 region is striped, or interleaved, across all the
child objects.
However, in RAID-4/5, parity information is also calculated and recorded
for each stripe of data in order to provide redundancy in case one of
the objects is lost.
In the event of a disk crash, the data from that disk can be recovered
based on the data on the remaining disks and the parity information.
</P
><P
>&#13;In RAID-4 regions, a single child object is used to store the parity
information for each data stripe.  However, this can cause an I/O
bottleneck on this one object, because the parity information must be
updated for each I/O-write to the region.
</P
><P
>&#13;In RAID-5 regions, the parity is spread evenly across all the child
objects in the region, thus eliminating the parity bottleneck in RAID-4.
RAID-5 provides four different algorithms for how the parity is
distributed.  In fact, RAID-4 is often thought of as a special case of
RAID-5 with a parity algorithm that simply uses one object instead of
all objects.  This is the viewpoint that Linux and EVMS use.
Therefore, the RAID-4/5 level is often just referred to as RAID-5, with
RAID-4 simply being one of the five available parity algorithms.
</P
><P
>Advantages and disadvantages</P
><P
></P
><UL
><LI
><P
>&#13;Like RAID-1, RAID-4/5 provides redundancy in the event of a hardware
failure.
However, unlike RAID-1, RAID-4/5 can only survive the loss of a
single object.
This is because only one object's worth of parity is recorded.
If more than one object is lost, there isn't enough parity information
to recover the lost data.
</P
></LI
><LI
><P
>&#13;RAID-4/5 provides redundancy more cost effectively than RAID-1.
A RAID-4/5 region with N disks provides N-1 times the storage space of a
single disk.
The redundancy comes at the cost of only a single disk in the region.
</P
></LI
><LI
><P
>&#13;Like RAID-0, RAID-4/5 can generally provide an I/O performance
improvement, because large I/O requests can be broken up and submitted
in parallel to the multiple child objects.  However, on I/O-writes the
performance improvement will be less than that of RAID-0, because the
parity information must be calculated and rewritten each time a write
request is serviced.
In addition, in order to provide any performance improvement on 
I/O-writes, an in-memory cache must be maintained for recently accessed
stripes so the parity information can be quickly recalculated.
If a write request is received for a stripe of data that isn't in the
cache, the data chunks for the stripe must first be read from disk in
order to calculate the parity.  If such cache-misses occur too often,
the I/O-write performance could potentially be worse than even a
Linear-RAID region.
</P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="multipath"
></A
>B.1.5. Multipath</H2
><P
>&#13;A multipath region consists of one or more objects, just like the other
RAID levels.  However, in multipath, the child objects actually
represent multiple physical paths to the same physical disk.  Such setups
are often found on systems with fiber-attached storage devices or SANs.
</P
><P
>&#13;Multipath is not actually part of the RAID standard, but was added
to the Linux MD driver because it provides a convenient place to create
"virtual" devices that consist of multiple underlying devices.
</P
><P
>&#13;The previous RAID levels can all be created using a wide variety of
storage devices, including generic, locally attached disks (for example, 
IDE and SCSI).  However, Multipath can only be used if the hardware
actually contains multiple physical paths to the storage device, and
such hardware is usually available on high-end systems with fiber-or 
network-attached storage.  Therefore, if you don't know whether you
should be using the Multipath module, chances are you don't need to use it.
</P
><P
>&#13;Like RAID-1 and RAID-4/5, Multipath provides redundancy against
hardware failures.
However, unlike these other RAID levels, Multipath protects against
failures in the paths to the device, and not failures in the device
itself.  If one of the paths is lost (for example, a network adapter
breaks or a fiber-optic cable is removed), I/O will be redirected to the
remaining paths.
</P
><P
>&#13;Like RAID-0 and RAID-4/5, Multipath can provide I/O performance
improvements by load balancing I/O requests across the various paths.
</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="createmdreg"
></A
>B.2. Creating an MD region</H1
><P
>&#13;The procedure for creating a new MD region is very similar for all the
different RAID levels.
When using the EVMS GUI or Ncurses, first choose the 
<SPAN
CLASS="guimenu"
>Actions</SPAN
><SPAN
CLASS="guimenuitem"
>Create</SPAN
>
<SPAN
CLASS="guimenuitem"
>Region</SPAN
> menu item.
A list of region-managers will open, and each RAID level will appear
as a separate plug-in in this list.
Select the plug-in representing the desired RAID level.
The next panel will list the objects available for creating a new RAID
region.
Select the desired objects to build the new region.
If the selected RAID level does not support any additional options,
then there are no more steps, and the region will be created.
If the selected RAID level has extra creation options, the next
panel will list those options.
After selecting the options, the region will be created.
</P
><P
>&#13;When using the CLI, use the following command to create a new region:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;create:region,&#60;plugin&#62;={&#60;option_name&#62;=&#60;value&#62;[,&#60;option_name&#62;=&#60;value&#62;]*},
   &#60;object_name&#62;[,&#60;object_name&#62;]*
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;For &#60;plugin&#62;, the available plug-in names are "MDLinearRegMgr,"
"MDRaid0RegMgr," "MDRaid1RegMgr," "MDRaid5RegMgr," and "MD Multipath."
The available options are listed in the following sections.
If no options are available or desired, simply leave the space blank
between the curly braces.
</P
><P
>&#13;The Linear-RAID and Multipath levels provide no extra options for
creation.  The remaining RAID levels provide the options listed below.
</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="raid0options"
></A
>B.2.1. RAID-0 options</H2
><P
>&#13;RAID-0 has the following option:
</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>chunksize</DT
><DD
><P
>&#13;This option represents the granularity of the striped data.
In other words, the amount of data that is written to one child
object before moving to the next object.  The range of valid values is
4 KB to 4096 KB, and must be a power of 2.  If the option is not
specified, the default chunk size of 32 KB will be used.
</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="raid2options"
></A
>B.2.2. RAID-1 options</H2
><P
>&#13;RAID-1 has the following option:
</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>sparedisk</DT
><DD
><P
>&#13;This option is the name of another object to use as a "hot-spare."
This object cannot be one of the objects selected in the initial
object-selection list.
If no object is selected for this option, then the new region will
simply not initially have a spare.
More information about spare objects is in the following sections.
</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="raid45options"
></A
>B.2.3. RAID-4/5 options</H2
><P
>&#13;RAID-4/5 have the following options:
</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>chunksize</DT
><DD
><P
>&#13;This is the same as the chunksize option for RAID-0.
</P
></DD
><DT
>sparedisk</DT
><DD
><P
>&#13;This is the same as the sparedisk option for RAID-1.
</P
></DD
><DT
>level</DT
><DD
><P
>&#13;Choose between RAID4 and RAID5.  The default value for this option is RAID5.
</P
></DD
><DT
>algorithm</DT
><DD
><P
>&#13;If the RAID-5 level is chosen, this option allows choosing the
desired parity algorithm.
Valid choices are "Left Symmetric" (which is the default),
"Right Symmetric," "Left Asymmetric, and "Right Asymmetric."
If the RAID-4 level is chosen, this option is not available.
</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="activepsareobjs"
></A
>B.3. Active and spare objects</H1
><P
>&#13;An active object in a RAID region is one that is actively used by the
region and contains data or parity information.
When creating a new RAID region, all the objects selected from the
main available-objects panel will be active objects.
Linear-RAID and RAID-0 regions only have active objects, and if any
of those active objects fail, the region is unavailable.
</P
><P
>&#13;On the other hand, the redundant RAID levels (1 and 4/5) can have spare
objects in addition to their active objects.
A spare is an object that is assigned to the region, but does not
contain any live data or parity.  Its primary purpose is to act as a
"hot standby" in case one of the active objects fails.
</P
><P
>&#13;In the event of a failure of one of the child objects, the MD kernel
driver removes the failed object from the region.
Because these RAID levels provide redundancy (either in the form of
mirrored data or parity information), the whole region can continue
providing normal access to the data.
However, because one of the active objects is missing, the region is
now "degraded."
</P
><P
>&#13;If a region becomes degraded and a spare object has been assigned to
that region, the kernel driver will automatically activate that spare object.
This means the spare object is turned into an active object.  However,
this newly active object does not have any data or parity information,
so the kernel driver must "sync" the data to this object.
For RAID-1, this means copying all the data from one of the current
active objects to this new active object.
For RAID-4/5, this means using the data and parity information from the
current active objects to fill in the missing data and parity on the
new active object.
While the sync process is taking place, the region remains in the
degraded state.
Only when the sync is complete does the region return to the full
"clean" state.
</P
><P
>&#13;You can follow the progress of the sync process by examining the
<TT
CLASS="filename"
>/proc/mdstat</TT
> file.
You can also control the speed of the sync process using the files
<TT
CLASS="filename"
>/proc/sys/dev/raid/speed_limit_min</TT
> and
<TT
CLASS="filename"
>/proc/sys/dev/raid/speed_limit_max</TT
>.  To speed up the
process, echo a larger number into the <TT
CLASS="filename"
>speed_limit_min</TT
>
file.
</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="addspareobjs"
></A
>B.3.1. Adding spare objects</H2
><P
>&#13;As discussed above, a spare object can be assigned to a RAID-1 or 
RAID-4/5 region when the region is created.
In addition, a spare object can also be added to an already existing
RAID region.
The effect of this operation is the same as if the object were
assigned when the region was created.
</P
><P
>&#13;If the RAID region is clean and operating normally, the kernel driver
will add the new object as a regular spare, and it will act as a hot-standby
for future failures.
If the RAID region is currently degraded, the kernel driver will
immediately activate the new spare object and begin syncing the data
and parity information.
</P
><P
>&#13;For both RAID-1 and RAID-4/5 regions, use the "addspare" plug-in function
to add a new spare object to the region.  The only argument is the
name of the desired object, and only one spare object can be added at a time.
For RAID-1 regions, the new spare object must be at least as big as the
region, and for RAID-4/5 regions, the new spare object must be at least
as big as the smallest active object.
</P
><P
>&#13;Spare objects can be added while the RAID region is active and in use.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="remspareobjs"
></A
>B.3.2. Removing spare objects</H2
><P
>&#13;If a RAID-1 or RAID-4/5 region is clean and operating normally, and
that region has a spare object, the spare object can be removed from
the region if you need to use that object for another purpose.
</P
><P
>&#13;For both RAID-1 and RAID-4/5 regions, use the "remspare" plug-in
function to remove a spare object from the region.
The only argument is the name of the desired object, and only one spare
object can be removed at a time.
After the spare is removed, that object will show up in the Available-Objects
list in the EVMS user interfaces.
</P
><P
>&#13;Spare objects can be removed while the RAID region is active and in use.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="addactobjsr1"
></A
>B.3.3. Adding active objects to RAID-1</H2
><P
>&#13;In RAID-1 regions, every active object has a full copy of the data for
the region.
This means it is easy to simply add a new active object, sync the
data to this new object, and thus increase the "width" of the mirror.
For instance, if you have a 2-way RAID-1 region, you can add a new
active object, which will increase the region to a 3-way mirror, which
increases the amount of redundancy offered by the region.
</P
><P
>&#13;The first process of adding a new active object can be done in one of
two ways.  First, the "addactive" plug-in function adds any
available object in EVMS to the region as a new active object.
The new object must be at least as big as the size of the RAID-1 region.
Second, if the RAID-1 region has a spare object, that object can be
converted to an active member of the region using the "activatespare"
plug-in function.
</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="faultobjs"
></A
>B.4. Faulty objects</H1
><P
>&#13;As discussed in the previous section, if one of the active objects in a
RAID-1 or RAID-4/5 region has a problem, that object will be kicked out and
the region will become degraded.
A problem can occur with active objects in a variety of ways.
For instance, a disk can crash, a disk can be pulled out of the
system, a drive cable can be removed, or one or more I/Os can cause errors.
Any of these will result in the object being kicked out and the RAID
region becoming degraded.
</P
><P
>&#13;If a disk has completely stopped working or has been removed from the
machine, EVMS obviously will no longer recognize that disk, and it will
not show up as part of the RAID region when running the EVMS user interfaces.
However, if the disk is still available in the machine, EVMS will likely
be able to recognize that the disk is assigned to the RAID region, but has
been removed from any active service by the kernel. 
This type of disk is referred to as a faulty object.
</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="remfaultyobjs"
></A
>B.4.1. Removing faulty objects</H2
><P
>&#13;Faulty objects are no longer usable by the RAID region, and should be
removed.
You can remove faulty objects with the "remfaulty" plug-in function
for both RAID-1 and RAID-4/5.  This operation is very similar to
removing spare objects.  After the object is removed, it will appear
in the Available-Objects list in the EVMS user interfaces.
</P
><P
>&#13;Faulty objects can be removed while the RAID region is active and in use.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="fixtempfailedobjs"
></A
>B.4.2. Fixing temporarily failed objects</H2
><P
>&#13;Sometimes a disk can have a temporary problem that causes the disk to be
marked faulty and the RAID region to become degraded.
For instance, a drive cable can come loose, causing the MD kernel driver
to think the disk has disappeared.
However, if the cable is plugged back in, the disk should be available
for normal use.
However, the MD kernel driver and the EVMS MD plug-in will continue to
indicate that the disk is a faulty object because the disk might have
missed some writes to the RAID region and would therefore be out of
sync with the rest of the disks in the region.
</P
><P
>&#13;In order to correct this situation, the faulty object should be
removed from the RAID region (as discussed in the previous section).
The object will then show up as an Available-Object.
Next, that object should be added back to the RAID region as a spare 
(as discussed in <A
HREF="#addspareobjs"
>Section B.3.1</A
>.  When the
changes are saved, the MD kernel driver will activate the spare and
sync the data and parity.
When the sync is complete, the RAID region will be operating in its
original, normal configuration.
</P
><P
>&#13;This procedure can be accomplished while the RAID region is active and
in use.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="markobjsfaulty"
></A
>B.4.3. Marking objects faulty</H2
><P
>&#13;EVMS provides the ability to manually mark a child of a RAID-1 or
RAID-4/5 region as faulty.
This has the same effect as if the object had some problem or
caused I/O errors.
The object will be kicked out from active service in the region, and
will then show up as a faulty object in EVMS.
It can then be removed from the region as discussed in the previous
sections.
</P
><P
>&#13;There are a variety of reasons why you might want to manually mark an
object faulty.
One example would be to test failure scenarios to learn how Linux and
EVMS deal with the hardware failures.
Another example would be that you want to replace one of the current
active objects with a different object.
To do this, you would add the new object as a spare, then mark the
current object faulty (causing the new object to be activated and
the data to be resynced), and finally remove the faulty object.
</P
><P
>&#13;EVMS allows you to mark an object faulty in a RAID-1 region if there
are more than one active objects in the region.
EVMS allows you to mark an object faulty in a RAID-4/5 region if the
region has a spare object.
</P
><P
>&#13;Use the "markfaulty" plug-in function for both RAID-1 and RAID-4/5. 
This command can be used while the RAID region is active and in use.
</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="resizemdreg"
></A
>B.5. Resizing MD regions</H1
><P
>&#13;RAID regions can be resized in order to expand or shrink the available
data space in the region.
Each RAID level has different characteristics, and thus each RAID level
has different requirements for when and how they can expand or shrink.
</P
><P
>&#13;See <A
HREF="#expandshrink"
>Chapter 16</A
> for general information about
resizing EVMS volumes and objects.
</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="linear"
></A
>B.5.1. Linear</H2
><P
>&#13;A Linear-RAID region can be expanded in two ways.
First, if the last child object in the Linear-RAID region is
expandable, then that object can be expanded, and the RAID region
can expand into that new space.
Second, one or more new objects can be added to the end of the region.
</P
><P
>&#13;Likewise, a Linear-RAID region can be shrunk in two ways.
If the last child object in the region is shrinkable, then that object
can be shrunk, and the RAID region will shrink by the same amount.
Also, one or more objects can be removed from the end of the RAID
region (but the first object in the region cannot be removed).
</P
><P
>&#13;Linear-RAID regions can be resized while they are active and in use.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="resizeraid0"
></A
>B.5.2. RAID-0</H2
><P
>&#13;You can expand a RAID-0 region by adding one new object to the region.
You can shrink a RAID-0 region by removing up to N-1 of the current
child objects in a region with N objects.
</P
><P
>&#13;Because RAID-0 regions stripe across the child objects, when a RAID-0
region is resized, the data must be "re-striped" to account for the new
number of objects.
This means the MD plug-in will move each chunk of data from its
location in the current region to the appropriate location in the
expanded region.
Be forewarned, the re-striping process can take a long time.
At this time, there is no mechanism for speeding up or slowing down
the re-striping process.
The EVMS GUI and text-mode user interface will indicate the progress
of the re-striping.
Please do not attempt to interrupt the re-striping before it is
complete, because the data in the RAID-0 region will likely become
corrupted.
</P
><P
>&#13;RAID-0 regions must be deactivated before they are resized in order to
prevent data corruption while the data is being re-striped.
</P
><P
>&#13;IMPORTANT: Please have a suitable backup available before attempting
a RAID-0 resize.  If the re-striping process is interrupted before it
completes (for example, the EVMS process gets killed, the machine
crashes, or a child object in the RAID region starts returning I/O
errors), then the state of that region cannot be ensured in all situations.
</P
><P
>&#13;EVMS will attempt to recover following a problem during a RAID-0 resize.
The MD plug-in does keep track of the progress of the resize in the MD
metadata.
Each time a data chunk is moved, the MD metadata is updated to
reflect which chunk is currently being processed.
If EVMS or the machine crashes during a resize, the next time you run
EVMS the MD plug-in will try to restore the state of that region based
on the latest metadata information.
If an expand was taking place, the region will be "rolled back" to its
state before the expand.
If a shrink was taking place, the shrink will continue from the
point it stopped.
However, this recovery is not always enough to ensure that the entire
volume stack is in the correct state.
If the RAID-0 region is made directly into a volume, then it will
likely be restored to the correct state.
On the other hand, if the RAID region is a consumed-object in an
LVM container, or a child-object of another RAID region, then the
metadata for those plug-ins might not always be in the correct state
and might be at the wrong location on the RAID region.
Thus, the containers, objects, and volumes built on top of the RAID-0
region might not reflect the correct size and might not even be discovered.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="resizeraid1"
></A
>B.5.3. RAID-1</H2
><P
>&#13;A RAID-1 region can be resized if all of the child objects can be
simultaneously resized by the same amount.
</P
><P
>&#13;RAID-1 regions cannot be resized by adding additional objects.
This type of operation is referred to as "adding active objects," and
is discussed in <A
HREF="#addactobjsr1"
>Section B.3.3</A
>.
</P
><P
>&#13;RAID-1 regions must be deactivated before they are resized.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="resizeRAID-45"
></A
>B.5.4. RAID-4/5</H2
><P
> 
Resizing a RAID-4/5 region follows the same rules and restrictions 
for resizing a RAID-0 region.  Expand a RAID-4/5 region by 
adding one new object to the region.   
Shrink a RAID-4/5 region by removing up to N-1 of the current child objects in a region
with N objects. 
</P
><P
> 
See <A
HREF="#resizeraid0"
>Section B.5.2</A
> for information about how to perform this function.
</P
><P
>&#13;Like RAID-0, RAID-4/5 regions must be deactivated before they are resized.
</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="replaceobjs"
></A
>B.6. Replacing objects</H1
><P
>The MD plug-in allows the child objects of a RAID region to be replaced with
other available objects.
This is accomplished using the general EVMS replace function.
Please see <A
HREF="#evmsreplaceobjects"
>Chapter 22</A
> for more detailed information about how to
perform this function.</P
><P
>For all RAID levels, the replacement object must be at least as big as the
child object being replaced.  If the replacement object is bigger than the
child object being replaced, the extra space on the replacement object will be unused.
In order to perform a replace operation, any volumes that comprise the
RAID region must be unmounted.
</P
><P
>This capability is most useful for Linear-RAID and RAID-0 regions.  It is also allowed
with RAID-1 and RAID-4/5, but those two RAID levels offer the ability to mark objects faulty,
which accomplishes the same end result.
Because that process can be done while the region is in use, it is generally preferable
to object-replace, which must be done with the region deactivated.</P
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="appxlvm"
></A
>Appendix C. The LVM plug-in</H1
><P
>The LVM plug-in combines storage objects into groups called containers.
From these containers, new storage objects can be created, with a variety of
mappings to the consumed objects.  Containers allow the storage capacity of
several objects to be combined, allow additional storage to be added in the future,
and allow for easy resizing of the produced objects.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="lvmimp"
></A
>C.1. How LVM is implemented</H1
><P
>The Linux LVM plug-in is compatible with volumes and volume groups from
the original Linux LVM tools from Sistina Software.  The original LVM is based on the
concept of volume groups.  A volume group (VG) is a grouping of physical volumes 
(PVs), which are usually disks or disk partitions.  The volume group is not directly
usable as storage space; instead, it represents a pool of available storage.
You create logical volumes (LVs) to use this storage.  The storage space of the LV can 
map to one or more of the group's PVs.</P
><P
>The Linux LVM concepts are represented by similar concepts in the EVMS LVM plug-in.
A volume group is called a container, and the logical volumes that are produced are
called regions.  The physical volumes can be disks, segments, or other regions.
Just as in the original LVM, regions can map to the consumed objects in a variety of ways.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="containerops"
></A
>C.2. Container operations</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="createlvmconts"
></A
>C.2.1. Creating LVM containers</H2
><P
>Containers are created with an initial set of objects.  In the LVM plug-in, the
objects can be disks, segments, or regions.  LVM has two options for creating containers.
The value of these options cannot be changed after the container has been created.  The
options are:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>name</DT
><DD
><P
>The name of the new container.</P
></DD
><DT
>pe_size</DT
><DD
><P
>The physical extent (PE) size, which is the granularity with which regions can be created.  The default is 16 MB.  Each region must have a whole number of extents.  
Also, each region can have only up to 65534 extents.  Thus, the PE size for the container
limits the maximum size of a region in that container.  With the default PE size, an LVM
region can be, at most 1 TB.  In addition, each object consumed by the container must
be big enough to hold at least five extents.  Thus, the PE size cannot be arbitrarily large.  Choose wisely.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4729"
></A
>C.2.2. Adding objects to LVM containers</H2
><P
>You can add objects to existing LVM containers in order to increase the pool of
storage that is available for creating regions.  A single container can consume up to 256
objects.  Because the name and PE size of the containers are set when the container is
created, no options are available when you add new objects to a container.  Each object
must be large enough to hold five physical extents.  If an object is not large enough to
satisfy this requirement, the LVM plug-in will not allow the object to be added to the container.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4732"
></A
>C.2.3. Removing objects from LVM containers</H2
><P
>You can remove a consumed object from its container as long as no regions
are mapped to that object.  The LVM plug-in does not allow objects that are in use to
be removed their their container.  If an object must be removed, you can delete or
shrink regions, or move extents, in order to free the object from use.</P
><P
>No options are available for removing objects from LVM containers.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4736"
></A
>C.2.4. Expanding consumed objects in LVM containers</H2
><P
>In addition to adding new objects to an LVM container, 
you can also expand
the space in a container by expanding one of the existing consumed 
objects (PVs).
For example, if a PV is a disk-segment with freespace immediately 
following it on
the disk, you can expand that segment, which will increase the 
amount of freespace in the container.  
Likewise, if a PV is a RAID-0 or RAID-5 region, you can expand
that region by adding additional objects, which in turn increases the 
freespace in the container.</P
><P
>When using the GUI or text-mode UIs, PV-expand is performed by expanding
the container.  
If any of the existing PVs are expandable, they will appear in the
expand-points list.  
Choose the PV to expand, and then the options for expanding
that object.  After the PV has expanded, the container's 
freespace will reflect the additional space available on that PV.</P
><P
>When using the CLI, PV-expand is performed by expanding the 
appropriate object directly.  
The CLI and the EVMS engine will route the necessary commands so the
container is expanded at the same time.</P
><P
>The options for expanding a PV are dependent on the plug-in 
that owns that PV object.
Please see the appropriate plug-in's appendix for more details on 
options for that object.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4742"
></A
>C.2.5. Shrinking consumed objects in LVM containers</H2
><P
>&#13;In addition to removing existing objects from an LVM container, 
you can
also reduce the size of a container by shrinking one of the existing
consumed objects (PVs).  
This is only allowed if the consumed object
has physical extents (PEs) at the end of the object that are not allocated
to any LVM regions.  
In this case, LVM2 will allow the object to
shrink by the number of unused PEs at the end of that object.
</P
><P
>&#13;For example, if a PV is a desk-segment, you can shrink that segment,
which will decrease the amount of freespace in the container.  Likewise,
if a PV is a RAID-0 or RAID-5 region, you can shrink that region by
removing one of the objects, which in turn decreases the freespace in
the container.
</P
><P
>&#13;When using the GUI or text-mode UIs, PV-shrink is performed by shrinking
the container.  If any of the existing PVs are shrinkable, they will
appear in the shrink-points list.  Choose the PV to shrink, and then the
options for shrinking that object.  After the PV has shrunk, the container's
freespace will reflect the reduced space available on that PV.
</P
><P
>&#13;When using the CLI, PV-shrink is performed by shrinking the appropriate
object directly.  The CLI and the EVMS engine will route the necessary
commands so the container is shrunk at the same time.
</P
><P
>&#13;The options for shrinking a PV are dependent on the plug-in that owns
that PV object.  Please see the appropriate plug-in's appendix for more
details on options for that object.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4749"
></A
>C.2.6. Deleting LVM containers</H2
><P
>You can delete a container as long as the container does not have any produced
regions.  The LVM plug-in does not allow containers to be deleted if they have any
regions.  No options are available for deleting LVM containers.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4752"
></A
>C.2.7. Renaming LVM containers</H2
><P
>You can rename an existing LVM container.  When renaming an LVM container,
all of the regions produced from that container will automatically have their names changed as
well, because the region names include the container name.
In the EVMS GUI and text-mode UIs, this is done using the 
<B
CLASS="command"
>modify properties</B
> command,
which is available through the "Actions" menu or the context-sensitive pop-up menus.
In the EVMS CLI, this is done using the <B
CLASS="command"
>set </B
>command.</P
><P
>See <A
HREF="#renamereg"
>Section C.3.6</A
> for more information about the effects of renaming the regions.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN4759"
></A
>C.3. Region operations</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN4761"
></A
>C.3.1. Creating LVM regions</H2
><P
>You create LVM regions from the freespace in LVM containers.  If there is at least
one extent of freespace in the container, you can create a new region.</P
><P
>The following options are available for creating LVM regions:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>name</DT
><DD
><P
>The name of the new region.</P
></DD
><DT
>extents</DT
><DD
><P
>The number of extents to allocate to the new region.  A new region must
have at least one extent and no more than the total available free extents in the container,
or 65534 (whichever is smaller).  If you use the <TT
CLASS="filename"
>extents</TT
> option, the appropriate value
for the size option is automatically calculated.  By default, a new region uses all
available extents in the container.</P
></DD
><DT
>size</DT
><DD
><P
>The size of the new region.  This size must be a multiple of the
container's PE size.  If you use the <TT
CLASS="filename"
>size</TT
> option, the appropriate value for the
extents options is automatically calculated.  By default, a new region uses all
available freespace in the container.</P
></DD
><DT
>stripes</DT
><DD
><P
>If the container consumes two or more objects, and each object has
unallocated extents, then the new region can be striped across multiple objects.
This is similar to RAID-0 striping and achieves an increased amount of I/O
throughput across multiple objects.  This option specifies how many objects the
new region should be striped across.  By default, new regions are not striped, and
this value is set to 1.</P
></DD
><DT
>stripe_size</DT
><DD
><P
>The granularity of striping.  The default value is 16 KB.  Use this option
only if the <TT
CLASS="filename"
>stripes</TT
> option is greater than 1.</P
></DD
><DT
>contiguous</DT
><DD
><P
>This option specifies that the new region must be allocated on a single
object, and that the extents on that object must be physically contiguous.  By default,
this is set to false, which allows regions to span objects.  This option cannot be used
if the <TT
CLASS="filename"
>stripes</TT
> option is greater than 1.</P
></DD
><DT
>pv_names</DT
><DD
><P
>A list of names of the objects the new region should map to.  By default,
this list is empty, which means all available objects will be used to allocate space
to the new region.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4798"
></A
>C.3.2. Expanding LVM regions</H2
><P
>You can expand an existing LVM region if there are unused extents in the
container.  If a region is striped, you can expand it only by using free space on
the objects it is striped across.  If a region was created with the contiguous option,
you can only expand it if there is physically contiguous space following the
currently allocated space.</P
><P
>The following options are available for expanding LVM regions:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>add_extents</DT
><DD
><P
>The number of extents to add to the region.  If you specify this
option, the appropriate value for the add_size option is automatically
calculated.  By default, the region will expand to use all free extents in the
container.</P
></DD
><DT
>add_size</DT
><DD
><P
>The amount of space to add to the region.  If you specify this option,
the appropriate value for the add_extents option is automatically calculated.
By default, the region will expand to use all freespace in the container.</P
></DD
><DT
>pv_names</DT
><DD
><P
>A list of names of the objects to allocate the additional space from.
By default,  this list is empty, which means all available objects will be used to
allocate new space to the region.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4815"
></A
>C.3.3. Shrinking LVM regions</H2
><P
>You can shrink an existing LVM region by removing extents from the end of the
region.  Regions must have at least one extent, so regions cannot be shrunk to zero.</P
><P
>The following options are available when shrinking LVM regions.  Because regions
are always shrunk by removing space from the end of the region, a list of objects
cannot be specified in this command.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>remove_extents</DT
><DD
><P
>The number of extents to remove from the region.  If you specify this option,
the appropriate value for the <TT
CLASS="filename"
>remove_size</TT
> option is automatically calculated.  By
default, one extent is removed from the region.</P
></DD
><DT
>remove_size</DT
><DD
><P
>The amount of space to shrink the region by.  If you specify this option,
the appropriate value for the <TT
CLASS="filename"
>remove_extents</TT
> option is automatically calculated.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4830"
></A
>C.3.4. Deleting LVM regions</H2
><P
>You can delete an existing LVM region as long as it is not currently a 
compatibility volume, an EVMS volume, or consumed by another EVMS plug-in.
No options are available for deleting LVM regions.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4833"
></A
>C.3.5. Moving LVM regions</H2
><P
>The LVM plug-in lets you change the logical-to-physical mapping
for an LVM region and move the necessary data in the process.
This capability is most useful if a PV needs to be removed from a container.
There are currently two LVM plug-in functions for moving regions: 
<B
CLASS="command"
>move_pv</B
> and <B
CLASS="command"
>move_extent</B
>.</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN4838"
></A
>C.3.5.1. move_pv</H3
><P
>When a PV needs to be removed from a container, all PEs on that PV that are
allocated to regions must be moved to other PVs.  The <B
CLASS="command"
>move_pv</B
> command lets you move PEs to other PVs. 
<B
CLASS="command"
>move_pv</B
> is targeted at the LVM container and the desired PV is used as 
the selected object.  The following options are available:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>target_pvs</DT
><DD
><P
>By default, all remaining PVs in the container are used to find
available extents to move the PEs.  You can specify a subset of the PVs with this option.</P
></DD
><DT
>maintain_stripes</DT
><DD
><P
>When the target PV contains striped regions, there are three choices
for handling moving extents that belong to those regions:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>no</DT
><DD
><P
>Don't bother to maintain true striping.  This choice allows
extents to be moved to PVs that the region already uses for other stripes.
This means that the performance will not be as optimal as it is with true
striping, but allows the most flexibility in performing the move operation.
This choice is the default for the <B
CLASS="command"
>maintain_stripes</B
> option.</P
></DD
><DT
>loose</DT
><DD
><P
>Ensure that moved extents do not end up on any PVs that the
striped region already uses.  However, this does not ensure that all moved
extents end up on the same PV.  For example, a region with three stripes may
end up mapping to four or more PVs.</P
></DD
><DT
>strict</DT
><DD
><P
>Ensure that all moved extents end up on the same PV, thus ensuring
true striping with the same number of PVs that the striped region originally used.
This is the most restricted choice, and may prevent the <B
CLASS="command"
>move_pv</B
> operation from
proceeding (depending on the particular configuration of the container).</P
></DD
></DL
></DIV
><P
>If the target PV has no striped regions, the <B
CLASS="command"
>maintain_stripes</B
> option is ignored.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN4869"
></A
>C.3.5.2. move_extent</H3
><P
>In addition to moving all the extents from one PV, the LVM plug-in provides
the ability to move single extents.
This allows a fine-grain tuning of the allocation of extents.
This command is targeted at the region owning the extent to move.  There are
three required options for the <B
CLASS="command"
>move_extent</B
> command:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>le</DT
><DD
><P
>The number of the logical extent to move.  LE numbers start at 0.</P
></DD
><DT
>pv</DT
><DD
><P
>The target object to move the extent to.</P
></DD
><DT
>pe</DT
><DD
><P
>The target physical extent on the target object.  PE numbers
also start at 0.</P
></DD
></DL
></DIV
><P
>To determine the source LE and target PE, it is often helpful to view the
extended information about the region and container in question.
The following are command-line options that can be used to gather this
information:</P
><P
>To view the map of LEs in the region, enter this command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query:ei,&#60;region_name&#62;,Extents</PRE
></FONT
></TD
></TR
></TABLE
><P
>To view the list of PVs in the container, enter this command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query:ei,&#60;container_name&#62;,Current_PVs</PRE
></FONT
></TD
></TR
></TABLE
><P
>To view the current PE map for the desired target PV, enter this command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>query:ei,&#60;container_name&#62;,PEMapPV#</PRE
></FONT
></TD
></TR
></TABLE
><P
># is the number of the target PV in the container.</P
><P
>This information is also easily obtainable in the GUI and Text-Mode UIs by
using the "Display Details" item in the context-popup menus for the desired
region and container.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="renamereg"
></A
>C.3.6. Renaming LVM regions</H2
><P
>You can rename an existing LVM region.  In the EVMS GUI and text-mode UIs, this
is done using the <B
CLASS="command"
>modify properties</B
> command, which is available through the "Actions"
menu or the context-sensitive pop-up menus.  In the EVMS CLI, this is done using the
<B
CLASS="command"
>set</B
> command.</P
><P
>If the renamed LVM region has a compatibility volume on it, then the name of that
compatibility volume will also change.  In order for this to work correctly, that volume must
be unmounted before the name is changed.  Also, be sure to update your
<TT
CLASS="filename"
>/etc/fstab</TT
> file if the volume is listed, or the volume won't be mounted properly the next
time the system boots.</P
><P
>If the renamed LVM region has an EVMS volume or another storage object built on it,
then the region's name change will be transparent to the upper layers.  In this case, the
rename can be done while the volume is mounted.</P
></DIV
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="appxlvm2"
></A
>Appendix D. The LVM2 plug-in</H1
><P
>The LVM2 plug-in provides compatibility with the new volume format
introduced by the LVM2 tools from Red Hat (previously Sistina).
This plug-in is very similar in functionality to the LVM plug-in.  The primary
difference is the new, improved metadata format.
LVM2 is still based on the concept of volume groups (VGs), which are constructed
from physical volumes (PVs) and produce logical volumes (LVs).</P
><P
>Just like the LVM plug-in, the LVM2 plug-in represents volume groups as EVMS containers
and represents logical volumes as EVMS regions.
LVM2 containers combine storage objects (disks, segments, or other regions) to
create a pool of freespace.  Regions are then created from this freespace, with a variety
of mappings to the consumed objects.</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="contops"
></A
>D.1. Container operations</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN4909"
></A
>D.1.1. Creating LVM2 containers</H2
><P
>Containers are created with an initial set of objects.
These objects can be disks, segments, or regions.  There are two options
available when creating an LVM2 container:</P
><P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>name</DT
><DD
><P
>The name of the new container.
</P
></DD
><DT
>extent_size</DT
><DD
><P
>The physical-extent (PE) size, which is the granularity with which regions
can be created.  The default is 32 MB.  Unlike the LVM1 plug-in, there is no
limitation to the number of extents that can be allocated to an LVM2 region.
</P
></DD
></DL
></DIV
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4922"
></A
>D.1.2. Adding objects to LVM2 containers</H2
><P
>You can add objects to existing LVM containers in order to increase
the pool of storage that is available for creating regions.
Because the name and extent-size are set when the container is created,
no options are available when you add new objects to a container.
Each object must be large enough to hold at least one physical extent.
If an object is not large enough to satisfy this requirement, the LVM2 plug-in
will not allow the object to be added to the container.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4925"
></A
>D.1.3. Removing objects from LVM2 containers</H2
><P
>You can remove a consumed object from its container as long as no regions
are mapped to that object.
The LVM2 plug-in does not allow objects that are in use to be removed from their
container.  If an object must be removed, you can delete or shrink regions, or
move extents, in order to free the object from use.</P
><P
>No options are available for removing objects from LVM containers.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4929"
></A
>D.1.4. Expanding consumed objects in LVM2 containers</H2
><P
>In addition to adding new objects to an LVM2 container, you can also expand
the space in a container by expanding one of the existing consumed objects (PVs).
For example, if a PV is a disk-segment with freespace immediately following it on
the disk, you can expand that segment, which will increase the amount of freespace
in the container.  Likewise, if a PV is a RAID-0 or RAID-5 region, you can expand
that region by adding additional objects, which in turn increases the freespace in the
container.</P
><P
>When using the GUI or text-mode UIs, PV-expand is performed by expanding
the container.  If any of the existing PVs are expandable, they will appear in the
expand-points list.  Choose the PV to expand, and then the options for expanding
that object.  After the PV has expanded, the container's freespace will reflect the
additional space available on that PV.</P
><P
>When using the CLI, PV-expand is performed by expanding the appropriate object
directly.  The CLI and the EVMS engine will route the necessary commands so the
container is expanded at the same time.</P
><P
>The options for expanding a PV are dependent on the plug-in that owns that PV object.
Please see the appropriate plug-in's appendix for more details on options for that object.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4935"
></A
>D.1.5. Shrinking consumed objects in LVM2 containers</H2
><P
>&#13;In addition to removing existing objects from an LVM2 container, you can
also reduce the size of a container by shrinking one of the existing
consumed objects (PVs).  This is only allowed if the consumed object
has physical extents (PEs) at the end of the object that are not allocated
to any LVM2 regions.  In this case, LVM2 will allow the object to
shrink by the number of unused PEs at the end of that object.
</P
><P
>&#13;For example, if a PV is a desk-segment, you can shrink that segment,
which will decrease the amount of freespace in the container.  Likewise,
if a PV is a RAID-0 or RAID-5 region, you can shrink that region by
removing one of the objects, which in turn decreases the freespace in
the container.
</P
><P
>&#13;When using the GUI or text-mode UIs, PV-shrink is performed by shrinking
the container.  If any of the existing PVs are shrinkable, they will
appear in the shrink-points list.  Choose the PV to shrink, and then the
options for shrinking that object.  After the PV has shrunk, the container's
freespace will reflect the reduced space available on that PV.
</P
><P
>&#13;When using the CLI, PV-shrink is performed by shrinking the appropriate
object directly.  The CLI and the EVMS engine will route the necessary
commands so the container is shrunk at the same time.
</P
><P
>&#13;The options for shrinking a PV are dependent on the plug-in that owns
that PV object.  Please see the appropriate plug-in's appendix for more
details on options for that object.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4942"
></A
>D.1.6. Deleting LVM2 containers</H2
><P
>You can delete a container as long as the container does not have any produced
regions.
The LVM2 plug-in does not allow containers to be deleted if they have any regions.
No options are available for deleting LVM2 containers.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4945"
></A
>D.1.7. Renaming LVM2 containers</H2
><P
>You can rename an existing LVM2 container.  
When renaming an LVM2 container,
all of the regions produced from that container will automatically have their names changed as
well, because the region names include the container name.
In the EVMS GUI and text-mode UIs, this is done using the 
<B
CLASS="command"
>modify properties</B
> command,
which is available through the "Actions" menu or the context-sensitive pop-up menus.
In the EVMS CLI, this is done using the <B
CLASS="command"
>set </B
>command.</P
><P
>See <A
HREF="#renamereg2"
>Section D.2.5</A
> for more information about the effects of renaming the regions.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="regionops"
></A
>D.2. Region operations</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN4954"
></A
>D.2.1. Creating LVM2 regions</H2
><P
>You create LVM2 regions from the freespace in LVM2 containers.
If there is at least one extent of freespace in the container, you can create a new region.</P
><P
>The following options are available for creating LVM2 regions:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>name</DT
><DD
><P
>The name of the new region.</P
></DD
><DT
>size</DT
><DD
><P
>The size of the new region.  This size must be a multiple of the
container's extent-size.  If it isn't, the size will be rounded down as appropriate.
By default, all of the available freespace in the container will be used for the new region.</P
></DD
><DT
>stripes</DT
><DD
><P
>If the container consumes two or more objects, and each object has unallocated
extents, then the new region can be striped across multiple objects.  This is similar to
RAID-0 striping and achieves an increased amount of I/O throughput.  This option
specifies how many objects the new region should be striped across.  By default, new
regions are not striped, and this value is set to 1.</P
></DD
><DT
>stripe_size</DT
><DD
><P
>The granularity of striping.  The default value is 64 KB.  Use this option only if the
stripes option is greater than 1.</P
></DD
><DT
>pvs</DT
><DD
><P
>A list of names of the objects the new region should map to.  By default, this
list is empty, which means all available objects will be used to allocate space to the new region.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4979"
></A
>D.2.2. Expanding LVM2 regions</H2
><P
>You can expand an existing LVM region if there are any unused extents in the 
container.  The following options are available for expanding LVM regions.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>size</DT
><DD
><P
>The amount of space to add to the region.  This is a delta-size,
not the new absolute size of the region.  As with creating new regions,
this size must be a multiple of the container's extent-size, and will be rounded
down if necessary.</P
></DD
><DT
>stripes</DT
><DD
><P
>The number of objects to stripe this new portion of the region across.
This value can be different than the number of stripes in the existing region.
For example, if the region was created originally with three stripes, but now only
two objects are available, then the new portion of the region could be striped
across just those two objects.  The number of stripes for the last mapping in the
region will be used as the default.</P
></DD
><DT
>stripe_size</DT
><DD
><P
>The granularity of striping. As with the number of stripes, this value
can be different than the stripe-size for the existing region.  By default, the
stripe-size of the last mapping in the region is used.</P
></DD
><DT
>pvs</DT
><DD
><P
>A list of names of the objects the region should be expanded onto.
By default, this list is empty, which means all available objects will be used to
allocate additional space for the region.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN4999"
></A
>D.2.3. Shrinking LVM2 regions</H2
><P
>You can shrink an existing LVM region by removing extents from the end of
the region.  Regions must have at least one extent, so regions cannot be
shrunk to zero.</P
><P
>The following options are available when shrinking LVM regions.
Because regions are always shrunk by removing space from the end of the region,
a list of objects cannot be specified in this command.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>size</DT
><DD
><P
>The amount of space to remove from the region.
This is a delta-size, not the new absolute size of the region.
As with creating and expanding regions, this size must be a multiple of
the container's extent-size, and will be rounded down if necessary.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN5008"
></A
>D.2.4. Deleting LVM2 regions</H2
><P
>You can delete an existing LVM region as long as it is not currently a
compatibility volume, an EVMS volume, or consumed by another EVMS plug-in.
No options are available for deleting LVM regions.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="renamereg2"
></A
>D.2.5. Renaming LVM2 regions</H2
><P
>You can rename an existing LVM2 region.  In the EVMS GUI and text-mode UIs, this
is done using the <B
CLASS="command"
>modify properties</B
> command, which is available through the "Actions"
menu or the context-sensitive pop-up menus.  In the EVMS CLI, this is done using the
<B
CLASS="command"
>set</B
> command.</P
><P
>If the renamed LVM2 region has a compatibility volume on it, then the name of that
compatibility volume will also change.  In order for this to work correctly, that volume must
be unmounted before the name is changed.  Also, be sure to update your
<TT
CLASS="filename"
>/etc/fstab</TT
> file if the volume is listed, or the volume won't be mounted properly the next
time the system boots.</P
><P
>If the renamed LVM2 region has an EVMS volume or another storage object built on it,
then the region's name change will be transparent to the upper layers.  In this case, the
rename can be done while the volume is mounted.</P
></DIV
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="appxcsm"
></A
>Appendix E. The CSM plug-in</H1
><P
>The Cluster Segment Manager (CSM) is the EVMS plug-in that identifies and
manages cluster storage.  The CSM protects disk storage objects by writing metadata
at the start and end of the disk, which prevents other plug-ins from attempting to use the disk.
Other plug-ins can look at the disk, but they cannot see their own metadata signatures
and cannot consume the disk.  The protection that CSM provides allows the CSM to
discover cluster storage and present it in an appropriate fashion to the system. </P
><P
>All cluster storage disk objects must be placed in containers that have the
following attributes:</P
><P
></P
><UL
><LI
><P
>cluster ID that identifies the cluster management software
</P
></LI
><LI
><P
>node ID that identifies the owner of the disk objects
</P
></LI
><LI
><P
>storage type: private, shared, or deported
</P
></LI
></UL
><P
>&#13;The CSM plug-in reads metadata and constructs containers that consume
the disk object.  Each disk provides a usable area, mapped as an EVMS
data segment, but only if the disk is accessible to the node viewing
the storage.</P
><P
>The CSM plug-in performs these operations:
</P
><P
></P
><UL
><LI
><P
>&#13;examines disk objects
</P
></LI
><LI
><P
>&#13;creates containers
</P
></LI
><LI
><P
>&#13;uses the containers to consume disk objects
</P
></LI
><LI
><P
>&#13;produces data segment objects if the disk is accessible to the node
</P
></LI
></UL
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="csmassn"
></A
>E.1. Assigning the CSM plug-in</H1
><P
>Assigning a segment manager to a disk means that you want the plug-in to
manage partitions on the disk.  In order to do this, the plug-in needs to create and
maintain appropriate metadata.  The CSM creates the follow three segments on the disk:</P
><P
></P
><UL
><LI
><P
>primary metadata segment</P
></LI
><LI
><P
>usable area data segment</P
></LI
><LI
><P
>secondary metadata segment</P
></LI
></UL
><P
>The CSM collects the information it needs to perform the assign operation with the
following options:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>NodeId</DT
><DD
><P
>Choose only from a list of configured node IDs that have been
provided to the CSM by clustering software.  The default selection is the
node from which you are running the EVMS user interface.</P
></DD
><DT
>Container Name</DT
><DD
><P
>The name for the container.  You need to keep this name unique
across the cluster to prevent name-in-conflict errors should the container fail over to
another node that has a container with the same name.  
</P
></DD
><DT
>Storage Type</DT
><DD
><P
>Can be either: share, private, or deported. </P
></DD
></DL
></DIV
><P
>Note that you would typically assign the CSM to a disk when you want to
add a disk to an existing CSM container.  If you are creating a new container, you
have a choice of using either:
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Create</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Container</SPAN
> or
<SPAN
CLASS="guimenu"
>Actions</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Add</SPAN
>-&gt;<SPAN
CLASS="guimenuitem"
>Segment Manager</SPAN
>.
</P
><P
>If the container doesn't exist, it will be created for the disk.  If the container already
exists, the disk will be added to it.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="unassignCSM"
></A
>E.2. Unassigning the CSM plug-in</H1
><P
>Unassigning a CSM plug-in results in the CSM removing its metadata from
the specified disk storage object.  The result is that the disk has no segments
mapped and appears as a raw disk object.  The disk is removed from the
container that consumed it and the data segment is removed as well.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN5078"
></A
>E.3. Deleting a CSM container</H1
><P
>An existing CSM container cannot be deleted if it is producing any data segments, 
because other EVMS plug-ins might be building higher-level objects on the CSM objects.
To delete a CSM container, first remove disk objects from the container.  When the last
disk is removed, the container is also removed.</P
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="jfsfsim"
></A
>Appendix F. JFS file system interface module</H1
><P
>&#13;The JFS FSIM lets EVMS users create and manage JFS file systems from
within the EVMS interfaces.  In order to use the JFS FSIM, version 1.0.9 or
later of the JFS utilities must be installed on your system.  The latest
version of JFS can be found at 
<A
HREF="http://oss.software.ibm.com/jfs/"
TARGET="_top"
>http://oss.software.ibm.com/jfs/</A
>.
</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="createjfsfsim"
></A
>F.1. Creating JFS file systems</H1
><P
>&#13;JFS file systems can be created with <B
CLASS="command"
>mkfs</B
> on any EVMS
or compatibility volume (at least 16 MB in size) that does not already
have a file system.  The following options are available for creating
JFS file systems:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>badblocks</DT
><DD
><P
>Perform a read-only check for bad blocks on the volume
before creating the file system.  The default is false.</P
></DD
><DT
>caseinsensitive</DT
><DD
><P
>Mark the file system as case-insensitive (for OS/2 compatibility).
The default is false.</P
></DD
><DT
>vollabel</DT
><DD
><P
>Specify a volume label for the file system.  The default is none.
</P
></DD
><DT
>journalvol</DT
><DD
><P
>Specify the volume to use for an external journal.  This option
is only available with version 1.0.20 or later of the JFS utilities.
The default is none.
</P
></DD
><DT
>logsize</DT
><DD
><P
>&#13;Specify the inline log size (in MB).  This option is only available if
the journalvol option is not set.  The default is 0.4% of the size of
the volume up to 32 MB.
</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="checkjfsfsim"
></A
>F.2. Checking JFS file systems</H1
><P
>&#13;The following options are available for checking JFS file systems with
<B
CLASS="command"
>fsck</B
>:
</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>force</DT
><DD
><P
>Force a complete file system check, even if the file system is
already marked clean.  The default is false.</P
></DD
><DT
>readonly</DT
><DD
><P
>Check the file system is in read-only mode.  Report but do not
fix errors.  If the file system is mounted, this option is
automatically selected.  The default is false.</P
></DD
><DT
>omitlog</DT
><DD
><P
>Omit replaying the transaction log.  This option should only
be specified if the log is corrupt.  The default is false.</P
></DD
><DT
>verbose</DT
><DD
><P
>Display details and debugging information during the check.
The default is false.</P
></DD
><DT
>version</DT
><DD
><P
>Display the version of <TT
CLASS="filename"
>fsck.jfs</TT
> and exit without 
checking the file system.  The default is false.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="removejfsfsim"
></A
>F.3. Removing JFS file systems</H1
><P
>&#13;A JFS file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume
so the file system will not be recognized in the future.  There are no
options available for removing file systems.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="expandjfsfsim"
></A
>F.4. Expanding JFS file systems</H1
><P
>&#13;A JFS file system is automatically expanded when its volume is expanded.
However, JFS only allows the volume to be expanded if it is mounted,
because JFS performs all of its expansions online.  In addition, JFS only
allows expansions if version 1.0.21 or later of the JFS utilities are
installed.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="shrinkjfsfsim"
></A
>F.5. Shrinking JFS file systems</H1
><P
>&#13;At this time, JFS does not support shrinking its file systems.
Hence, volumes with JFS file systems cannot be shrunk.
</P
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="xfsfsim"
></A
>Appendix G. XFS file system interface module</H1
><P
>&#13;The XFS FSIM lets EVMS users create and manage XFS file systems from
within the EVMS interfaces.  In order to use the XFS FSIM, version 2.0.0 or
later of the XFS utilities must be installed on your system.  The latest
version of XFS can be found at 
<A
HREF="http://oss.sgi.com/projects/xfs/"
TARGET="_top"
>http://oss.sgi.com/projects/xfs/</A
>.
</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="createxfsfsim"
></A
>G.1. Creating XFS file systems</H1
><P
>&#13;XFS file systems can be created with <B
CLASS="command"
>mkfs</B
> on any EVMS
or compatibility volume that does not already
have a file system.  The following options are available for creating
XFS file systems:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>vollabel</DT
><DD
><P
>Specify a volume label for the file system.  The default is none.
</P
></DD
><DT
>journalvol</DT
><DD
><P
>Specify the volume to use for an external journal. 
The default is none.
</P
></DD
><DT
>logsize</DT
><DD
><P
>&#13;Specify the inline log size (in MB).  This option is only available if
the journalvol option is not set.  The default is 4 MB; the
allowed range is 2 to 256 MB.
</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="checkxfsfsim"
></A
>G.2. Checking XFS file systems</H1
><P
>&#13;The following options are available for checking XFS file systems with
<B
CLASS="command"
>fsck</B
>:
</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>readonly</DT
><DD
><P
>Check the file system is in read-only mode.  Report but do not
fix errors.  The default is false.</P
></DD
><DT
>verbose</DT
><DD
><P
>Display details and debugging information during the check.
The default is false.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="removexfsfsim"
></A
>G.3. Removing XFS file systems</H1
><P
>&#13;An XFS file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume
so the file system will not be recognized in the future.  There are no
options available for removing file systems.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="expandxfsfsim"
></A
>G.4. Expanding XFS file systems</H1
><P
>&#13;An XFS file system is automatically expanded when its volume is expanded.
However, XFS only allows the volume to be expanded if it is mounted,
because XFS performs all of its expansions online.  
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="shrinkxfsfsim"
></A
>G.5. Shrinking XFS file systems</H1
><P
>&#13;At this time, XFS does not support shrinking its file systems.
Hence, volumes with XFS file systems cannot be shrunk.
</P
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="reiserfsim"
></A
>Appendix H. ReiserFS file system interface module</H1
><P
>&#13;The ReiserFS FSIM lets EVMS users create and manage ReiserFS file systems from
within the EVMS interfaces.  In order to use the 
ReiserFS FSIM, version 3.x.0 or
later of the ReiserFS utilities must be installed on your system.  
In order to get full functionality from the ReiserFS FSIM, use version
3.x.1b or later. The latest
version of ReiserFS can be found at 
<A
HREF="http://www.namesys.com/"
TARGET="_top"
>http://www.namesys.com/</A
>.
</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="createreiserfsim"
></A
>H.1. Creating ReiserFS file systems</H1
><P
>&#13;ReiserFS file systems can be created with <B
CLASS="command"
>mkfs</B
> on any EVMS
or compatibility volume that does not already
have a file system.  The following option is available for creating
ReiserFS file systems:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>vollabel</DT
><DD
><P
>Specify a volume label for the file system.  The default is none.
</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="checkreiserfsim"
></A
>H.2. Checking ReiserFS file systems</H1
><P
>&#13;The following option is available for checking XFS file systems with
<B
CLASS="command"
>fsck</B
>:
</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>mode</DT
><DD
><P
>There are three possible modes for checking a ReiserFS file system:
Check Read-Only, Fix, and Rebuild Tree."</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="removexreiserfsim"
></A
>H.3. Removing ReiserFS file systems</H1
><P
>&#13;A ReiserFS file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume
so the file system will not be recognized in the future.  There are no
options available for removing file systems.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="expandreiserFSfsim"
></A
>H.4. Expanding ReiserFS file systems</H1
><P
>&#13;A ReiserFS file system is automatically expanded when its volume is expanded.
ReiserFS file systems can be expanded if the volume is mounted or
unmounted.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="shrinkreiserfsim"
></A
>H.5. Shrinking ReiserFS file systems</H1
><P
>&#13;A ReiserFS file system is automatically shrunk if the volume is shrunk.
ReiserFS file systems can only be shrunk if the volume is unmounted.
</P
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="ext23fsim"
></A
>Appendix I. Ext-2/3 file system interface module</H1
><P
>&#13;The Ext-2/3 FSIM lets EVMS users create and manage Ext2 and
Ext3 file systems from
within the EVMS interfaces.  In order to use the Ext-2/3 FSIM, 
the e2fsprogs package 
must be installed on your system.  The e2fsprogs package
can be found at 
<A
HREF="http://e2fsprogs.sourceforge.net/"
TARGET="_top"
>http://e2fsprogs.sourceforge.net/</A
>.
</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="createext23fsim"
></A
>I.1. Creating Ext-2/3 file systems</H1
><P
>&#13;Ext-2/3 file systems can be created with <B
CLASS="command"
>mkfs</B
> on any EVMS
or compatibility volume that does not already
have a file system.  The following options are available for creating
Ext-2/3 file systems:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>badblocks</DT
><DD
><P
>Perform a read-only check for bad blocks on the volume
before creating the file system.  The default is false.</P
></DD
><DT
>badblocks_rw</DT
><DD
><P
>Perform a read/write check for bad blocks on the volume before
creating the file system.  The default is false.
</P
></DD
><DT
>vollabel</DT
><DD
><P
>Specify a volume label for the file system.  The default is none.
</P
></DD
><DT
>journal</DT
><DD
><P
>Create a journal for use with the Ext2 file system.  The default
is true.
</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="checkext23fsim"
></A
>I.2. Checking Ext-2/3 file systems</H1
><P
>&#13;The following options are available for checking Ext-2/3 file systems with
<B
CLASS="command"
>fsck</B
>:
</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>force</DT
><DD
><P
>Force a complete file system check, even if the file system is
already marked clean.  The default is false.</P
></DD
><DT
>readonly</DT
><DD
><P
>Check the file system is in read-only mode.  Report but do not
fix errors.  If the file system is mounted, this option is
automatically selected.  The default is false.</P
></DD
><DT
>badblocks</DT
><DD
><P
>Check for bad blocks on the volume and mark them as busy.  The
default is false.
</P
></DD
><DT
>badblocks_rw</DT
><DD
><P
>Perform a read-write check for bad blocks on the volume and mark
them as busy. The default is false.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="removeext23fsim"
></A
>I.3. Removing Ext-2/3 file systems</H1
><P
>&#13;An Ext-2/3 file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume
so the file system will not be recognized in the future.  There are no
options available for removing file systems.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="expandshrinkext23fsim"
></A
>I.4. Expanding and shrinking Ext-2/3 
file systems</H1
><P
>&#13;An Ext-2/3 file system is automatically expanded or shrunk when its volume 
is expanded or shrunk.
However, Ext-2/3 only allows these operations if the volume is
unmounted, because online expansion and shrinkage is not yet supported.
</P
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="gfsfsim"
></A
>Appendix J. OpenGFS file system interface module</H1
><P
>&#13;The OpenGFS FSIM lets EVMS users create and manage OpenGFS 
file systems from within the EVMS interfaces.  
In order to use the OpenGFS FSIM, the OpenGFS utilities must be
installed on your system.  Go to 
<A
HREF="http://sourceforge.net/projects/opengfs"
TARGET="_top"
>http://sourceforge.net/projects/opengfs</A
> for the OpenGFS project.
</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="createopengfsfsim"
></A
>J.1. Creating OpenGFS file systems</H1
><P
>&#13;OpenGFS file systems can be created with <B
CLASS="command"
>mkfs</B
> on any EVMS
or compatibility volume that does not already
have a file system and that is produced from a shared cluster container.  
The following options are available for creating
OpenGFS file systems:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>blocksize</DT
><DD
><P
>Set the file system block size.
The block size is in bytes.
The block size must be a power of 2 between 512 and 65536, inclusive.
The default block size is 4096 bytes.
</P
></DD
><DT
>journals</DT
><DD
><P
>The names of the journal volumes, one for each node.
</P
></DD
><DT
>protocol</DT
><DD
><P
>Specify the name of the locking protocol to use.
The choices are "memexp" and "opendlm."
</P
></DD
><DT
>lockdev</DT
><DD
><P
>Specify the shared volume to be used to contain the locking metadata.
</P
></DD
></DL
></DIV
><P
>&#13;The OpenGFS FSIM only takes care of file system operations.
It does not take care of OpenGFS cluster and node configuration.
Before the volumes can be mounted, you must configure the cluster and
node separately after you have made the file system and saved the changes.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="checkopengfsfsim"
></A
>J.2. Checking OpenGFS file systems</H1
><P
>&#13;The OpenGFS utility for checking the file system has no additional options.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="removeopengfsfsim"
></A
>J.3. Removing OpenGFS file systems</H1
><P
>&#13;An OpenGFS file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume,
erasing the log headers for the journal volumes, and erasing the control
block on the cluster configuration volume associated with the file
system volume so that the file system will not be recognized in the future.
There are no options available for removing file systems.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="expandshrinkopengfsfsim"
></A
>J.4. Expanding and shrinking OpenGFS
file systems</H1
><P
>&#13;OpenGFS only allows a volume to be expanded.  
OpenGFS only allows a volume to expanded when the volume is mounted.
An OpenGFS file system is automatically expanded when its volume is
expanded.
</P
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="ntfsfsim"
></A
>Appendix K. NTFS file system interface module</H1
><P
>&#13;The NTFS FSIM lets EVMS users create and manage Windows® NT®
file systems from within the EVMS interfaces.  
</P
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="createntfsfsim"
></A
>K.1. Creating NTFS file systems</H1
><P
>&#13;NTFS file systems can be created with <B
CLASS="command"
>mkfs</B
> on any EVMS
or compatibility volume that is at least 1 MB in size and that does not already
have a file system.
The following options are available for creating
NTFS file systems:</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>label</DT
><DD
><P
>&#13;Specify a volume label for the file system.  The default is none.
</P
></DD
><DT
>cluster-size</DT
><DD
><P
>Specify the size of clusters in bytes.  Valid cluster size values
are powers of two, with at least 256, and at most 65536 bytes per cluster.
If omitted, mkntfs cluster-size is determined by the volume size.  The
value is determined as follows:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;Volume size	Default cluster

0-512 MB	512 bytes
512 MB-1 GB	1024 bytes
1 GB-2 GB	2048 bytes
2 GB+		4096 bytes
</PRE
></FONT
></TD
></TR
></TABLE
></DD
><DT
>mft-zone-mult</DT
><DD
><P
>Set the MFT zone multiplier, which determines the size of the
MFT zone to use on the volume.  The MFT zone is the area at the
beginning of the volume reserved for the master file table (MFT),
which stores the on disk inodes (MFT records).  Note that small files
are stored entirely within the node.  Thus, if you expect to use the
volume for storing large numbers of very small files, it is useful
to set the zone multiplier to a higher value.  Note that the MFT zone
is resized on the fly as required during operation of the NTFS driver,
but choosing a good value will reduce fragmentation.  Valid
values are 12.5 (the default), 25, 37.5, and 50.
</P
></DD
><DT
>compress</DT
><DD
><P
>Enable compression on the volume.
</P
></DD
><DT
>quick</DT
><DD
><P
>Perform quick format.  This skips both zeroing of the volume
and bad sector checking.
</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="fixntfsfsim"
></A
>K.2. Fixing NTFS file systems</H1
><P
>&#13;The NTFS FSIM can run the <B
CLASS="command"
>ntfsfix</B
> utility on an
NTFS file system.
</P
><P
>&#13;<B
CLASS="command"
>ntfsfix</B
> fixes NTFS partitions altered in any manner
with the Linux NTFS driver.  <B
CLASS="command"
>ntfsfix</B
> is not a Linux
version of <B
CLASS="command"
>chkdsk</B
>.  <B
CLASS="command"
>ntfsfix</B
>  
only tries to leave the NTFS
partition in a not-so-inconsistent state after the NTFS driver has written
to it.
</P
><P
>&#13;Running <B
CLASS="command"
>ntfsfix</B
> after mounting an NTFS volume
read-write is recommended for reducing the chance of severe data loss
when Windows NT or Windows 2000 tries to remount the affected volume.
</P
><P
>&#13;In order to use <B
CLASS="command"
>ntfsfix</B
>, you must unmount the
NTFS volume.  After running <B
CLASS="command"
>ntfsfix</B
>, you can safely
reboot into Windows NT or Windows 2000.  Please note that
<B
CLASS="command"
>ntfsfix</B
> is not an <B
CLASS="command"
>fsck</B
>-like tool. 
<B
CLASS="command"
>ntfsfix</B
> is not guaranteed to fix all the
alterations provoked by the NTFS driver.
</P
><P
>&#13;The following option is available for running <B
CLASS="command"
>ntfsfix</B
>
on an NTFS file system:
</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>force</DT
><DD
><P
>&#13;Force <B
CLASS="command"
>ntfsfix</B
> to write changes even if it
detects that the file system is dirty.  The default is false.
</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="clonentfsfsim"
></A
>K.3. Cloning NTFS file systems</H1
><P
>&#13;The NTFS FSIM can run the <B
CLASS="command"
>ntfsclone</B
> utility to
copy an NTFS file system from one volume to another.
<B
CLASS="command"
>ntfsclone</B
> is faster than <B
CLASS="command"
>dd</B
>
because it only copies the files and the file system data instead
of the entire contents of the volume.
</P
><P
>&#13;The following options are available for running <B
CLASS="command"
>ntfsclone</B
>
on an NTFS file system:
</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>target</DT
><DD
><P
>The volume onto which the file system should be cloned.
</P
></DD
><DT
>force</DT
><DD
><P
>&#13;Force <B
CLASS="command"
>ntfsclone</B
> to copy the file system
even if it detects that the volume is dirty.  The default is false.
</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="removentfsfsim"
></A
>K.4. Removing NTFS file systems</H1
><P
>&#13;An NTFS file system can be removed from its volume if the file system
is unmounted.
This operation involves erasing the superblock from the volume so
the file system will not be recognized in the future.
There are no options available for removing file systems.
</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="expandshrinkntfsfsim"
></A
>K.5. Expanding and shrinking NTFS
file systems</H1
><P
>&#13;An NTFS file system is automatically expanded or shrunk when its volume
is expanded for shrunk.  However, NTFS only allows these operations if the
volume is unmounted.
</P
></DIV
></DIV
></DIV
></BODY
>
<!-- Mirrored from tldp.org/LDP/EVMSUG/html/EVMSUG.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 23 Oct 2018 23:53:37 GMT -->
</HTML
>