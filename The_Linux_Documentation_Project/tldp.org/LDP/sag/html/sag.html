<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
>
<!-- Mirrored from tldp.org/LDP/sag/html/sag.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 23 Oct 2018 23:50:34 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=ISO-8859-1" /><!-- /Added by HTTrack -->
<HEAD
><TITLE
>The Linux System Administrator's Guide</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><META
NAME="KEYWORD"
CONTENT="Linux Documentation"><META
NAME="KEYWORD"
CONTENT="GFDL"><META
NAME="KEYWORD"
CONTENT="Linux Documentation Project"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="INDEX"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN3"
></A
>The Linux System Administrator's Guide</H1
><H2
CLASS="SUBTITLE"
>Version 0.9</H2
><H3
CLASS="AUTHOR"
><A
NAME="AEN11"
></A
>Lars Wirzenius</H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:Email address removed by request"
>Email address removed by request</A
>&#62;</TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><H3
CLASS="AUTHOR"
><A
NAME="AEN17"
></A
>Joanna Oja</H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:Current email address unknown"
>Current email address unknown</A
>&#62;</TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><H3
CLASS="AUTHOR"
><A
NAME="AEN23"
></A
>Stephen Stafford</H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:stephen@clothcat.demon.co.uk.NOSPAM"
>stephen@clothcat.demon.co.uk.NOSPAM</A
>&#62;</TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><H3
CLASS="AUTHOR"
><A
NAME="AEN29"
></A
>Alex Weeks</H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:draxeman@gmail.com.NOSPAM"
>draxeman@gmail.com.NOSPAM</A
>&#62;</TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><DIV
><DIV
CLASS="ABSTRACT"
><A
NAME="AEN35"
></A
><P
></P
><P
>An introduction to system administration of a
Linux system for novices.</P
><P
></P
></DIV
></DIV
><DIV
CLASS="LEGALNOTICE"
><A
NAME="LEGAL-NOTICE"
></A
><P
></P
><P
>Copyright 1993--1998 Lars Wirzenius.</P
><P
>Copyright 1998--2001 Joanna Oja.</P
><P
>Copyright 2001--2003 Stephen Stafford.</P
><P
>Copyright 2003--2004 Stephen Stafford &#38; Alex Weeks.</P
><P
>Copyright 2004--Present Alex Weeks.</P
><P
>Trademarks are owned by their owners.</P
><P
>Permission is granted to copy, distribute and/or modify this
        document under the terms of the GNU Free Documentation License,
        Version 1.2 or any later version published by the Free Software
        Foundation; with no Invariant Sections, no Front-Cover Texts, and no
        Back-Cover Texts. A copy of the license is included in the section
        entitled "GNU Free Documentation License".</P
><P
></P
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#PREFACE"
>About This Book</A
></DT
><DD
><DL
><DT
>1. <A
HREF="#ACKNOWLEDGEMENTS"
>Acknowledgments</A
></DT
><DT
>2. <A
HREF="#REVISION-HIST"
>Revision History</A
></DT
><DT
>3. <A
HREF="#AVAILABLE-VERSIONS"
>Source and pre-formatted versions available</A
></DT
><DT
>4. <A
HREF="#TYPO-CONVENTIONS"
>Typographical Conventions</A
></DT
></DL
></DD
><DT
>1. <A
HREF="#INTRO"
>Introduction</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#GNU-OR-NOT"
>Linux or GNU/Linux, that is the question.</A
></DT
><DT
>1.2. <A
HREF="#AEN186"
>Trademarks</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#OVERVIEW"
>Overview of a Linux System</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#VARIOUS-PARTS"
>Various parts of an operating system</A
></DT
><DT
>2.2. <A
HREF="#KERNEL-PARTS"
>Important parts of the kernel</A
></DT
><DT
>2.3. <A
HREF="#MAJOR-SERVICES"
>Major services in a UNIX system</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#DIR-TREE-OVERVIEW"
>Overview of the Directory Tree</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#FS-BACKGROUND"
>Background</A
></DT
><DT
>3.2. <A
HREF="#ROOT-FS"
>The root filesystem</A
></DT
><DT
>3.3. <A
HREF="#ETC-FS"
>The <TT
CLASS="FILENAME"
>/etc</TT
> directory</A
></DT
><DT
>3.4. <A
HREF="#DEV-FS"
>The <TT
CLASS="FILENAME"
>/dev</TT
> directory</A
></DT
><DT
>3.5. <A
HREF="#USR-FS"
>The <TT
CLASS="FILENAME"
>/usr</TT
> filesystem.</A
></DT
><DT
>3.6. <A
HREF="#VAR-FS"
>The <TT
CLASS="FILENAME"
>/var</TT
> filesystem</A
></DT
><DT
>3.7. <A
HREF="#PROC-FS"
>The <TT
CLASS="FILENAME"
>/proc</TT
> filesystem</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#DEVICE-LIST"
>Hardware, Devices, and Tools</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#HWUTILS"
>Hardware Utilities</A
></DT
><DT
>4.2. <A
HREF="#AEN1926"
>Kernel Modules</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#DISK-USAGE"
>Using Disks and Other Storage Media</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#BLOCK-CHAR-DEV"
>Two kinds of devices</A
></DT
><DT
>5.2. <A
HREF="#HARD-DISK"
>Hard disks</A
></DT
><DT
>5.3. <A
HREF="#SAN"
>Storage Area Networks - Draft</A
></DT
><DT
>5.4. <A
HREF="#NET-ATTACHED"
>Network Attached Storage - Draft</A
></DT
><DT
>5.5. <A
HREF="#FLOPPIES"
>Floppies</A
></DT
><DT
>5.6. <A
HREF="#CDROM"
>CD-ROMs</A
></DT
><DT
>5.7. <A
HREF="#TAPES"
>Tapes</A
></DT
><DT
>5.8. <A
HREF="#FORMATTING"
>Formatting</A
></DT
><DT
>5.9. <A
HREF="#PARTITIONS"
>Partitions</A
></DT
><DT
>5.10. <A
HREF="#FILESYSTEMS"
>Filesystems</A
></DT
><DT
>5.11. <A
HREF="#DISK-NO-FS"
>Disks without filesystems</A
></DT
><DT
>5.12. <A
HREF="#ALLOC-DISK"
>Allocating disk space</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#MEMORY-MANAGEMENT"
>Memory Management</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#VM-INTRO"
>What is virtual memory?</A
></DT
><DT
>6.2. <A
HREF="#SWAP-SPACE"
>Creating a swap space</A
></DT
><DT
>6.3. <A
HREF="#USING-SWAP"
>Using a swap space</A
></DT
><DT
>6.4. <A
HREF="#SHARING-SWAP"
>Sharing swap spaces with other operating systems</A
></DT
><DT
>6.5. <A
HREF="#SWAP-ALLOCATION"
>Allocating swap space</A
></DT
><DT
>6.6. <A
HREF="#BUFFER-CACHE"
>The buffer cache</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#SYSTEM-MONITORING"
>System Monitoring</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#SYSTEM-RESOURCES"
>System Resources</A
></DT
><DT
>7.2. <A
HREF="#FS-USAGE"
>Filesystem Usage</A
></DT
><DT
>7.3. <A
HREF="#MONITORING-USERS"
>Monitoring Users</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#BOOTS-AND-SHUTDOWNS"
>Boots And Shutdowns</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#BOOT-OVERVIEW"
>An overview of boots and shutdowns</A
></DT
><DT
>8.2. <A
HREF="#BOOT-PROCESS"
>The boot process in closer look</A
></DT
><DT
>8.3. <A
HREF="#SHUTDOWN"
>More about shutdowns</A
></DT
><DT
>8.4. <A
HREF="#REBOOTING"
>Rebooting</A
></DT
><DT
>8.5. <A
HREF="#SINGLE-USER"
>Single user mode</A
></DT
><DT
>8.6. <A
HREF="#EMERG-BOOT-FLOPPY"
>Emergency boot floppies</A
></DT
></DL
></DD
><DT
>9. <A
HREF="#INIT-INTRO"
><B
CLASS="COMMAND"
>init</B
></A
></DT
><DD
><DL
><DT
>9.1. <A
HREF="#INIT-PROCESS"
><B
CLASS="COMMAND"
>init</B
> comes first</A
></DT
><DT
>9.2. <A
HREF="#CONFIG-INIT"
>Configuring <B
CLASS="COMMAND"
>init</B
> to start 
<B
CLASS="COMMAND"
>getty</B
>: the 
<TT
CLASS="FILENAME"
>/etc/inittab</TT
> file</A
></DT
><DT
>9.3. <A
HREF="#RUN-LEVELS-INTRO"
>Run levels</A
></DT
><DT
>9.4. <A
HREF="#INITTAB"
>Special configuration in 
<TT
CLASS="FILENAME"
>/etc/inittab</TT
></A
></DT
><DT
>9.5. <A
HREF="#BOOT-SINGLE-USER"
>Booting in single user mode</A
></DT
></DL
></DD
><DT
>10. <A
HREF="#LOG-IN-AND-OUT"
>Logging In And Out</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#LOGIN-VIA-TERMINAL"
>Logins via terminals</A
></DT
><DT
>10.2. <A
HREF="#LOGIN-VIA-NETWORK"
>Logins via the network</A
></DT
><DT
>10.3. <A
HREF="#WHAT-LOGIN-DOES"
>What <B
CLASS="COMMAND"
>login</B
> does</A
></DT
><DT
>10.4. <A
HREF="#X-XDM"
>X and xdm</A
></DT
><DT
>10.5. <A
HREF="#ACCESS-CONTROL"
>Access control</A
></DT
><DT
>10.6. <A
HREF="#SHELL-STARTUP"
>Shell startup</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#MANAGING-USERS"
>Managing user accounts</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#ACCOUNT"
>What's an account?</A
></DT
><DT
>11.2. <A
HREF="#ADDUSER"
>Creating a user</A
></DT
><DT
>11.3. <A
HREF="#USER-PROPERTIES"
>Changing user properties</A
></DT
><DT
>11.4. <A
HREF="#DELUSER"
>Removing a user</A
></DT
><DT
>11.5. <A
HREF="#DISABLE-USER"
>Disabling a user temporarily</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#BACKUPS-INTRO"
>Backups</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="#BACKUPS"
>On the importance of being backed up</A
></DT
><DT
>12.2. <A
HREF="#BACKUP-MEDIA"
>Selecting the backup medium</A
></DT
><DT
>12.3. <A
HREF="#BACKUP-TOOLS"
>Selecting the backup tool</A
></DT
><DT
>12.4. <A
HREF="#SIMPLE-BACKUPS"
>Simple backups</A
></DT
><DT
>12.5. <A
HREF="#MULTI-LEVEL-BACKUPS"
>Multilevel backups</A
></DT
><DT
>12.6. <A
HREF="#WHAT-TO-BACKUP"
>What to back up</A
></DT
><DT
>12.7. <A
HREF="#COMPRESSED-BACKUPS"
>Compressed backups</A
></DT
></DL
></DD
><DT
>13. <A
HREF="#TASK-AUTOMATION"
>Task Automation --To Be Added</A
></DT
><DT
>14. <A
HREF="#KEEPING-TIME"
>Keeping Time</A
></DT
><DD
><DL
><DT
>14.1. <A
HREF="#LOCALTIME"
>The concept of localtime</A
></DT
><DT
>14.2. <A
HREF="#HW-SW-CLOCKS"
>The hardware and software clocks</A
></DT
><DT
>14.3. <A
HREF="#SHOWING-SETTING-TIME"
>Showing and setting time</A
></DT
><DT
>14.4. <A
HREF="#CLOCK-WRONG"
>When the clock is wrong</A
></DT
><DT
>14.5. <A
HREF="#NTP"
>NTP - Network Time Protocol</A
></DT
><DT
>14.6. <A
HREF="#BASIC-NTP-CONFIG"
>Basic NTP configuration</A
></DT
><DT
>14.7. <A
HREF="#NTP-TOOLKIT"
>NTP Toolkit</A
></DT
><DT
>14.8. <A
HREF="#NTP-SERVERS"
>Some known NTP servers</A
></DT
><DT
>14.9. <A
HREF="#NTP-LINKS"
>NTP Links</A
></DT
></DL
></DD
><DT
>15. <A
HREF="#SYSTEM-LOGS"
>System Logs --To Be Added</A
></DT
><DT
>16. <A
HREF="#SYSTEM-UPDATES"
>System Updates --To Be Added</A
></DT
><DT
>17. <A
HREF="#KERNEL"
>The Linux Kernel Source</A
></DT
><DT
>18. <A
HREF="#FINDING-HELP"
>Finding Help</A
></DT
><DD
><DL
><DT
>18.1. <A
HREF="#NEWSGROUPS-MAILLING-LISTS"
>Newsgroups and Mailing Lists</A
></DT
><DT
>18.2. <A
HREF="#IRC"
>IRC</A
></DT
></DL
></DD
><DT
>A. <A
HREF="#GFDL1.2"
>GNU Free Documentation License</A
></DT
><DD
><DL
><DT
>A.1. <A
HREF="#GFDL-0"
>PREAMBLE</A
></DT
><DT
>A.2. <A
HREF="#GFDL-1"
>APPLICABILITY AND DEFINITIONS</A
></DT
><DT
>A.3. <A
HREF="#GFDL-2"
>VERBATIM COPYING</A
></DT
><DT
>A.4. <A
HREF="#GFDL-3"
>COPYING IN QUANTITY</A
></DT
><DT
>A.5. <A
HREF="#GFDL-4"
>MODIFICATIONS</A
></DT
><DT
>A.6. <A
HREF="#GFDL-5"
>COMBINING DOCUMENTS</A
></DT
><DT
>A.7. <A
HREF="#GFDL-6"
>COLLECTIONS OF DOCUMENTS</A
></DT
><DT
>A.8. <A
HREF="#GFDL-7"
>AGGREGATION WITH INDEPENDENT WORKS</A
></DT
><DT
>A.9. <A
HREF="#GFDL-8"
>TRANSLATION</A
></DT
><DT
>A.10. <A
HREF="#GFDL-9"
>TERMINATION</A
></DT
><DT
>A.11. <A
HREF="#GFDL-10"
>FUTURE REVISIONS OF THIS LICENSE</A
></DT
><DT
>A.12. <A
HREF="#GFDL-ADDENDUM"
>ADDENDUM: How to use this License for
  your documents</A
></DT
></DL
></DD
><DT
><A
HREF="#GLOSSARY"
>Glossary (DRAFT, but not for long hopefully)</A
></DT
><DT
><A
HREF="#BOOKINDEX"
>Index-Draft</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Tables</B
></DT
><DT
>5-1. <A
HREF="#AEN2790"
>Comparing Filesystem Features</A
></DT
><DT
>5-2. <A
HREF="#AEN2949"
>Sizes</A
></DT
><DT
>5-3. <A
HREF="#AEN3270"
>My Partitions</A
></DT
><DT
>9-1. <A
HREF="#RUN-LEVELS-TABLE"
>Run level numbers</A
></DT
><DT
>12-1. <A
HREF="#EFFICIENT-BACKUP-LEVELS"
>Efficient backup scheme using many backup levels</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Figures</B
></DT
><DT
>2-1. <A
HREF="#KERNELOVERVIEW"
>Some of the more important parts of the Linux kernel</A
></DT
><DT
>3-1. <A
HREF="#FSTREE"
>Parts of a Unix
		directory tree. Dashed lines indicate partition 
		limits.</A
></DT
><DT
>5-1. <A
HREF="#HD-SCHEMATIC"
>A schematic picture of a hard disk.</A
></DT
><DT
>5-2. <A
HREF="#HARD-DISK-LAYOUT"
>A sample hard disk partitioning.</A
></DT
><DT
>5-3. <A
HREF="#HD-MOUNT-ROOT"
>Three separate filesystems.</A
></DT
><DT
>5-4. <A
HREF="#HD-MOUNT-ALL"
><TT
CLASS="FILENAME"
>/home</TT
> and <TT
CLASS="FILENAME"
>/usr</TT
> 
		have been 
		mounted.</A
></DT
><DT
>10-1. <A
HREF="#TERMINAL-LOGINS-TABLE"
>Logins via terminals: the interaction of 
<B
CLASS="COMMAND"
>init</B
>, 
<B
CLASS="COMMAND"
>getty</B
>, <B
CLASS="COMMAND"
>login</B
>, and the 
shell.</A
></DT
><DT
>12-1. <A
HREF="#BACKUP-HISTORY-TIMELINE"
>A sample multilevel backup schedule.</A
></DT
></DL
></DIV
><DIV
CLASS="PREFACE"
><HR><H1
><A
NAME="PREFACE"
></A
>About This Book</H1
><A
NAME="AEN47"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"Only two things are infinite, the universe 
	and human stupidity, and I'm not sure about the former."</SPAN
>
	Albert Einstein</P
></BLOCKQUOTE
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="ACKNOWLEDGEMENTS"
></A
>1. Acknowledgments</H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ACKNOWLEDGEMENTS-JOANNA"
></A
>1.1. Joanna's acknowledgments</H2
><P
>Many people have helped me with this book, directly or
	indirectly.  I would like to especially thank Matt Welsh for
	inspiration and LDP leadership, Andy Oram for getting me to work
	again with much-valued feedback, Olaf Kirch for showing me that it
	can be done, and Adam Richter at Yggdrasil and others for showing
	me that other people can find it interesting as well.</P
><P
>Stephen Tweedie, H. Peter Anvin, Remy Card, Theodore
	Ts'o, and Stephen Tweedie have let me borrow their work (and
	thus make the book look thicker and much more impressive):
	a comparison between the xia and ext2 filesystems, the device
	list and a description of the ext2 filesystem. These aren't
	part of the book any more.  I am most grateful for this, and
	very apologetic for the earlier versions that sometimes lacked
	proper attribution.</P
><P
>In addition, I would like to thank Mark Komarinski for
	sending his material in 1993 and the many system administration
	columns in Linux Journal.  They are quite informative and
	inspirational.</P
><P
>Many useful comments have been sent by a large number
	of people.  My miniature black hole of an archive doesn't let
	me find all their names, but some of them are, in alphabetical
	order: Paul Caprioli, Ales Cepek, Marie-France Declerfayt,
	Dave Dobson, Olaf Flebbe, Helmut Geyer, Larry Greenfield and
	his father, Stephen Harris, Jyrki Havia, Jim Haynes, York Lam,
	Timothy Andrew Lister, Jim Lynch, Michael J. Micek, Jacob Navia,
	Dan Poirier, Daniel Quinlan, Jouni K Seppänen, Philippe Steindl,
	G.B. Stotte.  My apologies to anyone I have forgotten.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="ACKNOWLEDGEMENTS-STEPHEN"
></A
>1.2. Stephen's acknowledgments</H2
><P
>I would like to thank Lars and Joanna for their hard 
	work on the guide.</P
><P
>In a guide like this one there are likely to be at least 
	some minor inaccuracies.  And there are almost certainly going to 
	be sections that become out of date from time to time.  If you 
	notice any of this then please let me know by sending me an email 
	to: <TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:bagpuss@debian.org.NOSPAM"
>bagpuss@debian.org.NOSPAM</A
>&#62;</TT
>.	I will take virtually
	any form of input (diffs, just plain text, html, whatever), I am 
	in no way above allowing others to help	me maintain such a large 
	text as this :) </P
><P
>Many thanks to Helen Topping Shaw for getting the red pen out 
	and making the text far better than it would otherwise have been.  
	Also thanks are due just for being wonderful.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="ACKNOWLEDGEMENTS-ALEX"
></A
>1.3. Alex's Acknowledgments</H2
><P
>I would like to thank Lars, Joanna, and Stephen for all the 
	great work that they have done on this document over the years.  I
	only hope that my contribution will be worthy of continuing the work
	they started.</P
><P
>Like the previous maintainers, I openly welcome any comments,
	suggestions, complains, corrections, or any other form of feedback
	you may have.  This document can only benefit from the suggestions 
	of those who use it.</P
><P
>There have been many people who have helped me on my journey
	through the "Windows-Free" world, the person I feel I need to thank the
	most is my first true UN*X mentor, Mike Velasco.  Back in a time before
	SCO became a "dirty word", Mike helped me on the path of tar's, cpio's,
	and many, many man pages.  Thanks Mike! You are the 'Sofa King'.</P
><P
></P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="REVISION-HIST"
></A
>2. Revision History</H1
><P
>	<DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.7</TD
><TD
ALIGN="LEFT"
>2001-12-03</TD
><TD
ALIGN="LEFT"
>Revised by: SS</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.8</TD
><TD
ALIGN="LEFT"
>2003-11-18</TD
><TD
ALIGN="LEFT"
>Revised by: AW</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
><DIV
CLASS="REVDESCRIPTION"
><A
NAME="AEN82"
></A
><P
></P
><OL
COMPACT="COMPACT"
TYPE="1"
><LI
><SPAN
>Added a section on NTP
				</SPAN
></LI
><LI
><SPAN
>Cleaned some SGML 
				</SPAN
></LI
><LI
><SPAN
>Added ext3 to the filesystem 
					section
				</SPAN
></LI
></OL
></DIV
></TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.9</TD
><TD
ALIGN="LEFT"
></TD
><TD
ALIGN="LEFT"
>Revised by: AW</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
><DIV
CLASS="REVDESCRIPTION"
><A
NAME="AEN94"
></A
><P
></P
><OL
COMPACT="COMPACT"
TYPE="1"
><LI
><SPAN
>Cleaned some SGML code, changed 
					doctype to lds.dsl, and added id tags 
				</SPAN
></LI
><LI
><SPAN
>Updated section on filesystem types, 
					and Filesystem comparison 
				</SPAN
></LI
><LI
><SPAN
>Updated partition type section
				</SPAN
></LI
><LI
><SPAN
>Updated section on creating 
					partitions 
				</SPAN
></LI
><LI
><SPAN
>Wrote section on Logical Volume 
					Manager (LVM)
				</SPAN
></LI
><LI
><SPAN
>Updated section on space allocation
				</SPAN
></LI
><LI
><SPAN
>Added chapter on System Monitoring
				</SPAN
></LI
><LI
><SPAN
>Added more command line utilities
				</SPAN
></LI
><LI
><SPAN
>Verified Device list
				</SPAN
></LI
><LI
><SPAN
>Modified email address for Authors
			 	</SPAN
></LI
><LI
><SPAN
>Added references to more in-depth 
					documents where applicable
			 	</SPAN
></LI
><LI
><SPAN
>Added notes on upcoming sections
			 	</SPAN
></LI
><LI
><SPAN
>Indexed chapters 1 - 4, &#38; part of 5
			 	</SPAN
></LI
><LI
><SPAN
>Updated Misc Information throughout 
					the book
				</SPAN
></LI
></OL
></DIV
></TD
></TR
></TABLE
></DIV
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AVAILABLE-VERSIONS"
></A
>3. Source and pre-formatted versions available</H1
><P
>The source code and other machine readable formats
	of this book can be found on the Internet via anonymous FTP at the
	Linux Documentation Project home page <A
HREF="../../../index.html"
TARGET="_top"
>http://www.tldp.org/</A
>, or
	at the home page of this book at 
	<A
HREF="http://www.draxeman.com/sag.html"
TARGET="_top"
>	http://www.draxeman/sag.html</A
>. This book is available in at 
	least it's SGML source, as well as, HTML and PDF formats.  Other
	formats may be available.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="TYPO-CONVENTIONS"
></A
>4. Typographical Conventions</H1
><P
>Throughout this book, I have tried to use uniform
	typographical conventions.  Hopefully they aid readability.  If
	you can suggest any improvements please contact me.</P
><P
>Filenames are expressed as:
	<TT
CLASS="FILENAME"
>/usr/share/doc/foo</TT
>.</P
><P
>Command names are expressed as: <B
CLASS="COMMAND"
>fsck</B
>

	</P
><P
>Email addresses are expressed as:
	<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:user@domain.com"
>user@domain.com</A
>&#62;</TT
></P
><P
>URLs are expressed as: <A
HREF="../../../index.html"
TARGET="_top"
>http://www.tldp.org</A
>
	</P
><P
>I will add to this section as things come up whilst
	editing.  If you notice anything that should be added then
	please let me know.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="INTRO"
></A
>Chapter 1. Introduction</H1
><A
NAME="AEN143"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"In the beginning, the file was without
	form, and void; and emptiness was upon the face of the bits.
	And the Fingers of the Author moved upon the face of the
	keyboard.  And the Author said, Let there be words, and there
	were words."</SPAN
></P
></BLOCKQUOTE
><P
>The Linux System Administrator's Guide,
	describes the system administration aspects of using Linux.
	It is intended for people who know next to nothing about system
	administration (those saying ``what is it?''), but who have already
	mastered at least the basics of normal usage.  This manual
	doesn't tell you how to install Linux; that is described in the
	Installation and Getting Started document. See below for more
	information about Linux manuals.</P
><P
>System administration covers all the things that you have to
	do to keep a computer system in usable order.  It includes
	things like backing up files (and restoring them if necessary),
	installing new programs, creating accounts for users (and deleting
	them when no longer needed), making certain that the filesystem
	is not corrupted, and so on.  If a computer were, say, a house,
	system administration would be called maintenance, and would
	include cleaning, fixing broken windows, and other such things.
	</P
><P
>The structure of this manual is such that many of the
	chapters should be usable independently, so if you need information
	about backups, for example, you can read just that chapter. However,
	this manual is	first and foremost a tutorial and can be read
	sequentially or as a whole.</P
><P
>This manual is not intended to be used completely 
	independently. Plenty of the rest of the Linux documentation is also
	important for system administrators.  After all, a system
	administrator is just a user with special privileges and duties.
	Very useful resources are the manual pages, which should always be
	consulted when you are not familiar with a command.  If you do not
	know which command you need, then the <B
CLASS="COMMAND"
>apropos</B
>
	command can be used.  Consult its manual page for more details.</P
><P
>While this manual is targeted at Linux, a general principle
	has been that it should be useful with other UNIX based operating
	systems as well.  Unfortunately, since there is so much variance
	between different versions of UNIX in general, and in system
	administration in particular, there is little hope to cover
	all variants.  Even covering all possibilities for Linux is
	difficult, due to the nature of its development.</P
><P
>There is no one official Linux distribution, so different
	people have different setups and many people have a setup they
	have built up themselves.  This book is not targeted at any
	one distribution.  Distributions can and do vary considerably.
	When possible, differences have been noted and alternatives
	given.  For a list of distributions 
	and some of their differences see
	<A
HREF="http://en.wikipedia.org/wiki/Comparison_of_Linux_distributions"
TARGET="_top"
>	http://en.wikipedia.org/wiki/Comparison_of_Linux_distributions</A
>.
	</P
><P
>In trying to describe how things work, rather than just
	listing ``five easy steps'' for each task, there is much information
	here that is not necessary for everyone, but those parts are marked
	as such and can be skipped if you use a preconfigured system.
	Reading everything will, naturally, increase your understanding of
	the system and should make using and administering it more
	productive.</P
><P
>Understanding is the key to success with Linux.  This book 
	could just provide recipes, but what would you do when confronted by 
	a problem this book had no recipe for?  If the book can provide
	understanding, then recipes are not required. The answers will be self 
	evident.</P
><P
>Like all other Linux related development, the work 
	to write this manual was done on a volunteer basis: I did it because
	I thought it might be fun and because I felt it should be done.
	However, like all volunteer work, there is a limit to how much time,
	knowledge and experience people have.  This means that the manual is
	not necessarily as good as it would be if a wizard had been paid
	handsomely to write it
	and had spent millennia to perfect it.  Be warned.</P
><P
>One particular point where corners have been cut is that 
	many things that are already well documented in other freely
	available manuals are not always covered here.  This applies
	especially to program specific documentation, such as all the
	details of using <B
CLASS="COMMAND"
>mkfs</B
>.  Only the purpose of the
	program and as much of its usage as is necessary for the purposes of
	this manual is described.  For further information, consult these
	other manuals.  Usually, all of the referred to documentation is
	part of the full Linux
	documentation set.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GNU-OR-NOT"
></A
>1.1. Linux or GNU/Linux, that is the question.</H1
><P
>Many people feel that Linux should really be called GNU/Linux.  
	
	This is because Linux is only the kernel, not the applications that run 
	on it.  Most of the basic command line utilities were written by the
	Free Software Foundation while developing their GNU operating system.  
	Among those utilities are some of the most basic commands like cp, mv
	lsof, and dd.</P
><P
>In a nutshell, what happened was, the FSF started developing GNU
	by writing things like compliers, C libraries, and basic command line
	utilities before the kernel.  Linus Torvalds, started Linux by writing 
	the Linux kernel first and using applications written for GNU.</P
><P
>I do not feel that this is the proper forum to debate what name
	people should use when referring to Linux.  I mention it here, because 
	I feel it is important to understand the relationship between GNU and
	Linux, and to also explain why some Linux is sometimes referred to as
	GNU/Linux.  The document will be simply referring to it as Linux.
	</P
><P
>GNU's side of the issue is discussed on their website:</P
><P
>The relationship - 
	<A
HREF="http://www.gnu.org/gnu/linux-and-gnu.html"
TARGET="_top"
>	http://www.gnu.org/gnu/linux-and-gnu.html</A
></P
><P
>Why Linux should be GNU/Linux - <A
HREF="http://www.gnu.org/gnu/why-gnu-linux.html"
TARGET="_top"
>	http://www.gnu.org/gnu/why-gnu-linux.html</A
></P
><P
>GNU/Linux FAQ's - <A
HREF="http://www.gnu.org/gnu/gnu-linux-faq.html"
TARGET="_top"
>	http://www.gnu.org/gnu/gnu-linux-faq.html</A
></P
><P
>Here are some Alternate views:</P
><P
><A
HREF="http://librenix.com/?inode=2312"
TARGET="_top"
>	http://librenix.com/?inode=2312</A
></P
><P
><A
HREF="http://www.topology.org/linux/lingl.html"
TARGET="_top"
>	http://www.topology.org/linux/lingl.html</A
></P
><P
><A
HREF="http://atulchitnis.net/writings/gnulinux.php"
TARGET="_top"
>	http://atulchitnis.net/writings/gnulinux.php</A
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN186"
></A
>1.2. Trademarks</H1
><P
>Microsoft, Windows, Windows NT, Windows 2000, and Windows XP
	 are trademarks and/or registered trademarks of Microsoft Corporation.
	</P
><P
>Red Hat is a trademark of Red Hat, Inc., in the United States 
	and other countries.</P
><P
>SuSE is a trademark of Novell.</P
><P
>Linux is a registered trademark of Linus Torvalds.</P
><P
>UNIX is a registered trademark in the United States and other 
	countries, licensed exclusively through X/Open Company Ltd.</P
><P
>GNU is a registered trademark of the Free Software Foundation.
	</P
><P
>Other product names mentioned herein may be trademarks and/or 
	registered trademarks of their respective companies. </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="OVERVIEW"
></A
>Chapter 2. Overview of a Linux System</H1
><A
NAME="AEN197"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"God saw everything that he
	had made, and saw that it was very good. "</SPAN
> --  Bible
	King James Version.  Genesis 1:31</P
></BLOCKQUOTE
><P
>This chapter gives an overview of a Linux system.  First,
	the major services provided by the operating system are described.
	Then, the programs that implement these services are described
	with a considerable lack of detail.  The purpose of this chapter
	is to give an understanding of the system as a whole, so that
	each part is described in detail elsewhere.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="VARIOUS-PARTS"
></A
>2.1. Various parts of an operating system</H1
><P
>UNIX and  'UNIX-like' operating systems (such as Linux) consist
	of a <I
CLASS="GLOSSTERM"
>kernel</I
> and some
	<I
CLASS="GLOSSTERM"
>system programs</I
>.  There are also some
	<I
CLASS="GLOSSTERM"
>application programs</I
> for doing work.
	The kernel is the heart of the operating 
	system.  In fact, it is often mistakenly considered to be the 
	operating system itself, but it is not.  An operating system provides 
	provides many more services than a plain kernel.</P
><P
>It keeps track of files on the disk, starts programs and runs 
	them concurrently, assigns memory and other resources to various
	processes, receives packets from and sends packets to the network,
	and so on.  The kernel does very little by itself, but it provides
	tools with which all services can be built.  It also prevents anyone
	from accessing the hardware directly, forcing everyone to use the
	tools it provides.
	This way the kernel provides some protection for users from each
	other.  The tools provided by the kernel are used via
	<I
CLASS="GLOSSTERM"
>system calls</I
><I
CLASS="GLOSSTERM"
>.  See manual page section 2 for more 
	information on these.  </I
></P
><P
>The system programs use the tools provided by the kernel to
	implement the various services required from an operating system.
	System programs, and all other programs, run `on top of the
	kernel', in what is called the <I
CLASS="GLOSSTERM"
>user mode</I
>.
	The difference between system and application programs is
	one of intent: applications are intended for getting useful
	things done (or for playing, if it happens to be a game),
	whereas system programs are needed to get the system working.
	A word processor is an application; <B
CLASS="COMMAND"
>mount</B
>
	is a system program.  The difference is often somewhat blurry,
	however, and is important only to compulsive categorizers.</P
><P
>An operating system can also contain compilers and their
	corresponding libraries (GCC and the C library in particular under
	Linux), although not all programming languages need be part of
	the operating system.  Documentation, and sometimes even games,
	can also be part of it.  Traditionally, the operating system has
	been defined by the contents of the installation tape or disks;
	with Linux it is not as clear since it is spread all over the
	FTP sites of the world.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="KERNEL-PARTS"
></A
>2.2. Important parts of the kernel</H1
><P
>The Linux kernel  consists of several important 
	parts: process
	management, memory management, hardware device drivers, filesystem
	drivers, network management, and various other bits and pieces.
	<A
HREF="#KERNELOVERVIEW"
>Figure 2-1</A
>
	shows some of them.</P
><DIV
CLASS="FIGURE"
><A
NAME="KERNELOVERVIEW"
></A
><P
><B
>Figure 2-1. Some of the more important parts of the Linux kernel</B
></P
><P
><IMG
SRC="overview-kernel.png"></P
></DIV
><P
>Probably the most important parts of the kernel (nothing else
	works without them) are memory management and 
	process management.  Memory management  takes care of assigning
	memory areas and swap space areas to processes, parts of the
	kernel, and for the buffer cache.  Process management 
	 creates
	processes, and implements multitasking by switching the
	active process on the processor.</P
><P
>At the lowest level, the kernel contains a hardware device
	driver for each kind of hardware 
	it supports.  Since the world is
	full of different kinds of hardware, the number of hardware device
	drivers is large.  There are often many otherwise similar pieces
	of hardware that differ in how they are controlled by software.
	The similarities make it possible to have general classes of
	drivers that support similar operations; each member of the class
	has the same interface to the rest of the kernel but differs in
	what it needs to do to implement them.	For example, all disk
	drivers look alike to the rest of the kernel, i.e., they all
	have operations like `initialize the drive', `read sector N',
	and `write sector N'.</P
><P
>Some software services provided by the kernel itself have
	similar properties, and can therefore be abstracted into classes.
	For example, the various network protocols have been abstracted
	into one programming interface, the BSD socket library.  Another
	example is the <I
CLASS="GLOSSTERM"
>virtual filesystem</I
> 
	 (VFS)
	layer that abstracts the filesystem operations away from their
	implementation.  Each filesystem type provides an implementation
	of each filesystem operation.  When some entity tries to use
	a filesystem, the request goes via the VFS, which routes the
	request to the proper filesystem driver.</P
><P
>A more in-depth discussion of kernel internals can be found 
	at <A
HREF="../../lki/index.html"
TARGET="_top"
>	http://www.tldp.org/LDP/lki/index.html</A
>.  This document was 
	written for the 2.4 kernel.  When I find one for the 2.6 kernel, I 
	will list it here.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="MAJOR-SERVICES"
></A
>2.3. Major services in a UNIX system</H1
><P
>This section describes some of the more important UNIX
	services, but without much detail.  They are described more
	thoroughly in later chapters.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="INIT"
></A
>2.3.1. <B
CLASS="COMMAND"
>init</B
></H2
><P
>The single most important service in a UNIX system is
	provided by <B
CLASS="COMMAND"
>init</B
>  <B
CLASS="COMMAND"
>init</B
>
	is started as the first process of every UNIX system, as the last
	thing the kernel does when it boots.  When <B
CLASS="COMMAND"
>init</B
>
	starts, it continues the boot process by doing various startup
	chores (checking and mounting filesystems, starting daemons,
	etc).</P
><P
>The exact list of things that <B
CLASS="COMMAND"
>init</B
>
	does depends on which flavor it is; there are several to choose
	from.  <B
CLASS="COMMAND"
>init</B
> usually provides the concept of
	<I
CLASS="GLOSSTERM"
>single user mode</I
>, in which no one can
	log in and root uses a shell at the console; the usual mode is
	called <I
CLASS="GLOSSTERM"
>multiuser mode</I
>.  Some flavors
	generalize this as <I
CLASS="GLOSSTERM"
>run levels</I
>; single
	and multiuser modes are considered to be two run levels, and
	there can be additional ones as well, for example, to run X on
	the console.</P
><P
>Linux allows for up to 10
	<I
CLASS="GLOSSTERM"
>runlevels</I
>, 0-9, but usually only some of
	these are defined by default.  Runlevel 0 is defined as ``system
	halt''.  Runlevel 1 is defined as ``single user mode''.  Runlevel 3 
	 is defined as
	"multi user" because it is the runlevel that the system boot into
	under normal day to day conditions.  Runlevel 5 is typically the same as 3 except that a GUI 
	 
	gets started also.
	Runlevel 6 is defined as ``system 
	reboot''.  Other runlevels are
	dependent on how your particular distribution has defined them,
	and they vary significantly between distributions.  Looking at 
	the contents of <TT
CLASS="FILENAME"
>/etc/inittab</TT
> 
	
	usually will 
	give some hint what the predefined runlevels are and what they
	have been defined as.</P
><P
>In normal operation, <B
CLASS="COMMAND"
>init</B
> 
	 makes 
	sure <B
CLASS="COMMAND"
>getty</B
> 
	is working (to allow users to log in)
	and to adopt orphan processes (processes whose parent has died; in
	UNIX <EM
>all</EM
> processes <EM
>must</EM
>
	be in a single tree, so orphans must be adopted).</P
><P
>When the system is shut down, it is <B
CLASS="COMMAND"
>init</B
>
	that is in charge of killing all other processes, unmounting all
	filesystems and stopping the processor, along with anything else
	it has been configured to do.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="TERMINAL-LOGINS"
></A
>2.3.2. Logins from terminals</H2
><P
>Logins from terminals (via serial lines) and the console
	(when not running X) are provided by the <B
CLASS="COMMAND"
>getty</B
> 
	
	program.  <B
CLASS="COMMAND"
>init</B
> starts a separate instance of
	<B
CLASS="COMMAND"
>getty</B
> for each terminal upon which logins are to
	be allowed.  <B
CLASS="COMMAND"
>getty</B
> reads the username and runs
	the <B
CLASS="COMMAND"
>login</B
>program, which reads the password.  
	If the username and password are correct, <B
CLASS="COMMAND"
>login</B
> runs
	the shell. When the shell terminates, i.e., the user logs out, or
	when <B
CLASS="COMMAND"
>login</B
> terminated because the username and
	password didn't match, <B
CLASS="COMMAND"
>init</B
> notices this and
	starts a new instance of <B
CLASS="COMMAND"
>getty</B
>. The kernel has no
	notion of logins, this is all handled by the
	<I
CLASS="GLOSSTERM"
>system programs</I
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="SYSLOG"
></A
>2.3.3. Syslog</H2
><P
>The kernel and many <I
CLASS="GLOSSTERM"
>system programs</I
>
	produce error, warning, and other messages.  It is often important
	that these messages can be viewed later, even much later, so they
	should be written to a file.  The program doing this is
	<B
CLASS="COMMAND"
>syslog</B
> .  It can be configured to sort the
	messages to different files according to writer or degree of
	importance.  For example, kernel messages are often directed to a
	separate file from the others, since kernel messages are often more
	important and need to be read
	regularly to spot problems.</P
><P
><A
HREF="#SYSTEM-LOGS"
>Chapter 15</A
> will provide more on
	 this.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="CRON"
></A
>2.3.4. Periodic command execution: <B
CLASS="COMMAND"
>cron</B
> and
<B
CLASS="COMMAND"
>at</B
></H2
><P
>Both users and system administrators often need
	to run commands periodically.  For example, the system administrator
	might want to run a command to clean the directories with temporary
	files (<TT
CLASS="FILENAME"
>/tmp</TT
> and <TT
CLASS="FILENAME"
>/var/tmp</TT
>)
	from old files, to keep the disks from filling up, since not all
	programs clean up after
	themselves correctly.</P
><P
>The <B
CLASS="COMMAND"
>cron</B
>  service is set up to do this.
	Each user can have a <TT
CLASS="FILENAME"
>crontab</TT
> 
	 file, where she
	lists the commands she wishes to execute and the times they should
	be executed.  The <B
CLASS="COMMAND"
>cron</B
> daemon takes care of
	starting the commands when specified.</P
><P
>The <B
CLASS="COMMAND"
>at</B
>  service is similar to
	<B
CLASS="COMMAND"
>cron</B
>, but it is once only: the command is
	executed at the given time, but it is not repeated.</P
><P
>We will go more into this later. See the manual pages 
	cron(1), crontab(1), crontab(5), at(1) and atd(8) for more in 
	depth information.</P
><P
><A
HREF="#TASK-AUTOMATION"
>Chapter 13</A
> will cover this.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="GUI"
></A
>2.3.5. Graphical user interface</H2
><P
>&#13;	UNIX and Linux don't incorporate the user interface
	into the kernel; instead, they let it be implemented by user level
	programs.  This applies for both text mode and graphical
	environments.</P
><P
>This arrangement makes the system more flexible, but has
	the disadvantage that it is simple to implement a different user
	interface for each program, making the system harder to
	learn.</P
><P
>The graphical environment primarily used with Linux
	is called the X Window System  (X for short).  
	X also does not implement a user interface; it only implements a 
	window system, i.e., tools with which a graphical user interface can
	be implemented.  Some popular window managers are: fvwm , icewm
	, blackbox , and windowmaker 
	. There are also two popular desktop managers,
	KDE  and Gnome.
	</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="NETWORKING"
></A
>2.3.6. Networking</H2
><P
>Networking is the act of connecting two or more computers
	so that they can communicate with each other.  The actual methods
	of connecting and communicating are slightly complicated, but
	the end result is very useful.</P
><P
>UNIX operating systems have many networking features.
	Most basic services (filesystems, printing, backups, etc) can
	be done over the network.  This can make system administration
	easier, since it allows centralized administration, while
	still reaping in the benefits of microcomputing and distributed
	computing, such as lower costs and better fault tolerance.</P
><P
>However, this book merely glances at networking; see the
	<I
CLASS="CITETITLE"
>Linux Network Administrators' Guide</I
>
	<A
HREF="../../nag2/index.html"
TARGET="_top"
>	http://www.tldp.org/LDP/nag2/index.html</A
> 
	 for
	more information, including a basic description of how networks
	operate.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="NETWORK-LOGINS"
></A
>2.3.7. Network logins</H2
><P
>Network logins work a little differently 
	than normal logins.  For each person logging in via the network
	there is a separate virtual network connection, 
	and there can be any number of these depending on the available 
	bandwidth.  It is therefore not possible to run a separate
	<B
CLASS="COMMAND"
>getty</B
> for each possible virtual connection.
	There are also several different ways to log in via a network,
	<B
CLASS="COMMAND"
>telnet</B
> and <B
CLASS="COMMAND"
>ssh</B
>
	 being
	the major ones in TCP/IP networks.</P
><P
>These days many Linux system administrators consider
	<B
CLASS="COMMAND"
>telnet</B
> and <B
CLASS="COMMAND"
>rlogin</B
> to be 
	insecure and prefer <B
CLASS="COMMAND"
>ssh</B
>, the ``secure shell'', 
	which encrypts traffic going over the network, thereby making it far 
	less likely that the malicious can ``sniff'' your connection and gain 
	sensitive data like usernames and passwords.  It is highly recommended 
	you use <B
CLASS="COMMAND"
>ssh</B
> rather than <B
CLASS="COMMAND"
>telnet</B
> 
	or <B
CLASS="COMMAND"
>rlogin</B
>.</P
><P
>Network logins have, instead of a herd 
	of <B
CLASS="COMMAND"
>getty</B
>s, a single daemon per way 
	of logging in
	(<B
CLASS="COMMAND"
>telnet</B
> and <B
CLASS="COMMAND"
>ssh</B
>
	 have
	separate daemons) that listens for all incoming login attempts.
	When it notices one, it starts a new instance of itself to
	handle that single attempt; the original instance continues to
	listen for other attempts.  The new instance works similarly
	to <B
CLASS="COMMAND"
>getty</B
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="NFS"
></A
>2.3.8. Network file systems</H2
><P
>One of the more useful things that can be done with
	networking services is sharing files via a <I
CLASS="GLOSSTERM"
>network
	file system</I
>.  Depending on your network this could 
	be done over the Network File System (NFS), or over 
	the Common Internet File System (CIFS).
	NFS is typically a 'UNIX' based service.  In Linux, NFS is supported
	by the kernel.  CIFS however is not.  In Linux,
	CIFS is supported by Samba <A
HREF="http://www.samba.org/"
TARGET="_top"
>	http://www.samba.org</A
>.

	</P
><P
>With a network file system any file operations done by
	a program on one machine are sent over the network to another
	computer.  This fools the program to think that all the files
	on the other computer are actually on the computer the program
	is running on.	This makes information sharing extremely simple,
	since it requires no modifications to programs.</P
><P
>This will be covered in more detail in 
	<A
HREF="#NET-ATTACHED"
>Section 5.4</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="MAIL"
></A
>2.3.9. Mail</H2
><P
>Electronic mail is the most popularly used method for
	communicating via computer.  An electronic letter is stored in a
	file using a special format, and special mail programs are used
	to send and read the letters.</P
><P
>Each user has an <I
CLASS="GLOSSTERM"
>incoming mailbox</I
>
	(a file in the special format), where all new mail is stored.
	When someone sends mail, the mail program locates the receiver's
	mailbox and appends the letter to the mailbox file.  If the
	receiver's mailbox is in another machine, the letter is sent to
	the other machine, which delivers it to the mailbox as it best
	sees fit.</P
><P
>The mail system consists of many programs.  The
	delivery of mail to local or remote mailboxes is done by one
	program (the <I
CLASS="GLOSSTERM"
>mail transfer agent</I
> (MTA)
	, e.g., <B
CLASS="COMMAND"
>sendmail</B
>
	
	or <B
CLASS="COMMAND"
>postfix</B
>
	), while the programs users use are many and varied
	(<I
CLASS="GLOSSTERM"
>mail user agent</I
> (MUA)
	, e.g., <B
CLASS="COMMAND"
>pine</B
>
	, or 
	<B
CLASS="COMMAND"
>evolution</B
>
	.	
	The mailboxes are usually stored
	in <TT
CLASS="FILENAME"
>/var/spool/mail</TT
> until the user's MUA
	retrieves them.</P
><P
>For more information on setting up and running mail services
	you can read the Mail Administrator HOWTO at
	<A
HREF="../../../HOWTO/Mail-Administrator-HOWTO.html"
TARGET="_top"
>	http://www.tldp.org/HOWTO/Mail-Administrator-HOWTO.html</A
>, or 
	visit the sendmail or postfix's website.
	<A
HREF="http://www.sendmail.org/"
TARGET="_top"
>http://www.sendmail.org/</A
>, 
	or <A
HREF="http://www.postfix.org/"
TARGET="_top"
>http://www.postfix.org/
	</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="PRINTING"
></A
>2.3.10. Printing</H2
><P
>Only one person can use a printer at one time, but it is
	uneconomical not to share printers between users.  The printer is
	therefore managed by software that implements a <I
CLASS="GLOSSTERM"
>print
	queue</I
>: all print 
	jobs are put into a queue and 
	whenever the printer is done with one job, the next one is sent
	to it automatically.  This relieves the users from organizing
	the print queue and fighting over control of the printer.
	Instead, they form a new queue <EM
>at</EM
> 
	the printer, waiting for their printouts, since no one ever seems to
	be able to get the queue software to know exactly when anyone's printout 
	is really finished.  This is a great boost to intra-office social 
	relations.</P
><P
>The print queue software also <I
CLASS="GLOSSTERM"
>spools</I
>
	 the printouts on 
	disk, i.e., the text is kept in a file while
	the job is in the queue.  This allows an application program
	to spit out the print jobs quickly to the print queue software;
	the application does not have to wait until the job is actually
	printed to continue.  This is really convenient, since it
	allows one to print out one version, and not have to wait for
	it to be printed before one can make a completely revised new
	version.</P
><P
>You can refer to the Printing-HOWTO located at
	<A
HREF="../../../HOWTO/Printing-HOWTO/index.html"
TARGET="_top"
>	http://www.tldp.org/HOWTO/Printing-HOWTO/index.html</A
> 
	for more help in setting up printers.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FS-LAYOUT"
></A
>2.3.11. The filesystem layout</H2
><P
>The filesystem is divided into many parts;
	usually along the lines of a root filesystem with
	<TT
CLASS="FILENAME"
>/bin</TT
>
	,
	<TT
CLASS="FILENAME"
>/lib</TT
>
	,
	<TT
CLASS="FILENAME"
>/etc</TT
>
	,
	<TT
CLASS="FILENAME"
>/dev</TT
>
	, and a few others;
	a <TT
CLASS="FILENAME"
>/usr</TT
>
	 filesystem with
        programs and unchanging data;
	<TT
CLASS="FILENAME"
>/var</TT
>
	 filesystem with changing
	data (such as log files); and a
	<TT
CLASS="FILENAME"
>/home</TT
>
	 for everyone's personal
	files.	Depending on the hardware configuration and the decisions
	of the system administrator, the division can be different;
	it can even be all in one filesystem.</P
><P
><A
HREF="#DIR-TREE-OVERVIEW"
>Chapter 3</A
> describes the filesystem
	layout in some little detail; the Filesystem Hierarchy Standard
	. covers 
	it in somewhat more detail.  This can be found on the web at:
	<A
HREF="http://www.pathname.com/fhs/"
TARGET="_top"
>	http://www.pathname.com/fhs/</A
></P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DIR-TREE-OVERVIEW"
></A
>Chapter 3. Overview of the Directory Tree</H1
><A
NAME="AEN542"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>" Two days later, there was Pooh, sitting
	on his branch, dangling his legs, and there, beside him, were
	four pots of honey..."</SPAN
> (A.A. Milne) </P
></BLOCKQUOTE
><P
>This chapter describes the important parts of a standard Linux
	directory tree, based on the Filesystem Hierarchy Standard
	. It
	outlines the normal way of breaking the directory tree into separate
	filesystems with different purposes and gives the motivation behind
	this particular split.  Not all Linux distributions follow this
	standard slavishly, but it is generic enough to give you an
	overview.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="FS-BACKGROUND"
></A
>3.1. Background</H1
><P
>This chapter is loosely based on the <I
CLASS="CITETITLE"
>Filesystems
	Hierarchy Standard</I
> (FHS).
	version 2.1, which attempts to
	set a standard for how the directory tree in a Linux
	system is organized. Such a standard has the advantage that it will
	be easier to write or port software for Linux, and to administer
	Linux machines, since everything should be in standardized places.
	There is no authority behind the standard that forces anyone to
	comply with it, but it has gained the support of many Linux
	distributions. It is not a good idea to break with the FHS without
	very compelling reasons.  The FHS attempts to follow Unix tradition
	and current trends, making Linux systems familiar to those with
	experience with other Unix systems, and vice versa.</P
><P
>This chapter is not as detailed as the FHS.  A system
	administrator should also read the full FHS for a complete
	understanding.</P
><P
>This chapter does not explain all files in detail. The
	intention is not to describe every file, but to give an overview of
	the system from a filesystem point of view. Further information on
	each file is available elsewhere in this manual or in the Linux
	manual pages.</P
><P
>The full directory tree is intended to be breakable into
	smaller parts, each capable of being on its own disk or partition,
	to accommodate to disk size limits and to ease backup and other
	system administration tasks.  The major parts are the root
	(<TT
CLASS="FILENAME"
>/</TT
>
        ), 
	<TT
CLASS="FILENAME"
>/usr</TT
>
        ,
        <TT
CLASS="FILENAME"
>/var</TT
>
        , and
        <TT
CLASS="FILENAME"
>/home</TT
>
         filesystems 
	(see <A
HREF="#FSTREE"
>Figure 3-1</A
>).  Each part has a
	different purpose. The directory tree has been designed so that it
	works well in a network of Linux machines which may share some parts
	of the filesystems over a read-only device (e.g., a CD-ROM), or over
	the network with NFS.</P
><DIV
CLASS="FIGURE"
><A
NAME="FSTREE"
></A
><P
><B
>Figure 3-1. Parts of a Unix
		directory tree. Dashed lines indicate partition 
		limits.</B
></P
><P
><IMG
SRC="fstree.png"></P
></DIV
><P
>The roles of the different parts of the directory tree are
	described below.

	<P
></P
><UL
><LI
><P
>The root filesystem
		 is specific for
		each machine (it is generally stored on a local disk,
		although it could be a ramdisk or network drive as well) and
		contains the files that are necessary for booting the system
		up, and to bring it up to such a state that the other
		filesystems may be mounted.  The contents of the root
		filesystem will therefore be sufficient for the single user
		state.	It will also contain tools for fixing a broken
		system, and for recovering lost files
		from backups.</P
></LI
><LI
><P
> The <TT
CLASS="FILENAME"
>/usr</TT
>
		 filesystem
		contains all commands, libraries, manual pages, and other
		unchanging files needed during normal operation. No files in
		<TT
CLASS="FILENAME"
>/usr</TT
> should be specific for any given
		machine, nor should they be modified during normal use. This
		allows the files to be shared over the network, which can be
		cost-effective since it saves disk space (there can easily
		be hundreds of megabytes, increasingly multiple gigabytes in
		<TT
CLASS="FILENAME"
>/usr</TT
>).  It can make administration
		easier (only the master <TT
CLASS="FILENAME"
>/usr</TT
> needs to
		be changed when updating an application, not each machine
		separately) to have /usr network mounted.  Even if the
		filesystem is on a local disk, it could be mounted
		read-only, to lessen the chance of filesystem corruption 
		during a crash.</P
></LI
><LI
><P
>The <TT
CLASS="FILENAME"
>/var</TT
>
		
		filesystem contains files that change, such as spool
		directories (for mail, news, printers, etc), log files,
		formatted manual pages, and temporary files. Traditionally
		everything in <TT
CLASS="FILENAME"
>/var</TT
> has been somewhere
		below <TT
CLASS="FILENAME"
>/usr</TT
>
		, but that made it 
		impossible to mount <TT
CLASS="FILENAME"
>/usr</TT
> read-only.
		</P
><P
></P
></LI
><LI
><P
> The <TT
CLASS="FILENAME"
>/home</TT
>
		
		filesystem contains the users' home directories, i.e., all
		the real data on the system.  Separating home directories to
		their own directory tree or filesystem makes backups easier;
		the other parts often do not have to be backed up, or at
		least not as often as they seldom change. A big
		<TT
CLASS="FILENAME"
>/home</TT
> might have to be broken across
		several filesystems, which requires adding an extra naming
		level below <TT
CLASS="FILENAME"
>/home</TT
>, for example
		<TT
CLASS="FILENAME"
>/home/students</TT
> and
		<TT
CLASS="FILENAME"
>/home/staff</TT
>.</P
></LI
></UL
> </P
><P
>Although the different parts have been called filesystems
	above, there is no requirement that they actually be on separate
	filesystems.  They could easily be kept in a single one if the
	system is a small single-user system and the user wants to keep
	things simple.	The directory tree might also be divided into
	filesystems differently, depending on how large the disks are, and
	how space is allocated for various purposes.  The important part,
	though, is that all the standard <EM
>names</EM
> work;
	even if, say, <TT
CLASS="FILENAME"
>/var</TT
>
	 and
	<TT
CLASS="FILENAME"
>/usr</TT
>
        are actually on the same partition, the names
	<TT
CLASS="FILENAME"
>/usr/lib/libc.a</TT
> and
	<TT
CLASS="FILENAME"
>/var/log/messages</TT
> must work, for example by
	moving files below <TT
CLASS="FILENAME"
>/var</TT
> into
	<TT
CLASS="FILENAME"
>/usr/var</TT
>, and making <TT
CLASS="FILENAME"
>/var</TT
>
	a symlink to
	<TT
CLASS="FILENAME"
>/usr/var</TT
>.</P
><P
>The Unix filesystem structure groups files according to 
	purpose, i.e., all commands are in one place, all data files in
	another, documentation in a third, and so on.  An alternative would
	be to group files files according to the program they belong to,
	i.e., all Emacs files would be in one directory, all TeX in another,
	and so on.  The problem with the latter approach is that it makes it
	difficult to share files (the program directory often contains both
	static and sharable and changing and non-sharable files), and
	sometimes to even find the files (e.g., manual pages in a huge
	number of places, and making the manual page programs find all of
	them is a maintenance
	nightmare).</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="ROOT-FS"
></A
>3.2. The root filesystem</H1
><P
>The root filesystem should generally be small, since
	it contains very critical files and a small, infrequently
	modified filesystem has a better chance of not getting corrupted.
	A corrupted root filesystem will generally mean that the system
	becomes unbootable except with special measures (e.g., from a
	floppy), so you don't want to risk it.</P
><P
>The root directory generally doesn't contain any files, except
	perhaps on older systems where the standard boot image for the system, 
	usually called <TT
CLASS="FILENAME"
>/vmlinuz</TT
>
	 was kept there.  (Most 
	distributions have moved those files the the 
	<TT
CLASS="FILENAME"
>/boot</TT
> directory.  Otherwise, all files are kept
	in subdirectories under the root filesystem:

	<DIV
CLASS="GLOSSLIST"
><DL
><DT
><B
><TT
CLASS="FILENAME"
>/bin</TT
></B
></DT
><DD
><P
>Commands needed during bootup
		that might be used by normal users (probably after
		bootup).</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/sbin</TT
></B
></DT
><DD
><P
>Like <TT
CLASS="FILENAME"
>/bin</TT
>, but the
		commands are not intended for normal users, although they
		may use them if necessary and allowed.
		<TT
CLASS="FILENAME"
>/sbin</TT
> is not usually in the default
		path of normal users, but will be in root's default
		path.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc</TT
></B
></DT
><DD
><P
>Configuration files specific to the
		machine.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/root</TT
></B
></DT
><DD
><P
>The home directory for user root.  This is
		usually not accessible to other users on the
		system</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/lib</TT
></B
></DT
><DD
><P
>Shared libraries needed by the programs on
		the root filesystem.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/lib/modules</TT
></B
></DT
><DD
><P
>Loadable kernel modules, especially those
		that are needed to boot the system when recovering from
		disasters (e.g., network and filesystem
		drivers).</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev</TT
></B
></DT
><DD
><P
>Device files.  These are special files that 
		help the user interface with the various devices on the system.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/tmp</TT
></B
></DT
><DD
><P
>Temporary files.  As the name suggests,
		programs running often store temporary files in here.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/boot</TT
></B
></DT
><DD
><P
>Files used by the bootstrap loader,
		e.g., LILO or GRUB.  Kernel images are often kept here instead
		of in the root directory.  If there are many kernel
		images, the directory can easily grow rather big, and it
		might be better to keep it in a separate filesystem.
		Another reason would be to make sure the kernel
		images are within the first 1024 cylinders of an IDE
		disk. This 1024 cylinder limit is no longer true in 
		most cases.  With modern BIOSes and later versions of LILO
		(the LInux LOader) the 1024 cylinder limit can be passed 
		with logical block addressing (LBA).  See the 
		<B
CLASS="COMMAND"
>lilo</B
> manual page for more details.
	       </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/mnt</TT
></B
></DT
><DD
><P
>Mount point for temporary mounts by
		the system administrator.  Programs aren't supposed to mount
		on <TT
CLASS="FILENAME"
>/mnt</TT
> automatically.
		<TT
CLASS="FILENAME"
>/mnt</TT
> might be divided into
		subdirectories (e.g., <TT
CLASS="FILENAME"
>/mnt/dosa</TT
> might
		be the floppy drive using an MS-DOS filesystem, and
		<TT
CLASS="FILENAME"
>/mnt/exta</TT
> might be the same
		with an ext2 filesystem).</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc</TT
>,
	<TT
CLASS="FILENAME"
>/usr</TT
>, 
	<TT
CLASS="FILENAME"
>/var</TT
>,
	<TT
CLASS="FILENAME"
>/home</TT
></B
></DT
><DD
><P
>Mount points for the other filesystems.  Although
	<TT
CLASS="FILENAME"
>/proc</TT
> does not reside on any disk in reality
	it is still mentioned here. See the section about 
	<TT
CLASS="FILENAME"
>/proc</TT
> later in the chapter.
	</P
></DD
></DL
></DIV
>
	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="ETC-FS"
></A
>3.3. The <TT
CLASS="FILENAME"
>/etc</TT
> directory</H1
><P
>The <TT
CLASS="FILENAME"
>/etc</TT
> maintains a lot
	of files.  Some of them are described below.  For others, you
	should determine which program they belong to and read the manual
	page for that program.	Many networking configuration files are
	in <TT
CLASS="FILENAME"
>/etc</TT
> as well, and are described in the
	<I
CLASS="CITETITLE"
>Networking Administrators' Guide</I
>.

	<DIV
CLASS="GLOSSLIST"
><DL
><DT
><B
><TT
CLASS="FILENAME"
>/etc/rc</TT
> or 
	<TT
CLASS="FILENAME"
>/etc/rc.d</TT
> or 
	<TT
CLASS="FILENAME"
>/etc/rc?.d</TT
></B
></DT
><DD
><P
>Scripts or directories of scripts
		to run at startup or when changing the run level.
		See <A
HREF="#INIT"
>Section 2.3.1</A
> for further
		information.  </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/passwd</TT
></B
></DT
><DD
><P
>The user database, with fields giving the
		username, real name, home directory, and other information
		about each user. The format is documented in the 
		<B
CLASS="COMMAND"
>passwd</B
> manual page.  
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/shadow</TT
></B
></DT
><DD
><P
><TT
CLASS="FILENAME"
>/etc/shadow</TT
> is an
		encrypted file the holds user passwords.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/fdprm</TT
></B
></DT
><DD
><P
>Floppy disk parameter table.
		Describes what different floppy disk formats look
		like.  Used by <B
CLASS="COMMAND"
>setfdprm</B
>
		.  See the
		<B
CLASS="COMMAND"
>setfdprm</B
> manual page for more
		information.  </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/fstab</TT
></B
></DT
><DD
><P
>Lists the filesystems mounted automatically
		at startup by the <B
CLASS="COMMAND"
>mount -a</B
> command (in
		<TT
CLASS="FILENAME"
>/etc/rc</TT
> or equivalent startup file).
		Under Linux, also contains information about swap areas used
		automatically by <B
CLASS="COMMAND"
>swapon -a</B
>
		.  See <A
HREF="#MOUNT-AND-UMOUNT"
>Section 5.10.7</A
> and the <B
CLASS="COMMAND"
>mount</B
>
		
		manual page for more information.  Also
		<TT
CLASS="FILENAME"
>fstab</TT
> usually has its own manual page in
		section 5. </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/group</TT
></B
></DT
><DD
><P
>Similar to <TT
CLASS="FILENAME"
>/etc/passwd</TT
>,
		but describes groups instead of users.  See the
		<TT
CLASS="FILENAME"
>group</TT
> manual page in section 5 for more
		information. </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/inittab</TT
></B
></DT
><DD
><P
>Configuration file for
		<B
CLASS="COMMAND"
>init</B
>.  </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/issue</TT
></B
></DT
><DD
><P
>Output by <B
CLASS="COMMAND"
>getty</B
>
		 before
		the login prompt.  Usually contains a short description or
		welcoming message to the system.  The contents are up to
		the system administrator.  </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/magic</TT
></B
></DT
><DD
><P
>The configuration file
		for <B
CLASS="COMMAND"
>file</B
>.  Contains the
		descriptions of various file formats based on
		which <B
CLASS="COMMAND"
>file</B
> guesses the type of
		the file.  See the <TT
CLASS="FILENAME"
>magic</TT
> and
		<B
CLASS="COMMAND"
>file</B
> manual pages for more information.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/motd</TT
></B
></DT
><DD
><P
>The message of the day, automatically
		output after a successful login.  Contents are up to the
		system administrator.  Often used for getting information
		to every user, such as warnings about planned downtimes.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/mtab</TT
></B
></DT
><DD
><P
>List of currently mounted filesystems.
		Initially set up by the bootup scripts, and updated
		automatically by the <B
CLASS="COMMAND"
>mount</B
>
		
		command.  Used when a list of mounted filesystems is
		needed, e.g., by the <B
CLASS="COMMAND"
>df</B
>
		 command.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/login.defs</TT
></B
></DT
><DD
><P
>Configuration file for the
		<B
CLASS="COMMAND"
>login</B
> command.  The
		<TT
CLASS="FILENAME"
>login.defs</TT
> file usually has a manual
		page in section 5. </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/printcap</TT
></B
></DT
><DD
><P
>Like <TT
CLASS="FILENAME"
>/etc/termcap</TT
>
        	<I
CLASS="GLOSSTERM"
><TT
CLASS="FILENAME"
>/etc/printcap</TT
>
		, but
		intended for printers.  However it uses different syntax.
		The <TT
CLASS="FILENAME"
>printcap</TT
> has a manual page in
		section 5. </I
></P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/profile</TT
>, 
	<TT
CLASS="FILENAME"
>/etc/bash.rc</TT
>, 
	<TT
CLASS="FILENAME"
>/etc/csh.cshrc</TT
></B
></DT
><DD
><P
>Files executed at login or startup time
		by the Bourne, BASH
		,
		or C 
		shells.  These allow the system
		administrator to set global defaults for all users.  Users
		can also create individual copies of these in their home 
		directory to personalize their environment.
		See the manual pages for the respective shells.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/securetty</TT
></B
></DT
><DD
><P
>Identifies secure terminals, i.e., the
		terminals from which root is allowed to log in. Typically
		only the virtual consoles are listed, so that it becomes
		impossible (or at least harder) to gain superuser privileges
		by breaking into a system over a modem or a network.  Do not
		allow root logins over a network.  Prefer to log in as an
		unprivileged user and use <B
CLASS="COMMAND"
>su</B
>
		 or
		<B
CLASS="COMMAND"
>sudo</B
> to gain root
		privileges.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/shells</TT
></B
></DT
><DD
><P
>Lists trusted shells.  The
		<B
CLASS="COMMAND"
>chsh</B
> command allows users to change
		their login shell only to shells listed in this file.
		<B
CLASS="COMMAND"
>ftpd</B
>, is the server process that provides
		FTP services for a machine, will check that the user's
		shell is listed in <TT
CLASS="FILENAME"
>/etc/shells</TT
>
		and will not let people log in unless the shell is
		listed there.  </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/etc/termcap</TT
></B
></DT
><DD
><P
>The terminal capability database.
		Describes by what ``escape sequences'' various terminals
		can be controlled.  Programs are written so that instead
		of directly outputting an escape sequence that only
		works on a particular brand of terminal, they look up
		the correct sequence to do whatever it is they want to
		do in <TT
CLASS="FILENAME"
>/etc/termcap</TT
>.  As a result
		most programs work with most kinds of terminals.
		See the <TT
CLASS="FILENAME"
>termcap</TT
>, curs_termcap,
		and <TT
CLASS="FILENAME"
>terminfo</TT
> manual pages for
		more information.  </P
></DD
></DL
></DIV
>
	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="DEV-FS"
></A
>3.4. The <TT
CLASS="FILENAME"
>/dev</TT
> directory</H1
><P
>The <TT
CLASS="FILENAME"
>/dev</TT
> directory contains
	the special device files for all the devices. 
	The device files are created during
	installation, and later with the <B
CLASS="COMMAND"
>/dev/MAKEDEV</B
>
	script. The <B
CLASS="COMMAND"
>/dev/MAKEDEV.local</B
> is a script
	written by the system administrator that creates local-only device
	files or links (i.e. those that are not part of the standard
	<B
CLASS="COMMAND"
>MAKEDEV</B
>, such as device files for some
	non-standard device driver).</P
><P
>This list which follows is by no means exhaustive or as
        detailed as it could be.  Many of these device files will need
        support compiled into your kernel for the hardware.  Read the kernel
        documentation to find details of any particular device.</P
><P
>If you think there are other devices which should be included
        here but aren't then let me know.  I will try to include them in the
        next revision.</P
><DIV
CLASS="GLOSSLIST"
><DL
><DT
><B
><TT
CLASS="FILENAME"
>/dev/dsp</TT
></B
></DT
><DD
><P
>Digital Signal Processor.  Basically this forms
            the interface between software which produces sound and your
            soundcard.  It is a character device on major node 14 and minor
            3.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/fd0</TT
></B
></DT
><DD
><P
>The first floppy drive.  If you are lucky enough
            to have several drives then they will be numbered sequentially.
            It is a character device on major node 2 and minor
            0.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/fb0</TT
></B
></DT
><DD
><P
>The first framebuffer device. A framebuffer is
            an abstraction layer between software and graphics hardware.
            This means that applications do not need to know about what kind
            of hardware you have but merely how to communicate with the
            framebuffer driver's API (Application Programming Interface)
            which is well defined and standardized.  The framebuffer is a
            character device and is on major node 29 and minor
            0.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/hda</TT
></B
></DT
><DD
><P
><TT
CLASS="FILENAME"
>/dev/hda</TT
> is the master IDE
            drive on the primary IDE controller.
            <TT
CLASS="FILENAME"
>/dev/hdb</TT
> the slave drive on the 
            primary controller.  <TT
CLASS="FILENAME"
>/dev/hdc</TT
>
	    , and <TT
CLASS="FILENAME"
>/dev/hdd</TT
>
             are the master and slave devices
            on the secondary controller respectively.  Each disk is divided
            into partitions. Partitions 1-4 are primary partitions and
            partitions 5 and above are logical partitions inside extended
            partitions.  Therefore the device file which references each
            partition is made up of several parts.  For example
            <TT
CLASS="FILENAME"
>/dev/hdc9</TT
> references partition 9 (a logical
            partition inside an extended partition type) on the master IDE
            drive on the secondary IDE controller.  The major and minor node
            numbers are somewhat complex.  For the first IDE controller all
            partitions are block devices on major node 3.  The master drive
            <TT
CLASS="FILENAME"
>hda</TT
> is at minor 0 and the 
            slave drive <TT
CLASS="FILENAME"
>hdb</TT
> is at minor 64.  For 
            each partition inside the drive add the partition number to the minor 
            minor node number for the drive.  For example
            <TT
CLASS="FILENAME"
>/dev/hdb5</TT
> is major 3, minor 69 (64 + 5 =
            69). Drives on the secondary interface are handled the same way,
            but with major node 22.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/ht0</TT
></B
></DT
><DD
><P
>The first IDE tape drive.  Subsequent drives are
            numbered <TT
CLASS="FILENAME"
>ht1</TT
> etc.  They are character
            devices on major node 37 and start at minor node 0 for
            <TT
CLASS="FILENAME"
>ht0</TT
> 1 for <TT
CLASS="FILENAME"
>ht1</TT
>
            etc.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/js0</TT
></B
></DT
><DD
><P
>The first analogue joystick.  Subsequent joysticks
            are numbered <TT
CLASS="FILENAME"
>js1</TT
>, <TT
CLASS="FILENAME"
>js2</TT
>
            etc.  Digital joysticks are called <TT
CLASS="FILENAME"
>djs0</TT
>,
            <TT
CLASS="FILENAME"
>djs1</TT
> and so on.  They are character devices
            on major node 15.  The analogue joysticks start at minor node 0
            and go up to 127 (more than enough for even the most fanatic
            gamer). Digital joysticks start at minor node
            128.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/lp0</TT
></B
></DT
><DD
><P
>The first parallel printer device.  Subsequent
            printers are numbered <TT
CLASS="FILENAME"
>lp1</TT
>,
            <TT
CLASS="FILENAME"
>lp2</TT
> etc.  They are character devices on
            major mode 6 and minor nodes starting at 0 and numbered
            sequentially.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/loop0</TT
></B
></DT
><DD
><P
>The first loopback device.  Loopback devices are
            used for mounting filesystems which are not located on other
            block devices such as disks.  For example if you wish to mount
            an iso9660 CD ROM image without burning it to CD then you need
            to use a loopback device to do so.  This is usually transparent
            to the user and is handled by the <B
CLASS="COMMAND"
>mount</B
>
	    
            command.  Refer to the manual pages for <B
CLASS="COMMAND"
>mount</B
>
            and <B
CLASS="COMMAND"
>losetup</B
>.
            The loopback devices are block
            devices on major node 7 and with minor nodes starting at 0 and
            numbered sequentially.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/md0</TT
></B
></DT
><DD
><P
>First metadisk group.  Metadisks are related to
            RAID (Redundant Array of Independent Disks) devices.  Please
            refer to the most current RAID HOWTO at the LDP for more details.
            This can be found at
            <A
HREF="../../../HOWTO/Software-RAID-HOWTO.html"
TARGET="_top"
>            http://www.tldp.org/HOWTO/Software-RAID-HOWTO.html</A
>.
            Metadisk devices are block devices on major node 9 with minor
            nodes starting at 0 and numbered
            sequentially.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/mixer</TT
></B
></DT
><DD
><P
>This is part of the OSS (Open Sound System)
	     driver. Refer to the OSS documentation at <A
HREF="http://www.opensound.com/"
TARGET="_top"
>http://www.opensound.com</A
>
            for more details.  It is a character device on major node 14,
            minor node 0.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/null</TT
></B
></DT
><DD
><P
>The bit bucket.  A black hole where you can send
            data for it never to be seen again.  Anything sent to
            <TT
CLASS="FILENAME"
>/dev/null</TT
> will disappear.  This can be
            useful if, for example, you wish to run a command but not have
            any feedback appear on the terminal.  It is a character device
            on major node 1 and minor node 3.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/psaux</TT
></B
></DT
><DD
><P
>The PS/2 mouse port.  This is a character device
            on major node 10, minor node 1.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/pda</TT
></B
></DT
><DD
><P
>Parallel port IDE disks.  These are named
            similarly to disks on the internal IDE controllers
            (<TT
CLASS="FILENAME"
>/dev/hd*</TT
>).  They are block devices on major
            node 45. Minor nodes need slightly more explanation here.  The
            first device is <TT
CLASS="FILENAME"
>/dev/pda</TT
> and it is on minor
            node 0.  Partitions on this device are found by adding the
            partition number to the minor number for the device.  Each
            device is limited to 15 partitions each rather than 63 (the
            limit for internal IDE disks).  <TT
CLASS="FILENAME"
>/dev/pdb</TT
>
            
            minor nodes start at 16, <TT
CLASS="FILENAME"
>/dev/pdc</TT
>
	     
            at 32 and <TT
CLASS="FILENAME"
>/dev/pdd</TT
> at 48.  So for example the 
            minor node number for <TT
CLASS="FILENAME"
>/dev/pdc6</TT
> would be 38 (32 +
            6 = 38).  This scheme limits you to 4 parallel disks of 15
            partitions each.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/pcd0</TT
></B
></DT
><DD
><P
>Parallel port CD ROM drives.  These are numbered
            from 0 onwards.  All are block devices on major node 46.
            <TT
CLASS="FILENAME"
>/dev/pcd0</TT
> is on minor node 0 with
            subsequent drives being on minor nodes 1, 2, 3
            etc.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/pt0</TT
></B
></DT
><DD
><P
>Parallel port tape devices.  Tapes do not have
            partitions so these are just numbered sequentially.  They are
            character devices on major node 96.  The minor node numbers
            start from 0 for <TT
CLASS="FILENAME"
>/dev/pt0</TT
>, 1 for
            <TT
CLASS="FILENAME"
>/dev/pt1</TT
>, and so on.
                </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/parport0</TT
></B
></DT
><DD
><P
>The raw parallel ports.  Most devices which are
            attached to parallel ports have their own drivers.  This is a
            device to access the port directly.  It is a character device on
            major node 99 with minor node 0.  Subsequent devices after the
            first are numbered sequentially incrementing the minor
            node.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/random</TT
> or
            <TT
CLASS="FILENAME"
>/dev/urandom</TT
></B
></DT
><DD
><P
>These are kernel random number generators.
            <TT
CLASS="FILENAME"
>/dev/random</TT
> is a non-deterministic
            generator which means that the value of the next number cannot
            be guessed from the preceding ones.  It uses the entropy of the
            system hardware to generate numbers.  When it has no more
            entropy to use then it must wait until it has collected more
            before it will allow any more numbers to be read from it.
            <TT
CLASS="FILENAME"
>/dev/urandom</TT
> works similarly.  Initially it
            also uses the entropy of the system hardware, but when there is
            no more entropy to use it will continue to return numbers using
            a pseudo random number generating formula.  This is considered
            to be less secure for vital purposes such as cryptographic key
            pair generation.  If security is your overriding concern then
            use <TT
CLASS="FILENAME"
>/dev/random</TT
>, if speed is more important
            then <TT
CLASS="FILENAME"
>/dev/urandom</TT
> works fine.  They are
            character devices on major node 1 with minor nodes 8 for
            <TT
CLASS="FILENAME"
>/dev/random</TT
> and 9 for
            <TT
CLASS="FILENAME"
>/dev/urandom</TT
>.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/sda</TT
></B
></DT
><DD
><P
>The first SCSI drive on the first SCSI bus.  
	    The following drives are named similar to IDE drives.  
	    <TT
CLASS="FILENAME"
>/dev/sdb</TT
> is the second SCSI drive, 
	    <TT
CLASS="FILENAME"
>/dev/sdc</TT
> is the third SCSI drive, and so 
	    forth.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/ttyS0</TT
></B
></DT
><DD
><P
>The first serial port.  Many times this it the port used
	    to connect an external modem to your system.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/dev/zero</TT
></B
></DT
><DD
><P
>This is a simple way of getting many 0s.  Every
            time you read from this device it will return 0.  This can be
            useful sometimes, for example when you want a file of fixed
            length but don't really care what it contains.  It is a
            character device on major node 1 and minor node
            5.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="USR-FS"
></A
>3.5. The <TT
CLASS="FILENAME"
>/usr</TT
> filesystem.</H1
><P
>The <TT
CLASS="FILENAME"
>/usr</TT
> filesystem is often
	large, since all programs are installed there.	All files
	in <TT
CLASS="FILENAME"
>/usr</TT
> usually come from a Linux
	distribution; locally installed programs and other stuff goes
	below <TT
CLASS="FILENAME"
>/usr/local</TT
>.  This makes it possible
	to update the system from a new version of the distribution,
	or even a completely new distribution, without having to
	install all programs again.  Some of the subdirectories of
	<TT
CLASS="FILENAME"
>/usr</TT
> are listed below (some of the less
	important directories have been dropped; see the FSSTND for
	more information).

	<DIV
CLASS="GLOSSLIST"
><DL
><DT
><B
><TT
CLASS="FILENAME"
>/usr/X11R6</TT
>.</B
></DT
><DD
><P
>The X Window System, all files. To simplify
		the development and installation of X, the X files have not
		been integrated into the rest of the system.  There is a
		directory tree below <TT
CLASS="FILENAME"
>/usr/X11R6</TT
> similar
		to that below <TT
CLASS="FILENAME"
>/usr</TT
> itself.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/usr/bin</TT
>.</B
></DT
><DD
><P
>Almost all user commands. Some commands are
		in <TT
CLASS="FILENAME"
>/bin</TT
> or in
		<TT
CLASS="FILENAME"
>/usr/local/bin</TT
>.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/usr/sbin</TT
></B
></DT
><DD
><P
>System administration commands that are not
		needed on the root filesystem, e.g., most server programs.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/usr/share/man</TT
>, 
	<TT
CLASS="FILENAME"
>/usr/share/info</TT
>, 
	<TT
CLASS="FILENAME"
>/usr/share/doc</TT
></B
></DT
><DD
><P
>Manual pages, GNU Info documents, and
		miscellaneous other documentation files, respectively.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/usr/include</TT
></B
></DT
><DD
><P
>Header files for the C
		programming language.  This should actually be below
		<TT
CLASS="FILENAME"
>/usr/lib</TT
> for consistency, 
		but the tradition is overwhelmingly in support for this name.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/usr/lib</TT
></B
></DT
><DD
><P
>Unchanging data files for programs and
		subsystems, including some site-wide configuration
		files.	The name <TT
CLASS="FILENAME"
>lib</TT
> comes from library;
		originally libraries of programming subroutines
		were stored in <TT
CLASS="FILENAME"
>/usr/lib</TT
>.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/usr/local</TT
></B
></DT
><DD
><P
>The place for locally installed software and
		other files.  Distributions may not install anything in
		here.  It is reserved solely for the use of the local
		administrator.  This way he can be absolutely certain that
		no updates or upgrades to his distribution will overwrite
		any extra software he has installed
		locally.</P
></DD
></DL
></DIV
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="VAR-FS"
></A
>3.6. The <TT
CLASS="FILENAME"
>/var</TT
> filesystem</H1
><P
>The <TT
CLASS="FILENAME"
>/var</TT
> contains data that is 
	changed when the system is running normally.  It is specific for each
	system, i.e., not shared over the network with other computers.

	<DIV
CLASS="GLOSSLIST"
><DL
><DT
><B
><TT
CLASS="FILENAME"
>/var/cache/man</TT
></B
></DT
><DD
><P
>A cache for man pages that are formatted on
		demand.  The source for manual pages is usually stored in
		<TT
CLASS="FILENAME"
>/usr/share/man/man?/</TT
>
		 
		(where ? is the manual section.  See the manual page for
		<B
CLASS="COMMAND"
>man</B
>
		 in section 7); some manual pages
		might come with a pre-formatted version, which might be
		stored in <TT
CLASS="FILENAME"
>/usr/share/man/cat*</TT
>
		. Other
		manual pages need to be formatted when they are first
		viewed; the formatted version is then stored in
		<TT
CLASS="FILENAME"
>/var/cache/man</TT
> so that the next person
		to view the same page won't have to wait for it to be
		formatted. </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/var/games</TT
></B
></DT
><DD
><P
>Any variable data belonging to games in
		<TT
CLASS="FILENAME"
>/usr</TT
> should be placed here.  This is in
		case /usr is mounted read only.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/var/lib</TT
></B
></DT
><DD
><P
>Files that change while the system is
		running normally.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/var/local</TT
></B
></DT
><DD
><P
>Variable data for programs that are
		installed in <TT
CLASS="FILENAME"
>/usr/local</TT
>
		 (i.e.,
		programs that have been installed by the system
		administrator).  Note that even locally installed
		programs should use the other <TT
CLASS="FILENAME"
>/var</TT
>
		directories if they are appropriate, e.g.,
		<TT
CLASS="FILENAME"
>/var/lock</TT
>.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/var/lock</TT
></B
></DT
><DD
><P
>Lock files.  Many programs
		follow a convention to create a lock file in
		<TT
CLASS="FILENAME"
>/var/lock</TT
> to indicate that they
		are using a particular device or file.	Other programs
		will notice the lock file and won't attempt to use the
		device or file.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/var/log</TT
></B
></DT
><DD
><P
>Log files from various programs, especially
		<B
CLASS="COMMAND"
>login</B
>(<TT
CLASS="FILENAME"
>/var/log/wtmp</TT
>, which logs all logins and logouts into the system) and
		<B
CLASS="COMMAND"
>syslog</B
>(<TT
CLASS="FILENAME"
>/var/log/messages</TT
>, where all kernel 
		and system program message are usually stored). Files in
		<TT
CLASS="FILENAME"
>/var/log</TT
> can often grow indefinitely,
		and may require cleaning at regular
		intervals.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/var/mail</TT
></B
></DT
><DD
><P
>This is the FHS approved location for user
		mailbox files.  Depending on how far your distribution has
		gone towards FHS compliance, these files may still be held
		in <TT
CLASS="FILENAME"
>/var/spool/mail</TT
>.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/var/run</TT
></B
></DT
><DD
><P
>Files that contain information about the
		system that is valid until the system is next booted.
		For example, <TT
CLASS="FILENAME"
>/var/run/utmp</TT
>
		
		contains information about people currently logged
		in.</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/var/spool</TT
></B
></DT
><DD
><P
>Directories for news, printer queues, and
		other queued work. Each different spool has its own
		subdirectory below <TT
CLASS="FILENAME"
>/var/spool</TT
>, e.g.,
		the news spool is in <TT
CLASS="FILENAME"
>/var/spool/news</TT
>
		.
		Note that some installations which are not fully compliant
		with the latest version of the FHS may have user mailboxes
		under <TT
CLASS="FILENAME"
>/var/spool/mail</TT
>.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/var/tmp</TT
></B
></DT
><DD
><P
>Temporary files that are large
		or that need to exist for a longer time than
		what is allowed for <TT
CLASS="FILENAME"
>/tmp</TT
>
		.
		(Although the system administrator might not allow
		very old files in <TT
CLASS="FILENAME"
>/var/tmp</TT
>
		either.)</P
></DD
></DL
></DIV
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="PROC-FS"
></A
>3.7. The <TT
CLASS="FILENAME"
>/proc</TT
> filesystem</H1
><P
>The <TT
CLASS="FILENAME"
>/proc</TT
> filesystem contains a
	illusionary filesystem.  It does not exist on a disk. Instead, the
	kernel creates it in memory.  It is used to provide information
	about the system (originally about processes, hence the name).  Some
	of the more important files and directories are explained below.
	The <TT
CLASS="FILENAME"
>/proc</TT
> filesystem is described in more
	detail in the <TT
CLASS="FILENAME"
>proc</TT
> manual page.

	<DIV
CLASS="GLOSSLIST"
><DL
><DT
><B
><TT
CLASS="FILENAME"
>/proc/1</TT
></B
></DT
><DD
><P
>A directory with information about
		process number 1.  Each process has a directory below
		<TT
CLASS="FILENAME"
>/proc</TT
> with the name being its process
		identification number.	</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/cpuinfo</TT
></B
></DT
><DD
><P
>Information about the processor,
		such as its type, make, model, and performance.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/devices</TT
></B
></DT
><DD
><P
>List of device drivers configured into the
		currently running kernel.  </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/dma</TT
></B
></DT
><DD
><P
>Shows which DMA channels are being used
		at the moment.	</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/filesystems</TT
></B
></DT
><DD
><P
>Filesystems configured into the kernel.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/interrupts</TT
></B
></DT
><DD
><P
>Shows which interrupts are
		in use, and how many of each there have been.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/ioports</TT
></B
></DT
><DD
><P
>Which I/O ports are in use at the moment.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/kcore</TT
></B
></DT
><DD
><P
>An image of the physical memory of
		the system.  This is exactly the same size as your
		physical memory, but does not really take up that much
		memory; it is generated on the fly as programs access it.
		(Remember: unless you copy it elsewhere, nothing under
		<TT
CLASS="FILENAME"
>/proc</TT
> takes up any disk space
		at all.)  </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/kmsg</TT
></B
></DT
><DD
><P
>Messages output by the kernel.
		These are also routed to <B
CLASS="COMMAND"
>syslog</B
>.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/ksyms</TT
></B
></DT
><DD
><P
>Symbol table for the kernel.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/loadavg</TT
></B
></DT
><DD
><P
>The `load average' of the system; three
		meaningless indicators of how much work the system has
		to do at the moment.  </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/meminfo</TT
></B
></DT
><DD
><P
>Information about memory usage, both
		physical and swap.  </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/modules</TT
></B
></DT
><DD
><P
>Which kernel modules are loaded at
		the moment.  </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/net</TT
></B
></DT
><DD
><P
>Status information about network
		protocols.  </P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/self</TT
></B
></DT
><DD
><P
>A symbolic link to the process
		directory of the program that is looking at
		<TT
CLASS="FILENAME"
>/proc</TT
>.  When two processes look at
		<TT
CLASS="FILENAME"
>/proc</TT
>, they get different links.
		This is mainly a convenience to make it easier
		for programs to get at their process directory.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/stat</TT
></B
></DT
><DD
><P
>Various statistics about the system, such
		as the number of page faults since the system was booted.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/uptime</TT
></B
></DT
><DD
><P
>The time the system has been up.
		</P
></DD
><DT
><B
><TT
CLASS="FILENAME"
>/proc/version</TT
></B
></DT
><DD
><P
>The kernel version.
		</P
></DD
></DL
></DIV
></P
><P
>Note that while the above files tend to be easily readable
	text files, they can sometimes be formatted in a way that is not
	easily digestible.  There are many commands that do little more than
	read the above files and format them for easier understanding. For
	example, the <B
CLASS="COMMAND"
>free</B
>program reads
	<TT
CLASS="FILENAME"
>/proc/meminfo</TT
> converts the amounts given in
	bytes to kilobytes (and adds a little more information, as
	well).</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DEVICE-LIST"
></A
>Chapter 4. Hardware, Devices, and Tools</H1
><A
NAME="AEN1797"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"Knowledge speaks, but wisdom listens."</SPAN
> 
	Jimi Hendrix</P
></BLOCKQUOTE
><P
>This chapter gives an overview of what a device file is, and how to
create one.  The canonical list of device files is
<TT
CLASS="FILENAME"
>/usr/src/linux/Documentation/devices.txt</TT
>
 if you have
the Linux kernel source code installed on your system.  The devices listed
here are correct as of kernel version 2.6.8.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="HWUTILS"
></A
>4.1. Hardware Utilities</H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="MAKEDEV"
></A
>4.1.1. The <B
CLASS="COMMAND"
>MAKEDEV</B
> Script</H2
><P
>Most device files will already be created and will be there
	ready to use after you install your Linux system.  If by some chance
	you need to create one which is not provided then you should first
	try to use the <B
CLASS="COMMAND"
>MAKEDEV</B
> script.  This script is
	usually located in <TT
CLASS="FILENAME"
>/dev/MAKEDEV</TT
> but might also
	have a copy (or a symbolic link) in
	<TT
CLASS="FILENAME"
>/sbin/MAKEDEV</TT
>.  If it turns out not to be in
	your path then you will need to specify the path to it
	explicitly.</P
><P
>In general the command is used as:
	
	<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>/dev/MAKEDEV -v ttyS0</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>create ttyS0   c 4 64 root:dialout 0660</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>

	This will create the device file <TT
CLASS="FILENAME"
>/dev/ttyS0</TT
>
	
	with major node 4 and minor node 64 as a character device with
	access permissions 0660 with owner root and group dialout.</P
><P
><TT
CLASS="FILENAME"
>ttyS0</TT
> is a serial port.  The major and
	minor node numbers are numbers understood by the kernel.  The kernel
	refers to hardware devices as numbers, this would be very difficult
	for us to remember, so we use filenames.  Access permissions of 0660
	means read and write permission for the owner (root in this case)
	and read and write permission for members of the group (dialout in 
	this case) with no access for anyone else.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="MKNOD"
></A
>4.1.2. The <B
CLASS="COMMAND"
>mknod</B
> command</H2
><P
><B
CLASS="COMMAND"
>MAKEDEV</B
> is the preferred way of creating
	device files which are not present.  However sometimes the
	<B
CLASS="COMMAND"
>MAKEDEV</B
> script will not know about the device
	file you wish to create.  This is where the <B
CLASS="COMMAND"
>mknod</B
>
	command comes in.  In order to use <B
CLASS="COMMAND"
>mknod</B
> you need
	to know the major and minor node numbers for the device you wish to
	create.  The <TT
CLASS="FILENAME"
>devices.txt</TT
> file in the kernel
	source documentation is the canonical source of this
	information.</P
><P
>To take an example, let us suppose that our version of the
	<B
CLASS="COMMAND"
>MAKEDEV</B
> script does not know how to create the
	<TT
CLASS="FILENAME"
>/dev/ttyS0</TT
> device file.  We need 
	to use <B
CLASS="COMMAND"
>mknod</B
> to create it.  We know from looking at the
	<TT
CLASS="FILENAME"
>devices.txt</TT
> that it should be a character
	device with major number 4 and minor number 64.  So we now know all
	we need to create the file.

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>mknod /dev/ttyS0 c 4 64</B
></TT
>
	<TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>chown root.dialout /dev/ttyS0</B
></TT
>
	<TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>chmod 0644 /dev/ttyS0</B
></TT
>
	<TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>ls -l /dev/ttyS0</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>	crw-rw----   1 root dialout    4,   64 Oct 23 18:23 /dev/ttyS0
	</TT
> 
	</PRE
></FONT
></TD
></TR
></TABLE
>

	As you can see, many more steps are required to create the file.  In
	this example you can see the process required however.  It is
	unlikely in the extreme that the ttyS0 file would not be provided by
	the <B
CLASS="COMMAND"
>MAKEDEV</B
> script, but it suffices to illustrate
	the point.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="LSPCI"
></A
>4.1.3. The <B
CLASS="COMMAND"
>lspci</B
>  command</H2
><P
>lspci</P
><P
>TO BE ADDED</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="LSDEV"
></A
>4.1.4. The <B
CLASS="COMMAND"
>lsdev</B
>  command</H2
><P
>lsdev</P
><P
>TO BE ADDED</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="LSUSB"
></A
>4.1.5. The <B
CLASS="COMMAND"
>lsusb</B
>  command</H2
><P
>lsusb</P
><P
>TO BE ADDED</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="LSRAID"
></A
>4.1.6. The <B
CLASS="COMMAND"
>lsraid</B
>  command</H2
><P
>lsraid</P
><P
>TO BE ADDED</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="HDPARM"
></A
>4.1.7. The <B
CLASS="COMMAND"
>hdparm</B
>  command</H2
><P
>hdparm</P
><P
>TO BE ADDED</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="MORE-HWRESOURCES"
></A
>4.1.8. More Hardware Resources</H2
><P
>More information on what hardware resources the kernel is using
	can be found in the <TT
CLASS="FILENAME"
>/proc</TT
> directory.  Refer to 
	<A
HREF="#PROC-FS"
>Section 3.7</A
> in chapter 3.
	</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN1926"
></A
>4.2. Kernel Modules</H1
><P
>This section will discuss kernel modules.</P
><P
>TO BE ADDED</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1933"
></A
>4.2.1. lsmod</H2
><P
>lsmod</P
><P
>TO BE ADDED</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1944"
></A
>4.2.2. insmod</H2
><P
>insmod</P
><P
>TO BE ADDED</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1955"
></A
>4.2.3. depmod</H2
><P
>depmod</P
><P
>TO BE ADDED</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1966"
></A
>4.2.4. rmmod</H2
><P
>rmmod</P
><P
>TO BE ADDED</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1977"
></A
>4.2.5. modprobe</H2
><P
>modprobe</P
><P
>TO BE ADDED</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DISK-USAGE"
></A
>Chapter 5. Using Disks and Other Storage Media</H1
><A
NAME="AEN1990"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"On a clear disk you can seek forever.
	"</SPAN
></P
></BLOCKQUOTE
><P
>When you install or upgrade your system, you need to do a
        fair amount of work on your disks.  You have to make filesystems on
	your disks so that files can be stored on them and reserve
        space for the different parts of your system.</P
><P
>This chapter explains all these initial activities.  Usually,
        once you get your system set up, you won't have to go through the
	work again, except for using floppies.  You'll need to come back to
	this chapter if you add a new disk or want to fine-tune your disk 
	usage.</P
><P
>&#13;        </P
><P
>The basic tasks in administering disks are:

	<P
></P
><UL
><LI
><P
>        Format your disk.  This does various things to prepare it for use,
	such as checking for bad sectors.  (Formatting is nowadays
	not necessary for most hard disks.)</P
></LI
><LI
><P
>        Partition a hard disk, if you want to use it for several activities
	that aren't supposed to interfere with one another. One reason for
	partitioning is to store different operating systems on the same
	disk.  Another reason is to keep user files separate from system
	files, which simplifies back-ups and helps protect the system files
	from corruption.
	</P
></LI
><LI
><P
>        Make a filesystem (of a suitable type) on each disk or partition.
	The disk means nothing to Linux until you make a filesystem; then
	files can be created and accessed on it.
	</P
></LI
><LI
><P
>        Mount different filesystems to form a single tree structure, either
	automatically, or manually as needed.  (Manually mounted filesystems
	usually need to be unmounted manually as well.)
	</P
></LI
></UL
>

	</P
><P
><A
HREF="#MEMORY-MANAGEMENT"
>Chapter 6</A
> contains information
	about virtual memory and disk caching, of which you also need
	to be aware when using disks.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="BLOCK-CHAR-DEV"
></A
>5.1. Two kinds of devices</H1
><P
>UNIX, and therefore Linux, recognizes two different
	kinds of device: random-access block devices (such as disks),
	 and
	character devices (such as tapes and serial lines)
	, some of which
	may be serial, and some random-access.  Each supported device is
	represented in the filesystem as a <I
CLASS="GLOSSTERM"
>device file</I
>. 
	  When you read or write a device file, the data
	comes from or goes to the device it represents.  This way no special
	programs (and no special application programming methodology, such
	as catching interrupts or polling a serial port) are necessary to
	access devices; for example, to send a file to the printer, one
	could just say

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>cat filename &#62; /dev/lp1</B
></TT
>
<TT
CLASS="PROMPT"
>$</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	and the contents of the file are printed (the file must, of course,
	be in a form that the printer understands).  However, since it is
	not a good idea to have several people cat their files to the
	printer at the same time, one usually uses a special program to send
	the files to be printed (usually <B
CLASS="COMMAND"
>lpr</B
>
	). This
	program makes sure that only one file is being printed at a time,
	and will automatically send files to the printer as soon as it
	finishes with the previous file.  Something similar is needed for
	most devices.  In fact, one seldom needs to worry
	about device files at all.</P
><P
>Since devices show up as files in the filesystem (in the
	<TT
CLASS="FILENAME"
>/dev</TT
> 
	directory), it is easy to see just what
	device files exist, using <B
CLASS="COMMAND"
>ls</B
> or another suitable
	command.  In the output of <B
CLASS="COMMAND"
>ls -l</B
>, the first
	column contains the type of the file and its permissions.  For
	example, inspecting a serial device might give

	<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>ls -l /dev/ttyS0</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>	crw-rw-r--    1 root     dialout    4,  64 Aug 19 18:56 /dev/ttyS0
	</TT
>
	<TT
CLASS="PROMPT"
>$</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>

	The first character in the first column, i.e.,
	`<TT
CLASS="LITERAL"
>c</TT
>' in <TT
CLASS="LITERAL"
>crw-rw-rw-</TT
> above, tells
	an informed user the type of the file, in this case a character
	device.  For ordinary files, the first character is
	`<TT
CLASS="LITERAL"
>-</TT
>', for directories it is
	`<TT
CLASS="LITERAL"
>d</TT
>', and for block devices
	`<TT
CLASS="LITERAL"
>b</TT
>'; see the <B
CLASS="COMMAND"
>ls</B
> man page
	for further information.</P
><P
>Note that usually all device files exist even though the
	device itself might be not be installed.  So just because you have a
	file <TT
CLASS="FILENAME"
>/dev/sda</TT
>, it doesn't mean that you really
	do have an SCSI hard disk.  Having all the device files makes the
	installation programs simpler, and makes it easier to add new
	hardware (there is no need to find out the correct parameters
	for and create the device files for the new device).</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="HARD-DISK"
></A
>5.2. Hard disks</H1
><P
>This subsection introduces terminology related to hard
	disks.	If you already know the terms and concepts, you can skip
	this subsection.</P
><P
>See <A
HREF="#HD-SCHEMATIC"
>Figure 5-1</A
> for a schematic picture
	of the important parts in a hard disk.	A hard disk consists of one
	or more circular aluminum <I
CLASS="GLOSSTERM"
>platters</I
>\
	,
	of which either or both <I
CLASS="GLOSSTERM"
>surfaces</I
> are coated
	with a magnetic substance used for recording the data.	For each
	surface, there is a <I
CLASS="GLOSSTERM"
>read-write head</I
> that
	examines or alters the recorded data.  The platters rotate on a
	common axis; typical rotation speed is 5400 or 7200 rotations per
	minute, although high-performance hard disks have higher speeds and
	older disks may have lower speeds. The heads move along the radius
	of the platters; this movement combined with the rotation of the
	platters allows the head to access all parts of the surfaces.</P
><P
>The processor (CPU) and the actual disk communicate through a
	<I
CLASS="GLOSSTERM"
>disk controller</I
>
	.  This relieves the rest of
	the computer from knowing how to use the drive, since the
	controllers for different types of disks can be made to use the same
	interface towards the rest of the computer.  Therefore, the computer
	can say just ``hey disk, give me what I want'', instead of a long
	and complex series of electric signals to move the head to the
	proper location and waiting for the correct position to come under
	the head and doing all the other unpleasant stuff necessary. (In
	reality, the interface to the controller is still complex, but much
	less so than it would otherwise be.) The controller may also do
	other things, such as caching, or automatic bad sector 
	replacement.</P
><P
>The above is usually all one needs to understand about the
	hardware.  There are also other things, such as the motor that
	rotates the platters and moves the heads, and the electronics that
	control the operation of the mechanical parts, but they are mostly
	not relevant for understanding the working principles of a hard 
	disk.</P
><P
>The surfaces are usually divided into concentric rings,
	called <I
CLASS="GLOSSTERM"
>tracks</I
>, and these in turn are divided
	into <I
CLASS="GLOSSTERM"
>sectors</I
>.  This division is used to
	specify locations on the hard disk and to allocate disk space to
	files.  To find a given place on the hard disk, one might say
	``surface 3, track 5, sector 7''.  Usually the number of sectors is
	the same for all tracks, but some hard disks put more sectors in
	outer tracks (all sectors are of the same physical size, so more of
	them fit in the longer outer tracks). Typically, a sector will hold
	512 bytes of data.  The disk itself
	can't handle smaller amounts of data than one sector.</P
><DIV
CLASS="FIGURE"
><A
NAME="HD-SCHEMATIC"
></A
><P
><B
>Figure 5-1. A schematic picture of a hard disk.</B
></P
><P
><IMG
SRC="hd-schematic.png"></P
></DIV
><P
>Each surface is divided into tracks (and sectors) in
	the same way.  This means that when the head for one surface is on a
	track, the heads for the other surfaces are also on the
	corresponding tracks.  All the corresponding tracks taken together
	are called a <I
CLASS="GLOSSTERM"
>cylinder</I
>.	It takes time to
	move the heads from one track (cylinder) to another, so by placing
	the data that is often accessed together (say, a file) so that it is
	within one cylinder, it is not necessary to move the heads to read
	all of it.  This improves performance. It is not always possible to
	place files like this; files that are stored in several places on
	the disk are called
	<I
CLASS="GLOSSTERM"
>fragmented</I
>.</P
><P
>The number of surfaces (or heads, which is the same thing),
	cylinders, and sectors vary a lot; the specification of the number
	of each is called the <I
CLASS="GLOSSTERM"
>geometry</I
> of a hard
	disk.  The geometry is usually stored in a special, battery-powered
	memory location called the <I
CLASS="GLOSSTERM"
>CMOS RAM</I
>
	, from
	where the operating system can fetch it during bootup or driver 
	initialization.</P
><P
>Unfortunately, the BIOS
	has a design limitation, which makes it impossible to specify a
	track number that is larger than 1024 in the CMOS RAM, which is too
	little for a large hard disk.  To overcome this, the hard disk
	controller lies about the geometry, and <I
CLASS="GLOSSTERM"
>translates the
	addresses</I
> given by the computer into something that fits
	reality.  For example, a hard disk might have 8 heads, 2048 tracks,
	and 35 sectors per track.
	Its controller could lie to the computer and claim that it has 16
	heads, 1024 tracks, and 35 sectors per track, thus not exceeding the
	limit on tracks, and translates the address that the computer gives
	it by halving the head number, and doubling the track number.  The
	mathematics can be more complicated in reality, because the numbers
	are not as nice as here (but again, the details are not relevant for
	understanding the principle). This translation distorts the
	operating system's view of how the disk is organized, thus making it
	impractical to use the all-data-on-one-cylinder trick to boost 
	performance.</P
><P
>The translation is only a problem for IDE disks.	SCSI disks
	use a sequential sector number (i.e., the controller translates a
	sequential sector number to a head, cylinder, and sector triplet),
	and a completely different method for the CPU to talk with the
	controller, so they are insulated from the problem. Note, however,
	that the computer might not know the real geometry of an SCSI disk 
	either.</P
><P
>Since Linux often will not know the real geometry of a disk,
	its filesystems don't even try to keep files within a single
	cylinder.  Instead, it tries to assign sequentially numbered sectors
	to files, which almost always gives similar performance. The issue
	is further complicated by on-controller caches, and automatic 
	prefetches done by the controller.</P
><P
>Each hard disk is represented by a separate device
	file.  There can (usually) be only two or four IDE hard disks. These
	are known as <TT
CLASS="FILENAME"
>/dev/hda</TT
>,
	<TT
CLASS="FILENAME"
>/dev/hdb</TT
>, 
	<TT
CLASS="FILENAME"
>/dev/hdc</TT
>, and
	<TT
CLASS="FILENAME"
>/dev/hdd</TT
>, 
	respectively.  SCSI hard disks are
	known as <TT
CLASS="FILENAME"
>/dev/sda</TT
>,
	<TT
CLASS="FILENAME"
>/dev/sdb</TT
>, and so on.  Similar naming
	conventions exist for other hard disk types; see <A
HREF="#DEVICE-LIST"
>Chapter 4</A
> for more information.  Note that the device
	files for the hard disks give access to the entire disk, with no
	regard to partitions (which will be discussed below), and it's easy
	to mess up the partitions or the data in them if you aren't careful.
	The disks' device files are usually used only to get access to the
	master boot record (which will also be discussed below).</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SAN"
></A
>5.3. Storage Area Networks - Draft</H1
><P
>A SAN 
        is a dedicated storage network that provides block level
        access to LUNs. A LUN, 
	or logical unit number, is a virtual disk
	provided by the SAN.
        The system administrator the same access and rights to the LUN as if
        it were a disk directly attached to it.  The administrator can partition, and
        format the disk in any means he or she chooses.</P
><P
>Two networking protocols commonly used in a SAN are
        <I
CLASS="GLOSSTERM"
>fibre channel</I
>
	
	 and
        <I
CLASS="GLOSSTERM"
>iSCSI</I
>
	. 
        A fibre channel network is very fast and is not
        burdened by the other network traffic in a company's LAN. However, it's
        very expensive.  Fibre channel cards cost around $1000.00 USD each.  They
        also require special fibre channel switches. </P
><P
>iSCSI is a newer technology that sends SCSI commands over a TCP/IP
        network.  While this method may not be as fast as a Fibre Channel network,
        it does save money by using less expensive network hardware.</P
><P
>More To Be Added</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="NET-ATTACHED"
></A
>5.4. Network Attached Storage - Draft</H1
><P
>A NAS
         uses your companies existing Ethernet network to allow
        access to shared disks.  This is filesystem level access.
        The system administrator does not have the ability to partition or format
        the disks since they are potentially shared by multiple computers. 
	This technology is commonly used to provide multiple workstations 
	access to the same data.</P
><P
>Similar to a SAN, 
        a NAS need to make use of a protocol to allow access
        to it's disks.  With a NAS this is either CIFS/Samba
        , or NFS.</P
><P
>Traditionally CIFS was used with Microsoft Windows networks, and
        NFS was used with UNIX &#38; Linux networks.  However, with Samba, Linux
        machines can also make use of CIFS shares.</P
><P
>Does this mean that your Windows 2003 server or your Linux box
        are NAS servers because they provide access to shared drives over your
        network?  Yes, they are.  You could also purchase a NAS device from a
        number of manufacturers.  These devices are specifically designed to 
	provide high speed access to data.</P
><P
>More To Be Added</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="NET-FILE-SYS"
></A
>5.4.1. NFS</H2
><P
>TO BE ADDED</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="CIFS"
></A
>5.4.2. CIFS</H2
><P
>TO BE ADDED</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="FLOPPIES"
></A
>5.5. Floppies</H1
><P
>A floppy disk 
	consists of a flexible membrane covered on one
	or both sides with similar magnetic substance as a hard disk. The
	floppy disk itself doesn't have a read-write head, that is included
	in the drive.  A floppy corresponds to one platter in a hard disk,
	but is removable and one drive can be used to access different
	floppies, and the same floppy can be read by many drives, whereas
	the hard disk is one indivisible unit.</P
><P
>Like a hard disk, a floppy is divided into tracks and sectors
	(and the two corresponding tracks on either side of a floppy
	form a cylinder), but there are many fewer of them than on a
	hard disk.</P
><P
>A floppy drive can usually use several different types of disks;
	for example, a 3.5 inch drive can use both 720 KB and 1.44 MB disks.
	Since the drive has to operate a bit differently and the operating
	system must know how big the disk is, there are many device files
	for floppy drives, one per combination of drive and disk type.
	Therefore, <TT
CLASS="FILENAME"
>/dev/fd0H1440</TT
> is the first floppy 
	drive (fd0), which must be a 3.5 inch drive, using a 3.5 inch, high
	density disk (H) of size 1440 KB (1440), i.e., a normal 3.5 inch HD
	floppy.
	</P
><P
>The names for floppy drives are complex, however, and Linux
	therefore has a special floppy device type that automatically
	detects the type of the disk in the drive.  It works by trying to
	read the first sector of a newly inserted floppy using different
	floppy types until it finds the correct one. This naturally requires
	that the floppy is formatted first. The automatic devices are called
	<TT
CLASS="FILENAME"
>/dev/fd0</TT
>, 
	<TT
CLASS="FILENAME"
>/dev/fd1</TT
>, and so 
	on.</P
><P
>The parameters the automatic device uses to access a disk can
	also be set using the program <B
CLASS="COMMAND"
>setfdprm</B
>
	.  This can
	be useful if you need to use disks that do not follow any usual
	floppy sizes, e.g., if they have an unusual number of sectors, or if
	the autodetecting for some reason fails and the proper device file is 
	missing.</P
><P
>Linux can handle many nonstandard floppy disk formats
	in addition to all the standard ones.  Some of these require using
	special formatting programs.  We'll skip these disk types for now,
	but in the mean time you can examine the
	<TT
CLASS="FILENAME"
>/etc/fdprm</TT
> file.  It specifies the settings
	that <B
CLASS="COMMAND"
>setfdprm</B
> recognizes.</P
><P
>The operating system must know when a disk has been changed in
	a floppy drive, for example, in order to avoid using cached data
	from the previous disk.  Unfortunately, the signal line that is used
	for this is sometimes broken, and worse, this won't always be
	noticeable when using the drive from within MS-DOS. If you are
	experiencing weird problems using floppies, this might be the
	reason.  The only way to correct it is to repair the floppy drive.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="CDROM"
></A
>5.6. CD-ROMs</H1
><P
>A CD-ROM drive uses an 
	optically read, plastic coated disk.
	The information is recorded on the surface of the disk
	in small `holes' aligned along a spiral from the center to the edge.
	The drive directs a laser beam along the spiral to read the disk.
	When the laser hits a hole, the laser is reflected in one way; when
	it hits smooth surface, it is reflected in another way.  This makes
	it easy to code bits, and therefore information.  The rest is easy, 
	mere mechanics.</P
><P
>CD-ROM drives are slow compared to hard disks.  Whereas a
	typical hard disk will have an average seek time less than 15
	milliseconds, a fast CD-ROM drive can use tenths of a second for
	seeks.  The actual data transfer rate is fairly high at hundreds of
	kilobytes per second.  The slowness means that CD-ROM drives are not
	as pleasant to use as hard disks (some Linux distributions provide
	`live' filesystems on CD-ROMs, making it unnecessary to copy the
	files to the hard disk, making installation easier and saving a lot
	of hard disk space), although it is still possible.  For installing
	new software, CD-ROMs are very good, since maximum speed is not
	essential during installation.</P
><P
>There are several ways to arrange data on a CD-ROM.  The most
	popular one is specified by the international standard ISO 9660
	.
	This standard specifies a very minimal filesystem, which is even
	more crude than the one MS-DOS uses.  On the other hand, it is so
	minimal that every operating system should be able to map it to its 
	native system.</P
><P
>For normal UNIX use, the ISO 9660 filesystem is not usable, so
	an extension to the standard has been developed, called the Rock
	Ridge extension.  Rock Ridge 
	allows longer filenames, symbolic
	links, and a lot of other goodies, making a CD-ROM look more or less
	like any contemporary UNIX filesystem. Even better, a Rock Ridge
	filesystem is still a valid ISO 9660 filesystem, making it usable by
	non-UNIX systems as well. Linux supports both ISO 9660 and the Rock
	Ridge extensions;  the extensions are recognized and used 
	automatically.</P
><P
>The filesystem is only half the battle, however.  Most CD-ROMs 
	contain data that requires a special program to access, and most of
	these programs do not run under Linux (except, possibly, under
	dosemu, the Linux MS-DOS emulator, or wine, the Windows emulator.
	</P
><P
>Ironically perhaps, wine actually stands for ``Wine Is Not an 
	Emulator''.  
	Wine, more strictly, is an API (Application Program 
	Interface) replacement. Please see the wine documentation at 
	<A
HREF="http://www.winehq.com/"
TARGET="_top"
>http://www.winehq.com</A
>
	for more information.</P
><P
>There is also VMWare, a commercial product, which emulates
	an entire x86 machine in software.  See the VMWare website, 
	<A
HREF="http://www.vmware.com/"
TARGET="_top"
>http://www.vmware.com</A
>
	for more information.</P
><P
>A CD-ROM drive is accessed via the corresponding device file.
	There are several ways to connect a CD-ROM drive to the computer:
	via SCSI, via a sound card, or via EIDE.  The hardware hacking
	needed to do this is outside the scope of this book, but the
	type of connection decides the device file.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="TAPES"
></A
>5.7. Tapes</H1
><P
>A tape drive uses a tape, similar
	to cassettes used for music.  A tape is serial in nature, which
	means that in order to get to any given part of it, you first have
	to go through all the parts in between.  A disk can be accessed
	randomly, i.e., you can jump directly to any place on the disk.
	The serial access of tapes makes them slow.</P
><P
>On the other hand, tapes are relatively cheap to make,
	since they do not need to be fast.  They can also easily be made
	quite long, and can therefore contain a large amount of data. This
	makes tapes very suitable for things like archiving and backups,
	which do not require large speeds, but benefit from
	low costs and large storage capacities.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="FORMATTING"
></A
>5.8. Formatting</H1
><P
><I
CLASS="GLOSSTERM"
>Formatting</I
>
	 is the process of writing marks 
	on the magnetic media that are used to mark tracks and sectors.
	Before a disk is formatted, its magnetic surface is a complete mess
	of magnetic signals.  When it is formatted, some order is brought
	into the chaos by essentially drawing lines where the tracks go, and
	where they are divided into sectors.  The actual details are not
	quite exactly like this, but that is irrelevant.  What is important
	is that a disk cannot be used unless it has been formatted.</P
><P
>The terminology is a bit confusing here: in MS-DOS and MS 
	Windows, the word formatting is used to cover also the process of
	creating a filesystem (which will be discussed below).  There, the
	two processes are often combined, especially for floppies.  When the
	distinction needs to be made, the real formatting is called
	<I
CLASS="GLOSSTERM"
>low-level formatting</I
>, while making the 
	filesystem is called <I
CLASS="GLOSSTERM"
>high-level formatting</I
>
	.
	In UNIX circles, the two are called formatting and making a
	filesystem, so that's what is used in this book as well.</P
><P
>For IDE and some SCSI disks the formatting is actually
	done at the factory and doesn't need to be repeated; hence most
	people rarely need to worry about it.  In fact, formatting a hard
	disk can cause it to work less well, for example because a disk
	might need to be formatted in some very special way to
	allow automatic bad sector replacement to work.</P
><P
>Disks that need to be or can be formatted often require a
	special program anyway, because the interface to the formatting
	logic inside the drive is different from drive to drive. The
	formatting program is often either on the controller BIOS, or is
	supplied as an MS-DOS program; neither of these can easily
	be used from within Linux.</P
><P
>During formatting one might encounter bad spots on the
	disk, called <I
CLASS="GLOSSTERM"
>bad blocks</I
>
	 or <I
CLASS="GLOSSTERM"
>bad sectors</I
>.
	These are sometimes handled by the drive
	itself, but even then, if more of them develop, something needs to
	be done to avoid using those parts of the disk.  The logic to do
	this is built into the filesystem; how to add the information into
	the filesystem is described below.  Alternatively, one might create
	a small partition that covers just the bad part of the disk; this
	approach might be a good idea if the bad spot is very large, since
	filesystems can sometimes have trouble with very large bad areas.</P
><P
>Floppies are formatted with <B
CLASS="COMMAND"
>fdformat</B
>
	.  The 
	floppy device file to use is given as the parameter.  For example,
	the following command would format a high density, 3.5 inch floppy
	in the first floppy drive:

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>fdformat /dev/fd0H1440</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Double-sided, 80 tracks, 18 sec/track. Total capacity 
	1440 kB.</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Formatting ... done</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Verifying ... done</TT
>
	<TT
CLASS="PROMPT"
>$</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>

	Note that if you want to use an autodetecting device (e.g.,
	<TT
CLASS="FILENAME"
>/dev/fd0</TT
>),
        you <EM
>must</EM
> set 
	the parameters of the device with <B
CLASS="COMMAND"
>setfdprm</B
>
	 first.
	To achieve the same effect as above, one would have to do the
	following:

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>setfdprm /dev/fd0 1440/1440</B
></TT
>
	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>fdformat /dev/fd0</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Double-sided, 80 tracks, 18 sec/track. Total capacity 
	1440 KB.</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Formatting ... done</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Verifying ... done</TT
>
	<TT
CLASS="PROMPT"
>$</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>

	It is usually more convenient to choose the correct device file that
	matches the type of the floppy.  Note that it is unwise to format
	floppies to contain more information than what they are
	designed for.</P
><P
><B
CLASS="COMMAND"
>fdformat</B
>also validate the floppy, 
	i.e., check it for bad blocks.  It will try a bad block several
	times (you can usually hear this, the drive noise changes
	dramatically). If the floppy is only marginally bad (due to dirt on
	the read/write head, some errors are false signals),
	<B
CLASS="COMMAND"
>fdformat</B
> won't complain, but a real error will
	abort the validation process. The kernel will print log messages for
	each I/O error it finds; these will go to the console or, if
	<B
CLASS="COMMAND"
>syslog</B
> is being used, to the file
	<TT
CLASS="FILENAME"
>/var/log/messages</TT
>.  
	<B
CLASS="COMMAND"
>fdformat</B
>
	itself won't tell where the error is (one usually doesn't care,
	floppies are cheap enough that a bad one is automatically thrown
	away).

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>fdformat /dev/fd0H1440</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Double-sided, 80 tracks, 18 sec/track. Total capacity 
	1440 KB.</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Formatting ... done</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Verifying ... read: Unknown error</TT
>
	<TT
CLASS="PROMPT"
>$</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>

	The <B
CLASS="COMMAND"
>badblocks</B
> command can be used to search any 
	disk or partition for bad blocks (including a floppy).  It does not
	format the disk, so it can be used to check even existing
	filesystems.  The example below checks a 3.5 inch floppy with two
	bad blocks.

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>badblocks /dev/fd0H1440 1440</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>718</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>719</TT
>
	<TT
CLASS="PROMPT"
>$</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>

	<B
CLASS="COMMAND"
>badblocks</B
> outputs the block numbers of the bad
	blocks it finds.  Most filesystems can avoid such bad blocks. They
	maintain a list of known bad blocks, which is initialized when the
	filesystem is made, and can be modified later.	The initial search
	for bad blocks can be done by the <B
CLASS="COMMAND"
>mkfs</B
>
	 command
	(which initializes the filesystem), but later checks should be done
	with <B
CLASS="COMMAND"
>badblocks</B
> and the new blocks should be added
	with <B
CLASS="COMMAND"
>fsck</B
>.	We'll describe
	<B
CLASS="COMMAND"
>mkfs</B
>
	and <B
CLASS="COMMAND"
>fsck</B
> later.</P
><P
>Many modern disks automatically notice bad blocks, and attempt
	to fix them by using a special, reserved good block instead. This is
	invisible to the operating system.  This feature should be
	documented in the disk's manual, if you're curious if it is
	happening.  Even such disks can fail, if the number of bad blocks
	grows too large, although chances are that by then the disk
	will be so rotten as to be unusable.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="PARTITIONS"
></A
>5.9. Partitions</H1
><P
>A hard disk can be divided into several
	<I
CLASS="GLOSSTERM"
>partitions</I
>.  Each partition functions as if
	it were a separate hard disk.  The idea is that if you have one hard
	disk, and want to have, say, two operating systems on it, you can
	divide the disk into two partitions.  Each operating system uses its
	partition as it wishes and doesn't touch the other ones.  This way
	the two operating systems can co-exist peacefully on the same hard
	disk. Without partitions one would have to buy a hard disk for each 
	operating system.</P
><P
>Floppies are not usually partitioned. There is no technical reason
	against this, but since they're so small, partitions would be useful
	only very rarely.  CD-ROMs are usually also not partitioned, since
	it's easier to use them as one big disk, and there is seldom a need
	to have several operating systems on one.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="MBR"
></A
>5.9.1. The MBR, boot sectors and partition table</H2
><P
>The information about how a hard disk has been partitioned
	is stored in its first sector (that is, the first sector of the
	first track on the first disk surface).  The first sector is the
	<I
CLASS="GLOSSTERM"
>master boot record</I
> (MBR) of the disk; this is
	the sector that the BIOS reads in and starts when the machine is
	first booted.  The master boot record contains a small program that
	reads the partition table, checks which partition is active (that
	is, marked bootable), and reads the first sector of that partition,
	the partition's <I
CLASS="GLOSSTERM"
>boot sector</I
> (the MBR is also
	a boot sector, but it has a special status and therefore a special
	name).  This boot sector contains another small program that reads
	the first part of the operating system stored on that partition
	(assuming it is bootable), and then starts it.</P
><P
>The partitioning scheme is not built into the hardware, or
	even into the BIOS.  It is only a convention that many operating
	systems follow.  Not all operating systems do follow it, but they
	are the exceptions.  Some operating systems support partitions, but
	they occupy one partition on the hard disk, and use their internal
	partitioning method within that partition.  The latter type exists
	peacefully with other operating systems (including Linux), and does
	not require any special measures, but an operating system that
	doesn't support partitions cannot co-exist on the same disk with any 
	other operating system.</P
><P
>As a safety precaution, it is a good idea to write down the
	partition table on a piece of paper, so that if it ever corrupts you
	don't have to lose all your files.  (A bad partition table can be
	fixed with <B
CLASS="COMMAND"
>fdisk</B
>).  
	The relevant information is
	given by the <B
CLASS="COMMAND"
>fdisk -l</B
> command:

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>fdisk -l /dev/hda</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Disk /dev/hda: 15 heads, 57 sectors, 790 cylinders</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Units = cylinders of 855 * 512 bytes</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>   Device Boot  Begin   Start     End  Blocks   Id  System</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>/dev/hda1           1       1      24   10231+  82  Linux swap</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>/dev/hda2          25      25      48   10260   83  Linux native</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>/dev/hda3          49      49     408  153900   83  Linux native</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>/dev/hda4         409     409     790  163305    5  Extended</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>/dev/hda5         409     409     744  143611+  83  Linux native</TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>/dev/hda6         745     745     790   19636+  83  Linux native</TT
>
	<TT
CLASS="PROMPT"
>$</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXTENDED-LOGICAL-PART"
></A
>5.9.2. Extended and logical partitions</H2
><P
>The original partitioning scheme for PC hard disks allowed
	only four partitions.  This quickly turned out to be too little in
	real life, partly because some people want more than four operating
	systems (Linux, MS-DOS, OS/2, Minix, FreeBSD, NetBSD, or Windows/NT,
	to name a few), but primarily because sometimes it is a good idea to
	have several partitions for one operating system.  For example, swap
	space is usually best put in its own partition for Linux instead of
	in the main Linux partition for reasons of speed (see below).</P
><P
>To overcome this design problem, <I
CLASS="GLOSSTERM"
>extended 
	partitions</I
> were invented.  This trick allows
	partitioning a <I
CLASS="GLOSSTERM"
>primary partition</I
>
	 into
	sub-partitions.  The primary partition thus subdivided is the
	<I
CLASS="GLOSSTERM"
>extended partition</I
>; the sub-partitions are
	<I
CLASS="GLOSSTERM"
>logical partitions</I
>.  They behave like primary
	partitions, but are created differently.  There is no speed
	difference between them.  By using an extended partition you can now 
	have up to 15 partitions per disk.</P
><P
>The partition structure of a hard disk might look like that
	in <A
HREF="#HARD-DISK-LAYOUT"
>Figure 5-2</A
>.  The disk is divided into
	three primary partitions, the second of which is divided into two
	logical partitions.  Part of the disk is not partitioned at all.
	The disk as a whole and each primary partition has a boot sector.</P
><DIV
CLASS="FIGURE"
><A
NAME="HARD-DISK-LAYOUT"
></A
><P
><B
>Figure 5-2. A sample hard disk partitioning.</B
></P
><P
><IMG
SRC="hd-layout.png"></P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="PART-TYPES"
></A
>5.9.3. Partition types</H2
><P
>The partition tables (the one in the MBR, and the ones for
	extended partitions) contain one byte per partition that identifies
	the type of that partition.  This attempts to identify the operating
	system that uses the partition, or what it uses it for.  The purpose
	is to make it possible to avoid having two operating systems
	accidentally using the same partition.  However, in reality,
	operating systems do not really care about the partition type byte;
	e.g., Linux doesn't care at all what it is.  Worse, some of them use
	it incorrectly; e.g., at least some versions of DR-DOS ignore the
	most significant bit of the byte, while others don't.</P
><P
>There is no standardization agency to specify what each byte
	value means, but as far as Linux is concerned, here is a list of partition 
	types as per the <B
CLASS="COMMAND"
>fdisk</B
> program.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="COMPUTEROUTPUT"
> 0  Empty           1c  Hidden Win95 FA 70  DiskSecure Mult bb  Boot Wizard hid
 1  FAT12           1e  Hidden Win95 FA 75  PC/IX           be  Solaris boot
 2  XENIX root      24  NEC DOS         80  Old Minix       c1  DRDOS/sec (FAT-
 3  XENIX usr       39  Plan 9          81  Minix / old Lin c4  DRDOS/sec (FAT-
 4  FAT16 &#60;32M      3c  PartitionMagic  82  Linux swap      c6  DRDOS/sec (FAT-
 5  Extended        40  Venix 80286     83  Linux           c7  Syrinx
 6  FAT16           41  PPC PReP Boot   84  OS/2 hidden C:  da  Non-FS data
 7  HPFS/NTFS       42  SFS             85  Linux extended  db  CP/M / CTOS / .
 8  AIX             4d  QNX4.x          86  NTFS volume set de  Dell Utility
 9  AIX bootable    4e  QNX4.x 2nd part 87  NTFS volume set df  BootIt
 a  OS/2 Boot Manag 4f  QNX4.x 3rd part 8e  Linux LVM       e1  DOS access
 b  Win95 FAT32     50  OnTrack DM      93  Amoeba          e3  DOS R/O
 c  Win95 FAT32 (LB 51  OnTrack DM6 Aux 94  Amoeba BBT      e4  SpeedStor
 e  Win95 FAT16 (LB 52  CP/M            9f  BSD/OS          eb  BeOS fs
 f  Win95 Ext'd (LB 53  OnTrack DM6 Aux a0  IBM Thinkpad hi ee  EFI GPT
10  OPUS            54  OnTrackDM6      a5  FreeBSD         ef  EFI (FAT-12/16/
11  Hidden FAT12    55  EZ-Drive        a6  OpenBSD         f0  Linux/PA-RISC b
12  Compaq diagnost 56  Golden Bow      a7  NeXTSTEP        f1  SpeedStor
14  Hidden FAT16 &#60;3 5c  Priam Edisk     a8  Darwin UFS      f4  SpeedStor
16  Hidden FAT16    61  SpeedStor       a9  NetBSD          f2  DOS secondary
17  Hidden HPFS/NTF 63  GNU HURD or Sys ab  Darwin boot     fd  Linux raid auto
18  AST SmartSleep  64  Novell Netware  b7  BSDI fs         fe  LANstep
1b  Hidden Win95 FA 65  Novell Netware  b8  BSDI swap       ff  BBT</TT
></PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="PART-HD"
></A
>5.9.4. Partitioning a hard disk</H2
><P
>There are many programs for creating and removing
	partitions.  Most operating systems have their own, and it can be a
	good idea to use each operating system's own, just in case it does
	something unusual that the others can't. Many of the programs are
	called <B
CLASS="COMMAND"
>fdisk</B
>, including the Linux one, or
	variations thereof.  Details on using the Linux
	<B
CLASS="COMMAND"
>fdisk</B
> given on its man page.  The
	<B
CLASS="COMMAND"
>cfdisk</B
> command is similar to
	<B
CLASS="COMMAND"
>fdisk</B
>, but has a nicer (full screen) user 
	interface.</P
><P
>When using IDE disks, 
	the boot partition (the partition
	with the bootable kernel image files) must be completely within the
	first 1024 cylinders.  This is because the disk is used via the BIOS
	during boot (before the system goes into protected mode), and BIOS
	can't handle more than 1024 cylinders. It is sometimes possible to
	use a boot partition that is only partly within the first 1024
	cylinders.  This works as long as all the files that are read with
	the BIOS are within the first 1024 cylinders.  Since this is
	difficult to arrange, it is <EM
>a very bad idea</EM
> to
	do it; you never know when a kernel update or disk defragmentation
	will result in an unbootable system.  Therefore, make sure your boot
	partition is completely within the first 1024 cylinders.</P
><P
>However, this may no longer be true with newer versions of 
	LILO
	 that support LBA (Logical Block Addressing).  Consult the
	documentation for your distribution to see if it has a version
	of LILO where LBA is supported.</P
><P
>Some newer versions of the BIOS and IDE disks can, in fact,
	handle disks with more than 1024 cylinders.  If you have such a
	system, you can forget about the problem; if you aren't quite
	sure of it, put it within the first 1024 cylinders.</P
><P
>Each partition should have an even number of sectors,
	since the Linux filesystems use a 1 kilobyte block size, i.e., two
	sectors.  An odd number of sectors will result in the last sector
	being unused.  This won't result in any problems, but it is ugly,
	and some versions of <B
CLASS="COMMAND"
>fdisk</B
> will warn about it.</P
><P
>Changing a partition's size usually requires first backing up
	everything you want to save from that partition (preferably the
	whole disk, just in case), deleting the partition, creating new
	partition, then restoring everything to the new partition. If the
	partition is growing, you may need to adjust the sizes (and backup and 
	restore) of the adjoining partitions as well.</P
><P
>Since changing partition sizes is painful, it is preferable to
	get the partitions right the first time, or have an effective and
	easy to use backup system.  If you're installing from a media that
	does not require much human intervention (say, from CD-ROM, as
	opposed to floppies), it is often easy to play with different
	configuration at first. Since you don't already have data to back
	up, it is not so painful to modify partition sizes several times.</P
><P
>There is a program for MS-DOS, called <B
CLASS="COMMAND"
>fips</B
>
	,
	which resizes an MS-DOS partition without requiring the backup and
        restore, but for other filesystems it is still necessary.</P
><P
>The <B
CLASS="COMMAND"
>fips</B
> program is included in most Linux
	distributions.  The commercial partition manager ``Partition Magic'' 
	also has a similar facility but with a nicer interface.  Please do 
	remember that partitioning is dangerous.  Make
	<EM
>sure</EM
> you have a recent backup of any important 
	data before you try changing partition sizes ``on the fly''.  The 
	program <B
CLASS="COMMAND"
>parted</B
> can resize other types of partitions
	as well as MS-DOS, but sometimes in a limited manner.  Consult the 
	<B
CLASS="COMMAND"
>parted</B
> documentation before using it, better safe
	than sorry.
	</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="DEV-FILES-PARTS"
></A
>5.9.5. Device files and partitions</H2
><P
>Each partition and extended partition has its own
	device file.  The naming convention for these files is that a
	partition's number is appended after the name of the whole disk,
	with the convention that 1-4 are primary partitions (regardless of
	how many primary partitions there are) and number greater than 5 are
	logical partitions (regardless of within which primary partition
	they reside).  For example, <TT
CLASS="FILENAME"
>/dev/hda1</TT
> is the
	first primary partition on the first IDE hard disk, and
	<TT
CLASS="FILENAME"
>/dev/sdb7</TT
> is the third extended partition on
	the second SCSI hard disk.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="FILESYSTEMS"
></A
>5.10. Filesystems</H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FS-INTRO"
></A
>5.10.1. What are filesystems?</H2
><P
>A <I
CLASS="GLOSSTERM"
>filesystem</I
> is the methods and
	data structures that an operating system uses to keep track of files
	on a disk or partition; that is, the way the files are organized on
	the disk.  The word is also used to refer to a partition or disk
	that is used to store the files or the type of the filesystem.
	Thus, one might say ``I have two filesystems'' meaning one has two
	partitions on which one stores files, or that one is using the
	``extended filesystem'', meaning the type of the filesystem.</P
><P
>The difference between a disk or partition and the 
	filesystem it contains is important.  A few programs (including,
	reasonably enough, programs that create filesystems) operate
	directly on the raw sectors of a disk or partition; if there is an
	existing file system there it will be destroyed or seriously
	corrupted.  Most programs operate on a filesystem, and therefore
	won't work on a partition that doesn't contain one (or that contains 
	one of the wrong type).</P
><P
>Before a partition or disk can be used as a filesystem, it
	needs to be initialized, and the bookkeeping data structures need to
	be written to the disk.  This process is called
	<I
CLASS="GLOSSTERM"
>making a filesystem</I
>.</P
><P
>Most UNIX filesystem types have a similar general
	structure, although the exact details vary quite a bit. The central
	concepts are <I
CLASS="GLOSSTERM"
>superblock</I
>, <I
CLASS="GLOSSTERM"
>inode</I
>
	, <I
CLASS="GLOSSTERM"
>data block</I
>,
	<I
CLASS="GLOSSTERM"
>directory block</I
> , and <I
CLASS="GLOSSTERM"
>indirection
	block</I
>.  The superblock contains information about the
	filesystem as a whole, such as its size (the exact information here
	depends on the filesystem).  An inode contains all information about
	a file, except its name.  The name is stored in the directory,
	together with the number of the inode. A directory entry consists of
	a filename and the number of the inode which represents the file.
	The inode contains the numbers of several data blocks, which are
	used to store the data in the file.  There is space only for a few
	data block numbers in the inode, however, and if more are needed,
	more space for pointers to the data blocks is allocated dynamically.
	These dynamically allocated blocks are indirect blocks; the name
	indicates that in order to find the data block, one has to find
	its number in the indirect block first.</P
><P
>UNIX filesystems usually allow one to create a
	<I
CLASS="GLOSSTERM"
>hole</I
> in a file (this is done with the 
	<TT
CLASS="FUNCTION"
>lseek()</TT
> system call; check the manual page),
	which means that the filesystem just pretends that at a particular
	place in the file there is just zero bytes, but no actual disk
	sectors are reserved for that place in the file (this means that the
	file will use a bit less disk space). This happens especially often
	for small binaries, Linux shared libraries, some databases, and a
	few other special cases.  (Holes are implemented by storing a
	special value as the address of the data block in the indirect block
	or inode.  This special address means that no data block is
	allocated for that part of the file, ergo, there is a hole in the 
	file.)</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FS-GALORE"
></A
>5.10.2. Filesystems galore</H2
><P
>Linux supports several types of filesystems.  As of this
	writing the most important ones are:

	<DIV
CLASS="GLOSSLIST"
><DL
><DT
><B
>minix</B
></DT
><DD
><P
>The oldest, presumed to be the most 
		reliable, but quite limited in features (some time stamps
		are missing, at most 30 character filenames) and restricted
		in capabilities (at most 64 MB per filesystem).
		</P
></DD
><DT
><B
>xia</B
></DT
><DD
><P
>A modified version of the minix filesystem 
		that lifts the limits on the filenames and filesystem sizes,
		but does not otherwise introduce new features.  It is not
		very popular, but is reported to work very well.
		</P
></DD
><DT
><B
>ext3</B
></DT
><DD
><P
>The ext3 filesystem has all the features of 
		the ext2 filesystem.  The difference is, journaling has been 
		added.  This improves performance and recovery time in case 
		of a system crash.  This has become more popular than ext2.
		</P
></DD
><DT
><B
>ext2</B
></DT
><DD
><P
>The most featureful of the native Linux 
		filesystems.  It is designed to be easily upwards compatible, 
		so that new versions of the filesystem code do not require 
		re-making the existing filesystems.</P
></DD
><DT
><B
>ext</B
></DT
><DD
><P
>An older version of ext2 that wasn't upwards
		compatible.  It is hardly ever used in new installations any
		more, and most people have converted to ext2.
		</P
></DD
><DT
><B
>reiserfs</B
></DT
><DD
><P
>A more robust filesystem.  Journaling is
		used which makes data loss less likely.  Journaling is a
		mechanism whereby a record is kept of transaction which are
		to be performed, or which have been performed.  This allows
		the filesystem to reconstruct itself fairly easily after
		damage caused by, for example, improper
		shutdowns.</P
></DD
><DT
><B
>jfs</B
></DT
><DD
><P
>JFS is a journaled filesystem designed
		by IBM to to work in high performance environments&#62;</P
></DD
><DT
><B
>xfs</B
></DT
><DD
><P
>XFS was originally designed by Silicon Graphics
		to work as a 64-bit journaled filesystem. XFS was also designed
		to maintain high performance with large files and filesystems.
		</P
></DD
></DL
></DIV
></P
><P
>In addition, support for several foreign filesystems exists,
	to make it easier to exchange files with other operating systems.
	These foreign filesystems work just like native ones, except that
	they may be lacking in some usual UNIX features, or have curious
	limitations, or other oddities.

	<DIV
CLASS="GLOSSLIST"
><DL
><DT
><B
>msdos</B
></DT
><DD
><P
>Compatibility with MS-DOS (and OS/2 and
		Windows NT) FAT filesystems.</P
></DD
><DT
><B
>umsdos</B
></DT
><DD
><P
>Extends the msdos filesystem driver under
		Linux to get long filenames, owners, permissions, links, and
		device files. This allows a normal msdos filesystem to be
		used as if it were a Linux one, thus removing the need for a
		separate partition for Linux.</P
></DD
><DT
><B
>vfat</B
></DT
><DD
><P
>This is an extension of the FAT filesystem
		known as FAT32.  It supports larger disk sizes than FAT.
		Most MS Windows disks are vfat.</P
></DD
><DT
><B
>iso9660</B
></DT
><DD
><P
>The standard CD-ROM filesystem; the popular
		Rock Ridge extension to the CD-ROM standard that allows
		longer file names is supported automatically.
		</P
></DD
><DT
><B
>nfs</B
></DT
><DD
><P
>A networked filesystem that allows sharing a
		filesystem between many computers to allow easy access to
		the files from all of them.</P
></DD
><DT
><B
>smbfs</B
></DT
><DD
><P
>A networks filesystem which allows sharing
		of a filesystem with an MS Windows computer.  It is
		compatible with the Windows file sharing protocols.
		</P
></DD
><DT
><B
>hpfs</B
></DT
><DD
><P
>The OS/2 filesystem.
		</P
></DD
><DT
><B
>sysv</B
></DT
><DD
><P
>SystemV/386, Coherent, and Xenix filesystems.
		</P
></DD
><DT
><B
>NTFS</B
></DT
><DD
><P
>The most advanced Microsoft journaled filesystem
		providing faster file access and stability over previous
		Microsoft filesystems. 
		</P
></DD
></DL
></DIV
>
	</P
><P
>The choice of filesystem to use depends on the situation.  If
	compatibility or other reasons make one of the non-native
	filesystems necessary, then that one must be used.  If one can
	choose freely, then it is probably wisest to use ext3, since it has
	all the features of ext2, and is a journaled filesystem.  For more 
	information on filesystems, see <A
HREF="#FS-COMPARE"
>Section 5.10.6</A
>.  You 
	can also read the Filesystems HOWTO located at
	<A
HREF="../../../HOWTO/Filesystems-HOWTO.html"
TARGET="_top"
>	http://www.tldp.org/HOWTO/Filesystems-HOWTO.html</A
></P
><P
>There is also the proc filesystem, usually accessible as
	the <TT
CLASS="FILENAME"
>/proc</TT
> directory, which is not really a
	filesystem at all, even though it looks like one.  The proc
	filesystem makes it easy to access certain kernel data structures,
	such as the process list (hence the name). It makes these data
	structures look like a filesystem, and that filesystem can be
	manipulated with all the usual file tools.  For example, to get a
	listing of all processes one might use the command

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>ls -l /proc</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>total 0
dr-xr-xr-x   4 root     root            0 Jan 31 20:37 1
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 63
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 94
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 95
dr-xr-xr-x   4 root     users           0 Jan 31 20:37 98
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 99
-r--r--r--   1 root     root            0 Jan 31 20:37 devices
-r--r--r--   1 root     root            0 Jan 31 20:37 dma
-r--r--r--   1 root     root            0 Jan 31 20:37 filesystems
-r--r--r--   1 root     root            0 Jan 31 20:37 interrupts
-r--------   1 root     root      8654848 Jan 31 20:37 kcore
-r--r--r--   1 root     root            0 Jan 31 11:50 kmsg
-r--r--r--   1 root     root            0 Jan 31 20:37 ksyms
-r--r--r--   1 root     root            0 Jan 31 11:51 loadavg
-r--r--r--   1 root     root            0 Jan 31 20:37 meminfo
-r--r--r--   1 root     root            0 Jan 31 20:37 modules
dr-xr-xr-x   2 root     root            0 Jan 31 20:37 net
dr-xr-xr-x   4 root     root            0 Jan 31 20:37 self
-r--r--r--   1 root     root            0 Jan 31 20:37 stat
-r--r--r--   1 root     root            0 Jan 31 20:37 uptime
-r--r--r--   1 root     root            0 Jan 31 20:37 
version</TT
>
<TT
CLASS="PROMPT"
>$</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	(There will be a few extra files that don't correspond to
	processes, though.  The above example has been shortened.)</P
><P
>Note that even though it is called a filesystem, no part of 
	the proc filesystem touches any disk.  It exists only in the
	kernel's imagination.  Whenever anyone tries to look at any part of
	the proc filesystem, the kernel makes it look as if the part existed
	somewhere, even though it doesn't.  So, even though there is a
	multi-megabyte <TT
CLASS="FILENAME"
>/proc/kcore</TT
> file, it doesn't
	take any disk space. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="USE-WHICH-FS"
></A
>5.10.3. Which filesystem should be used?</H2
><P
>There is usually little point in using many different
	filesystems.  Currently, ext3 is the most popular filesystem, because
	it is a journaled filesystem. Currently it is probably the wisest 
	choice.  Reiserfs is another popular choice because it to is journaled.
	Depending on the overhead for bookkeeping structures, speed, (perceived) 
	reliability, compatibility, and various other reasons, it may be 
	advisable to use another file system.  This needs to be decided on a 
	case-by-case basis.</P
><P
> A filesystem that uses journaling is also called a journaled
	filesystem.  A journaled filesystem maintains a log, or journal, of
	what has happened on a filesystem.  In the event of a system crash, or
	if your 2 year old son hits the power button like mine loves to do, a 
	journaled filesystem is designed to use the filesystem's logs to recreate 
	unsaved and lost data.  This makes data loss much less likely and 
	will likely become a standard feature in Linux filesystems.  However,
	do not get a false sense of security from this.  Like everything 
	else, errors can arise.  Always make sure to back up your data in the 
	event of an emergency.
	</P
><P
>See <A
HREF="#FS-COMPARE"
>Section 5.10.6</A
> for more details about the 
	features of the different filesystem types.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="CREATE-FS"
></A
>5.10.4. Creating a filesystem</H2
><P
>Filesystems are created, i.e., initialized, with the 
	<B
CLASS="COMMAND"
>mkfs</B
> command.  There is actually a separate
	program for each filesystem type.  <B
CLASS="COMMAND"
>mkfs</B
> is just a
	front end that runs the appropriate program depending on the desired
	filesystem type.  The type is selected with the 
	<TT
CLASS="OPTION"
>-t fstype</TT
> option.</P
><P
>The programs called by <B
CLASS="COMMAND"
>mkfs</B
> have slightly
	different command line interfaces.  The common and most important
	options are summarized below; see the manual pages for more.

	<DIV
CLASS="GLOSSLIST"
><DL
><DT
><B
><TT
CLASS="OPTION"
>-t fstype</TT
></B
></DT
><DD
><P
>		Select the type of the filesystem.
		</P
></DD
><DT
><B
><TT
CLASS="OPTION"
>-c</TT
></B
></DT
><DD
><P
>		 Search for bad blocks and initialize the bad
		block list accordingly.
		</P
></DD
><DT
><B
>-l filename</B
></DT
><DD
><P
>		Read the initial bad block list from the name file.
		</P
></DD
></DL
></DIV
>
	</P
><P
>There are also many programs written to add specific options
	when creating a specific filesystem.  For example 
	<B
CLASS="COMMAND"
>mkfs.ext3</B
> adds a <B
CLASS="COMMAND"
>-b</B
> option to 
	allow the administrator to specify what block size should be used.  
	Be sure to find out if there is a specific program available for the 
	filesystem type you want to use.  For more information on determining
	what block size to use please see
	<A
HREF="#FS-BLOCK-SIZE"
>Section 5.10.5</A
>.</P
><P
>To create an ext2 filesystem on a floppy, one would give the
	following commands:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>fdformat -n /dev/fd0H1440</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>Double-sided, 80 tracks, 18 sec/track. Total capacity 
1440 KB.
Formatting ... done</TT
>
<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>badblocks /dev/fd0H1440 1440 $&#62;$ 
bad-blocks</B
></TT
>
<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>mkfs.ext2 -l bad-blocks 
/dev/fd0H1440</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>mke2fs 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10
360 inodes, 1440 blocks
72 blocks (5.00%) reserved for the super user
First data block=1
Block size=1024 (log=0)
Fragment size=1024 (log=0)
1 block group
8192 blocks per group, 8192 fragments per group
360 inodes per group

Writing inode tables: done
Writing superblocks and filesystem accounting information: 
done</TT
>
<TT
CLASS="PROMPT"
>$</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	First, the floppy was formatted (the <TT
CLASS="OPTION"
>-n</TT
> option
	prevents validation, i.e., bad block checking).  Then bad blocks
	were searched with <B
CLASS="COMMAND"
>badblocks</B
>, with the output
	redirected to a file, <TT
CLASS="FILENAME"
>bad-blocks</TT
>.	Finally, the
	filesystem was created, with the bad block list initialized
	by whatever <B
CLASS="COMMAND"
>badblocks</B
> found.</P
><P
>The <TT
CLASS="OPTION"
>-c</TT
> option could have been used with
	<B
CLASS="COMMAND"
>mkfs</B
> instead of <B
CLASS="COMMAND"
>badblocks</B
>
	and a separate file.  The example below does that.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>mkfs.ext2 -c 
/dev/fd0H1440</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>mke2fs 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10
360 inodes, 1440 blocks
72 blocks (5.00%) reserved for the super user
First data block=1
Block size=1024 (log=0)
Fragment size=1024 (log=0)
1 block group
8192 blocks per group, 8192 fragments per group
360 inodes per group

Checking for bad blocks (read-only test): done
Writing inode tables: done
Writing superblocks and filesystem accounting information: 
done</TT
>
<TT
CLASS="PROMPT"
>$</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	The <TT
CLASS="OPTION"
>-c</TT
> option is more convenient than a separate 
	use of <B
CLASS="COMMAND"
>badblocks</B
>, but
	<B
CLASS="COMMAND"
>badblocks</B
> is necessary for checking
	after the filesystem has been created.</P
><P
>The process to prepare filesystems on hard disks or
	partitions is the same as for floppies, except that the formatting
	isn't needed.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FS-BLOCK-SIZE"
></A
>5.10.5. Filesystem block size</H2
><P
>The block size specifies size that the filesystem will use
        to read and write data.  Larger block sizes will help improve disk 
        I/O performance when using large files, such as databases.  This
        happens because the disk can read or write data for a longer period
        of time before having to search for the next block.</P
><P
>On the downside, if you are going to have a lot of smaller 
        files on that filesystem, like the <TT
CLASS="FILENAME"
>/etc</TT
>, there 
        the potential for a lot of wasted disk space.</P
><P
>For example, if you set your block size to 4096, or 4K, and
        you create a file that is 256 bytes in size, it will still consume
        4K of space on your harddrive.  For one file that may seem trivial,
        but when your filesystem contains hundreds or thousands of files,
        this can add up.</P
><P
>Block size can also effect the maximum supported file size 
	on some filesystems.  This is because many modern filesystem are 
	limited not by block size or file size, but by the number of blocks.  
	Therefore you would be using a 
	"block size * max # of blocks = max block size" formula.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FS-COMPARE"
></A
>5.10.6. Filesystem comparison</H2
><P
>	<DIV
CLASS="TABLE"
><A
NAME="AEN2790"
></A
><P
><B
>Table 5-1. Comparing Filesystem Features</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>FS Name</TH
><TH
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Year Introduced</TH
><TH
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Original OS</TH
><TH
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Max File Size</TH
><TH
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Max FS Size</TH
><TH
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Journaling</TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>FAT16</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>1983</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>MSDOS V2</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>4GB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>16MB to 8GB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>N</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>FAT32</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>1997</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Windows 95</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>4GB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>8GB to 2TB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>N</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>HPFS</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>1988</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>OS/2</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>4GB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>2TB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>N</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>NTFS</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>1993</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Windows NT</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>16EB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>16EB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Y</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>HFS+</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>1998</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Mac OS</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>8EB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>?</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>N</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>UFS2 
		</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>2002</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>FreeBSD</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>512GB to 32PB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>1YB	</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>N</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>ext2</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>1993</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Linux</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>16GB to 2TB4</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>2TB to 32TB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>N</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>ext3</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>1999</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Linux</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>16GB to 2TB4</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>2TB to 32TB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Y</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>ReiserFS3 
		</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>2001</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Linux</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>8TB8</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>16TB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Y</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>ReiserFS4</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>2005</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Linux</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>?</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>?</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Y</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>XFS</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>1994</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>IRIX</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>9EB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>9EB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Y</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>JFS</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>?</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>AIX</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>8EB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>512TB to 4PB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Y</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>VxFS 
		</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>1991</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>SVR4.0</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>16EB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>?</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Y</TD
></TR
><TR
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>ZFS</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>2004</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>Solaris 10</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>1YB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>16EB</TD
><TD
WIDTH="17%"
ALIGN="LEFT"
VALIGN="TOP"
>N</TD
></TR
></TBODY
></TABLE
></DIV
></P
><P
>Legend
        <DIV
CLASS="TABLE"
><A
NAME="AEN2949"
></A
><P
><B
>Table 5-2. Sizes</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Kilobyte - KB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1024 Bytes</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Megabyte - MB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1024 KBs</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Gigabyte - GB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1024 MBs</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Terabyte - TB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1024 GBs</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Petabyte - PB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1024 TBs</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Exabyte - EB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1024 PBs</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Zettabyte - ZB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1024 EBs</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Yottabyte - YB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1024 ZBs</TD
></TR
></TBODY
></TABLE
></DIV
>
	</P
><P
>It should be noted that Exabytes, Zettabytes, and Yottabytes
	are rarely encountered, if ever.  There is a current estimate that 
	the worlds printed material is equal to 5 Exabytes.  Therefore, some
	of these filesystem limitations are considered by many as 
	theoretical.  However, the filesystem software has been written 
	with these capabilities.</P
><P
>For more detailed information you can visit
	<A
HREF="http://en.wikipedia.org/wiki/Comparison_of_file_systems"
TARGET="_top"
>	http://en.wikipedia.org/wiki/Comparison_of_file_systems</A
>.
	</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="MOUNT-AND-UMOUNT"
></A
>5.10.7. Mounting and unmounting</H2
><P
>Before one can use a filesystem, it has to be 
	<I
CLASS="GLOSSTERM"
>mounted</I
>. The operating system then does
	various bookkeeping things to make sure that everything works. Since
	all files in UNIX are in a single directory tree, the mount
	operation will make it look like the contents of the new filesystem
	are the contents of an existing subdirectory in some already mounted
	filesystem.</P
><P
>For example, <A
HREF="#HD-MOUNT-ROOT"
>Figure 5-3</A
> shows three
	separate filesystems, each with their own root directory. When the
	last two filesystems are mounted below <TT
CLASS="FILENAME"
>/home</TT
>
	and <TT
CLASS="FILENAME"
>/usr</TT
>, respectively, on the first 
	filesystem, we can get a single directory tree, as in
	<A
HREF="#HD-MOUNT-ALL"
>Figure 5-4</A
>.</P
><DIV
CLASS="FIGURE"
><A
NAME="HD-MOUNT-ROOT"
></A
><P
><B
>Figure 5-3. Three separate filesystems.</B
></P
><P
><IMG
SRC="hd-mount-separate.png"></P
></DIV
><DIV
CLASS="FIGURE"
><A
NAME="HD-MOUNT-ALL"
></A
><P
><B
>Figure 5-4. <TT
CLASS="FILENAME"
>/home</TT
> and <TT
CLASS="FILENAME"
>/usr</TT
> 
		have been 
		mounted.</B
></P
><P
><IMG
SRC="hd-mount-mounted.png"></P
></DIV
><P
>The mounts could be done as in the following example:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>mount /dev/hda2 /home</B
></TT
>
<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>mount /dev/hda3 /usr</B
></TT
>
<TT
CLASS="PROMPT"
>$</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	The <B
CLASS="COMMAND"
>mount</B
> command takes two arguments. The first
	one is the device file corresponding to the disk or partition
	containing the filesystem.  The second one is the directory below
	which it will be mounted.  After these commands the contents of the
	two filesystems look just like the contents of the
	<TT
CLASS="FILENAME"
>/home</TT
> and <TT
CLASS="FILENAME"
>/usr</TT
>
	directories, respectively.  One would then say that
	<TT
CLASS="FILENAME"
>/dev/hda2</TT
> <I
CLASS="GLOSSTERM"
>is mounted
	on</I
> <TT
CLASS="FILENAME"
>/home</TT
>'', and similarly for
	<TT
CLASS="FILENAME"
>/usr</TT
>.  To look at either filesystem, one would
	look at the contents of the directory on which it has been mounted,
	just as if it were any other directory.  Note the difference between
	the device file, <TT
CLASS="FILENAME"
>/dev/hda2</TT
>, and the mounted-on
	directory, <TT
CLASS="FILENAME"
>/home</TT
>.  The device file gives access
	to the raw contents of the disk, the mounted-on directory gives
	access to the files on the disk.  The mounted-on directory is called
	the <I
CLASS="GLOSSTERM"
>mount point</I
>.</P
><P
>Linux supports many filesystem types.  
	<B
CLASS="COMMAND"
>mount</B
> tries to guess the type of the filesystem.
	You can also use the <TT
CLASS="OPTION"
>-t fstype</TT
> option to specify
	the type directly; this is sometimes necessary, since the heuristics
	<B
CLASS="COMMAND"
>mount</B
> uses do not always work.  For example, to
	mount an MS-DOS floppy, you could use the following command:

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>mount -t msdos /dev/fd0 
	/floppy</B
></TT
>
	<TT
CLASS="PROMPT"
>$</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>
	
	</P
><P
>The mounted-on directory need not be empty, although it
	must exist.  Any files in it, however, will be inaccessible by name
	while the filesystem is mounted.  (Any files that have already been
	opened will still be accessible.  Files that have hard links from
	other directories can be accessed using those names.) There is no
	harm done with this, and it can even be useful.  For instance, some
	people like to have <TT
CLASS="FILENAME"
>/tmp</TT
> and
	<TT
CLASS="FILENAME"
>/var/tmp</TT
> synonymous, and make 
	<TT
CLASS="FILENAME"
>/tmp</TT
> be a symbolic link to
	<TT
CLASS="FILENAME"
>/var/tmp</TT
>.	When the system is booted, before
	the <TT
CLASS="FILENAME"
>/var</TT
> filesystem is mounted, a 
	<TT
CLASS="FILENAME"
>/var/tmp</TT
> directory residing on the root
	filesystem is used instead.  When <TT
CLASS="FILENAME"
>/var</TT
> is
	mounted, it will make the <TT
CLASS="FILENAME"
>/var/tmp</TT
> directory 
	on the root filesystem inaccessible.  If
	<TT
CLASS="FILENAME"
>/var/tmp</TT
> didn't exist on the root filesystem,
	it would be impossible to use temporary files
	before mounting <TT
CLASS="FILENAME"
>/var</TT
>.</P
><P
>If you don't intend to write anything to the filesystem, use
	the <TT
CLASS="OPTION"
>-r</TT
> switch for <B
CLASS="COMMAND"
>mount</B
> to do a 
	<I
CLASS="GLOSSTERM"
>read-only mount</I
>.  This will make the kernel
	stop any attempts at writing to the filesystem, and will also stop
	the kernel from updating file access times in the inodes.  Read-only
	mounts are necessary for unwritable media, e.g., CD-ROMs.</P
><P
>The alert reader has already noticed a slight
	logistical problem.  How is the first filesystem (called the 
	<I
CLASS="GLOSSTERM"
>root filesystem</I
>, because it contains the root
	directory) mounted, since it obviously can't be mounted on another
	filesystem? Well, the answer is that it is done by magic.
	The root filesystem is magically mounted at boot time, and one can
	rely on it to always be mounted. If the root filesystem can't be
	mounted, the system does not boot. The name of the filesystem that
	is magically mounted as root is either compiled into the kernel, or
	set using LILO or <B
CLASS="COMMAND"
>rdev</B
>.</P
><P
>For more information, see the kernel source or the Kernel 
	Hackers' Guide.</P
><P
>The root filesystem is usually first mounted read-only.
	The startup scripts will then run <B
CLASS="COMMAND"
>fsck</B
> to verify
	its validity, and if there are no problems, they will
	<I
CLASS="GLOSSTERM"
>re-mount</I
> it so that writes will also be
	allowed.  <B
CLASS="COMMAND"
>fsck</B
> must not be run on a mounted
	filesystem, since any changes to the filesystem while
	<B
CLASS="COMMAND"
>fsck</B
> is running <EM
>will</EM
> cause
	trouble. Since the root filesystem is mounted read-only while
	it is being checked, <B
CLASS="COMMAND"
>fsck</B
> can fix any problems
	without worry, since the remount operation will flush
	any metadata that the filesystem keeps in memory.</P
><P
>On many systems there are other filesystems that should
	also be mounted automatically at boot time.  These are specified
	in the <TT
CLASS="FILENAME"
>/etc/fstab</TT
> file; see the fstab man
	page for details on the format.  The details of exactly when the
	extra filesystems are mounted depend on many factors, and can be
	configured by each administrator if need be; see
        <A
HREF="#BOOTS-AND-SHUTDOWNS"
>Chapter 8</A
>.</P
><P
>When a filesystem no longer needs to be mounted, it can be
	unmounted with <B
CLASS="COMMAND"
>umount</B
>.
	<B
CLASS="COMMAND"
>umount</B
> takes one argument:
	either the device file or the mount point.  
	For example, to unmount the directories of
	the previous example, one could use the commands

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>umount /dev/hda2</B
></TT
>
<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>umount /usr</B
></TT
>
<TT
CLASS="PROMPT"
>$</TT
></PRE
></FONT
></TD
></TR
></TABLE
>
	</P
><P
>See the man page for further instructions on how to
	use the command.  It is imperative that you always unmount a mounted
	floppy.  <EM
>Don't just pop the floppy out of the
	drive!</EM
> Because of disk caching, the data is not
	necessarily written to the floppy until you unmount it, so removing
	the floppy from the drive too early might cause the contents to
	become garbled.  If you only read from the floppy, this is not very
	likely, but if you write, even accidentally,
	the result may be catastrophic.</P
><P
>Mounting and unmounting requires super user privileges, i.e.,
	only root can do it.  The reason for this is that if any user can
	mount a floppy on any directory, then it is rather easy to create a
	floppy with, say, a Trojan horse disguised as
	<TT
CLASS="FILENAME"
>/bin/sh</TT
>, or any other often used program.  
	However, it is often necessary to allow users to use floppies, and
	there are several ways to do this:

	<P
></P
><UL
><LI
><P
>Give the users the root password.  This is
	obviously bad security, but is the easiest solution.  It works well
	if there is no need for security anyway, which is the case
	on many non-networked, personal systems.</P
></LI
><LI
><P
>Use a program such as <B
CLASS="COMMAND"
>sudo</B
> to 
	allow users to use mount.  This is still bad security, but doesn't
	directly give super user privileges to everyone.  It requires several 
	seconds of hard thinking on the users' behalf.  Furthermore 
	<B
CLASS="COMMAND"
>sudo</B
> can be configured to only allow users to 
	execute certain commands.  See the sudo(8), sudoers(5), and visudo(8)
	manual pages.
	</P
></LI
><LI
><P
>Make the users use <B
CLASS="COMMAND"
>mtools</B
>, a 
	package for manipulating MS-DOS filesystems, without mounting them.
	This works well if MS-DOS floppies are all that is needed, but is
	rather awkward otherwise.
	</P
></LI
><LI
><P
>List the floppy devices and their allowable mount 
	points together with the suitable options in 
	<TT
CLASS="FILENAME"
>/etc/fstab</TT
>.

	</P
></LI
></UL
>

	The last alternative can be implemented by adding a line like the
	following to the <TT
CLASS="FILENAME"
>/etc/fstab</TT
> file:

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	/dev/fd0            /floppy      msdos   user,noauto      0     0
	</PRE
></FONT
></TD
></TR
></TABLE
>

	The columns are: device file to mount, directory to mount on,
	filesystem type, options, backup frequency (used by
	<B
CLASS="COMMAND"
>dump</B
>), and <B
CLASS="COMMAND"
>fsck</B
> pass number
	(to specify the order in which filesystems should be checked
	upon boot; 0 means no check).</P
><P
>The <TT
CLASS="OPTION"
>noauto</TT
> option stops this mount to be done
	automatically when the system is started (i.e., it stops
	<B
CLASS="COMMAND"
>mount -a</B
> from mounting it).  The 
	<TT
CLASS="OPTION"
>user</TT
> option allows any user to mount the
	filesystem, and, because of security reasons, disallows execution of
	programs (normal or setuid) and interpretation of device files from
	the mounted filesystem. After this, any user can mount a floppy with
	an msdos filesystem with the following command:

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>mount /floppy</B
></TT
>
	<TT
CLASS="PROMPT"
>$</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>

	The floppy can (and needs to, of course) be unmounted with
	the corresponding <B
CLASS="COMMAND"
>umount</B
> command.</P
><P
>If you want to provide access to several types of floppies,
	you need to give several mount points.  The settings can be
	different for each mount point.  For example, to give access to both
	MS-DOS and ext2 floppies, you could have the following to lines in
	<TT
CLASS="FILENAME"
>/etc/fstab</TT
>:

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	/dev/fd0    /mnt/dosfloppy    msdos   user,noauto  0  0
	/dev/fd0    /mnt/ext2floppy   ext2    user,noauto  0  0
	</PRE
></FONT
></TD
></TR
></TABLE
>

	The alternative is to just add one line similar to the following:

	<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>        /dev/fd0    /mnt/floppy    auto   user,noauto  0  0
        </PRE
></FONT
></TD
></TR
></TABLE
>

	The "auto" option in the filesystem type column allows the mount command
	to query the filesystem and try to determine what type it is itself.  This
	option won't work on all filesystem types, but works fine on the more common
	ones.</P
><P
>For MS-DOS filesystems (not just floppies), you probably want to
	restrict access to it by using the <TT
CLASS="OPTION"
>uid</TT
>,
	<TT
CLASS="OPTION"
>gid</TT
>, and <TT
CLASS="OPTION"
>umask</TT
> filesystem options,
	described in detail on the <B
CLASS="COMMAND"
>mount</B
> manual page.  If
	you aren't careful, mounting an MS-DOS filesystem gives everyone at
	least read access to the files in it, which
	is not a good idea.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN3099"
></A
>5.10.8. Filesystem Security</H2
><P
>TO BE ADDED</P
><P
>This section will describe mount options and how to use them 
	in <TT
CLASS="FILENAME"
>/etc/fstab</TT
> to provide additional system
	security.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FSCK"
></A
>5.10.9. Checking filesystem integrity with 
<B
CLASS="COMMAND"
>fsck</B
></H2
><P
>Filesystems are complex creatures, and as such, they
	tend to be somewhat error-prone.  A filesystem's correctness and
	validity can be checked using the <B
CLASS="COMMAND"
>fsck</B
> command.
	It can be instructed to repair any minor problems it finds, and to
	alert the user if there any unrepairable problems.  Fortunately, the
	code to implement filesystems is debugged quite effectively, so
	there are seldom any problems at all, and they are usually caused by
	power failures, failing hardware, or operator errors;
	for example, by not shutting down the system properly.</P
><P
>Most systems are setup to run <B
CLASS="COMMAND"
>fsck</B
>
	automatically at boot time, so that any errors are detected (and
	hopefully corrected) before the system is used.  Use of a corrupted
	filesystem tends to make things worse: if the data structures are
	messed up, using the filesystem will probably mess them up even
	more, resulting in more data loss. However, <B
CLASS="COMMAND"
>fsck</B
>
	can take a while to run on big filesystems, and since errors almost
	never occur if the system has been shut down properly, a couple of
	tricks are used to avoid doing the checks in such cases.  The first
	is that if the file <TT
CLASS="FILENAME"
>/etc/fastboot</TT
> exists, no
	checks are made.  The second is that the ext2 filesystem has a
	special marker in its superblock that tells whether the filesystem
	was unmounted properly after the previous mount.  This allows
	<B
CLASS="COMMAND"
>e2fsck</B
> (the version of <B
CLASS="COMMAND"
>fsck</B
>
	for the ext2 filesystem) to avoid checking the filesystem if the
	flag indicates that the unmount was done (the assumption being that
	a proper unmount indicates no problems).  Whether the
	<TT
CLASS="FILENAME"
>/etc/fastboot</TT
> trick works on your system
	depends on your startup scripts, but the ext2 trick works every time
	you use <B
CLASS="COMMAND"
>e2fsck</B
>. It has to be explicitly bypassed
	with an option to <B
CLASS="COMMAND"
>e2fsck</B
> to be avoided.	(See
	the <B
CLASS="COMMAND"
>e2fsck</B
> man page for
	details on how.)</P
><P
>The automatic checking only works for the
	filesystems that are mounted automatically at boot time. Use
	<B
CLASS="COMMAND"
>fsck</B
> manually to check other filesystems,
	e.g., floppies.</P
><P
>If <B
CLASS="COMMAND"
>fsck</B
> finds unrepairable problems,
	you need either in-depth knowledge of how filesystems work in
	general, and the type of the corrupt filesystem in particular, or
	good backups.  The latter is easy (although sometimes tedious) to
	arrange, the former can sometimes be arranged via a friend, the
	Linux newsgroups and mailing lists, or some other source of support,
	if you don't have the know-how yourself.  I'd like to tell you more
	about it, but my lack of education and experience in this regard
	hinders me.  The <B
CLASS="COMMAND"
>debugfs</B
>
	program by Theodore Ts'o should be useful.</P
><P
><B
CLASS="COMMAND"
>fsck</B
> must only be run on unmounted
	filesystems, never on mounted filesystems (with the exception of the
	read-only root during startup).  This is because it accesses the raw
	disk, and can therefore modify the filesystem without the operating
	system realizing it.	There <EM
>will</EM
>
	be trouble, if the operating system is confused.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BADBLOCKS"
></A
>5.10.10. Checking for disk errors with <B
CLASS="COMMAND"
>badblocks</B
></H2
><P
>It can be a good idea to periodically check for bad blocks.
	This is done with the <B
CLASS="COMMAND"
>badblocks</B
> command.  It 
	outputs a list of the numbers of all bad blocks it can find.  This
	list can be fed to <B
CLASS="COMMAND"
>fsck</B
> to be recorded in the
	filesystem data structures so that the operating system won't try to
	use the bad blocks for storing data. The following example will show
	how this could be done.

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>badblocks /dev/fd0H1440 1440 &#62; 
	bad-blocks</B
></TT
>
	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>fsck -t ext2 -l bad-blocks 
	/dev/fd0H1440</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Parallelizing fsck version 0.5a (5-Apr-94)
	e2fsck 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10
	Pass 1: Checking inodes, blocks, and sizes
	Pass 2: Checking directory structure
	Pass 3: Checking directory connectivity
	Pass 4: Check reference counts.
	Pass 5: Checking group summary information.
	
	/dev/fd0H1440: ***** FILE SYSTEM WAS MODIFIED *****
	/dev/fd0H1440: 11/360 files, 63/1440 blocks</TT
>
	<TT
CLASS="PROMPT"
>$</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>

	If badblocks reports a block that was already used,
	<B
CLASS="COMMAND"
>e2fsck</B
> will try to move the block to another
	place.	If the block was really bad, not just marginal, the
	contents of the file may be corrupted.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FRAGMENTATION"
></A
>5.10.11. Fighting fragmentation?</H2
><P
>When a file is written to disk, it can't always be written
	in consecutive blocks.  A file that is not stored in consecutive
	blocks is <I
CLASS="GLOSSTERM"
>fragmented</I
>.  It takes longer to
	read a fragmented file, since the disk's read-write head will have
	to move more.  It is desirable to avoid fragmentation, although it
	is less of a problem in a system with a good buffer
	cache with read-ahead.</P
><P
>Modern Linux filesystem keep fragmentation at a minimum
	by keeping all blocks in a file close together, even if
	they can't be stored in consecutive sectors.  Some filesystems, like 
	ext3, effectively allocate the free block that is nearest to other blocks
	in a file. Therefore it is not necessary to worry about fragmentation 
	in a Linux system.</P
><P
>In the earlier days of the ext2 filesystem, there was a concern 
	over file fragmentation that lead to the development of a 
	defragmentation program called, defrag.  A copy of it can still be 
	downloaded at <A
HREF="../../../../www.go.dlr.de/linux/src/defrag-0.73.tar.html"
TARGET="_top"
>	http://www.go.dlr.de/linux/src/defrag-0.73.tar.gz</A
>.  However, 
	it is HIGHLY recommended that you NOT use it.  It was designed for 
	and older version of ext2, and has not bee updated since 1998!  I 
	only mention it here for references purposes.</P
><P
>There are many MS-DOS defragmentation programs that
	move blocks around in the filesystem to remove fragmentation. For
	other filesystems, defragmentation must be done by backing up the
	filesystem, re-creating it, and restoring the files from backups.
	Backing up a filesystem before defragmenting is a good idea for all
	filesystems, since many things can go wrong during the 
	defragmentation.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FS-OTHER-TOOLS"
></A
>5.10.12. Other tools for all filesystems</H2
><P
>Some other tools are also useful for managing filesystems.
	<B
CLASS="COMMAND"
>df</B
> shows the free disk space on one or more
	filesystems; <B
CLASS="COMMAND"
>du</B
> shows how much disk space a
	directory and all its files contain.  These can be used to hunt down
	disk space wasters.  Both have manual pages which detail
	the (many) options which can be used.</P
><P
><B
CLASS="COMMAND"
>sync</B
> forces all unwritten blocks
	in the buffer cache (see <A
HREF="#BUFFER-CACHE"
>Section 6.6</A
>) to be
	written to disk.  It is seldom necessary to do this by hand; the
	daemon process <B
CLASS="COMMAND"
>update</B
> does this automatically.
	It can be useful in catastrophes, for example if
	<B
CLASS="COMMAND"
>update</B
> or its helper process
	<B
CLASS="COMMAND"
>bdflush</B
> dies, or if you must turn off power
	<EM
>now</EM
> and can't wait for
	<B
CLASS="COMMAND"
>update</B
> to run.  Again, there are manual pages.
	The <B
CLASS="COMMAND"
>man</B
> is your very best friend in Linux.  Its
	cousin <B
CLASS="COMMAND"
>apropos</B
> is also very useful when you don't
	know what the name of the command you want
	is.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FS-EXT3-TOOLS"
></A
>5.10.13. Other tools for the ext2/ext3 filesystem</H2
><P
>In addition to the filesystem creator 
	(<B
CLASS="COMMAND"
>mke2fs</B
>) and checker (<B
CLASS="COMMAND"
>e2fsck</B
>)
	accessible directly or via the filesystem type independent front
	ends, the ext2
	filesystem has some additional tools that can be useful.</P
><P
><B
CLASS="COMMAND"
>tune2fs</B
> adjusts filesystem parameters.  
	Some of the more interesting parameters are:

	<P
></P
><UL
><LI
><P
>	A maximal mount count.  <B
CLASS="COMMAND"
>e2fsck</B
> enforces a check 
	when filesystem has been mounted too many times, even if the clean
	flag is set.  For a system that is used for developing or testing
	the system, it might be a good idea to reduce this limit.
	</P
></LI
><LI
><P
>	A maximal time between checks.  <B
CLASS="COMMAND"
>e2fsck</B
> can also 
	enforce a maximal time between two checks, even if the clean flag is
	set, and the filesystem hasn't been mounted very often.  This can be
	disabled, however.
	</P
></LI
><LI
><P
>	Number of blocks reserved for root.  Ext2 reserves some blocks for
	root so that if the filesystem fills up, it is still possible to do
	system administration without having to delete anything.  The
	reserved amount is by default 5 percent, which on most disks isn't
	enough to be wasteful.  However, for floppies there is no point in
	reserving any blocks.
	</P
></LI
></UL
>
	
	See the <B
CLASS="COMMAND"
>tune2fs</B
> manual page for more
	information.</P
><P
><B
CLASS="COMMAND"
>dumpe2fs</B
> shows information about an ext2 or ext3 
	filesystem, mostly from the superblock. Below is a sample output.  Some 
	of the information in the output is technical and requires understanding 
	of how the filesystem works,  but much of it is readily understandable 
	even for lay-admins.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>dumpe2fs</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>dumpe2fs 1.32 (09-Nov-2002)
Filesystem volume name:   /
Last mounted on:          not available
Filesystem UUID:          51603f82-68f3-4ae7-a755-b777ff9dc739
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      has_journal filetype needs_recovery sparse_super
Default mount options:    (none)
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              3482976
Block count:              6960153
Reserved block count:     348007
Free blocks:              3873525
Free inodes:              3136573
First block:              0
Block size:               4096
Fragment size:            4096
Blocks per group:         32768
Fragments per group:      32768
Inodes per group:         16352
Inode blocks per group:   511
Filesystem created:       Tue Aug 26 08:11:55 2003
Last mount time:          Mon Dec 22 08:23:12 2003
Last write time:          Mon Dec 22 08:23:12 2003
Mount count:              3
Maximum mount count:      -1
Last checked:             Mon Nov  3 11:27:38 2003
Check interval:           0 (none)
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
Inode size:               128
Journal UUID:             none
Journal inode:            8
Journal device:           0x0000
First orphan inode:       655612


Group 0: (Blocks 0-32767)
  Primary superblock at 0, Group descriptors at 1-2
  Block bitmap at 3 (+3), Inode bitmap at 4 (+4)
  Block bitmap at 3 (+3), Inode bitmap at 4 (+4)
  Inode table at 5-515 (+5)
  3734 free blocks, 16338 free inodes, 2 directories</TT
></PRE
></FONT
></TD
></TR
></TABLE
><P
><B
CLASS="COMMAND"
>debugfs</B
> is a filesystem debugger.
	It allows direct access to the filesystem data structures stored on
	disk and can thus be used to repair a disk that is so broken that
	<B
CLASS="COMMAND"
>fsck</B
> can't fix it automatically. It has also been
	known to be used to recover deleted files. However,
	<B
CLASS="COMMAND"
>debugfs</B
> very much requires that you understand
	what you're doing; a failure to understand can
	destroy all your data.</P
><P
><B
CLASS="COMMAND"
>dump</B
> and <B
CLASS="COMMAND"
>restore</B
> can be 
	used to back up an ext2 filesystem.  They are ext2 specific versions
	of the traditional UNIX backup tools.  See <A
HREF="#BACKUPS"
>Section 12.1</A
>
	for more information on backups.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="DISK-NO-FS"
></A
>5.11. Disks without filesystems</H1
><P
>Not all disks or partitions are used as filesystems.
	A swap partition, for example, will not have a filesystem on it.
	Many floppies are used in a tape-drive emulating fashion, so that a
	<B
CLASS="COMMAND"
>tar</B
> (tape archive) or other file is written 
	directly on the raw disk, without a filesystem.  Linux boot floppies
	don't
	contain a filesystem, only the raw kernel.</P
><P
>Avoiding a filesystem has the advantage of making more of
	the disk usable, since a filesystem always has some bookkeeping
	overhead.  It also makes the disks more easily compatible with other
	systems: for example, the <B
CLASS="COMMAND"
>tar</B
> file format is the
	same on all systems, while filesystems are different on most
	systems.  You will quickly get used to disks without filesystems if
	you need them.  Bootable Linux floppies
	also do not necessarily have a filesystem, although they may.</P
><P
>One reason to use raw disks is to make image copies of them.
	For instance, if the disk contains a partially damaged filesystem,
	it is a good idea to make an exact copy of it before trying to fix
	it, since then you can start again if your fixing breaks things even
	more.  One way to do this is to use <B
CLASS="COMMAND"
>dd</B
>:

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>dd if=/dev/fd0H1440 
	of=floppy-image</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>2880+0 records in
	2880+0 records out</TT
>
	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>dd if=floppy-image 
	of=/dev/fd0H1440</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>2880+0 records in
	2880+0 records out</TT
>
	<TT
CLASS="PROMPT"
>$</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>

	The first <B
CLASS="COMMAND"
>dd</B
> makes an exact image of the floppy
	to the file <TT
CLASS="FILENAME"
>floppy-image</TT
>, the second one writes
	the image to the floppy.  (The user has presumably switched the
	floppy before the second command.	Otherwise the
	command pair is of doubtful usefulness.)</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="ALLOC-DISK"
></A
>5.12. Allocating disk space</H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PART-SCHEMES"
></A
>5.12.1. Partitioning schemes</H2
><P
>When it comes to partitioning your machine, 
	there is no universally correct way to do it. There are
	many factors that must be taken into account depending on 
	the purpose of the machine.</P
><P
>For a simple workstation with limited disk space, such 
	as a laptop, you may have as few a 3 partitions.  A partition for
	<TT
CLASS="FILENAME"
>/</TT
>, <TT
CLASS="FILENAME"
>/boot</TT
>, and swap.
	However, for most users this is not a recommended solution.</P
><P
>&#13;	</P
><P
>The traditional way is to have a (relatively) small
	root filesystem, and separate partitions for filesystems such as 
	<TT
CLASS="FILENAME"
>/usr</TT
> and <TT
CLASS="FILENAME"
>/home&#62;</TT
>.
	Creating a separate root filesystem if the root filesystem is small and 
	not heavily used, it is less likely to become corrupt when the system
	crashes, and therefore make it easier to recover a crashed system.  The
	reason is to prevent having the root filesystem get filled and cause a 
	system crash.</P
><P
>When creating your partitioning scheme, there are some things you 
	need to remember.  You cannot create separate partitions for the following 
	directories: <TT
CLASS="FILENAME"
>/bin</TT
>, <TT
CLASS="FILENAME"
>/etc</TT
>, 
	<TT
CLASS="FILENAME"
>/dev</TT
>, <TT
CLASS="FILENAME"
>/initrd</TT
>, 
	<TT
CLASS="FILENAME"
>/lib</TT
>, and <TT
CLASS="FILENAME"
>/sbin</TT
>.  The
	contents of these directories are required at bootup and must
	always be part of the <TT
CLASS="FILENAME"
>/</TT
> partition.</P
><P
>It is also recommended that you create separate partitions for 
	<TT
CLASS="FILENAME"
>/var</TT
> and <TT
CLASS="FILENAME"
>/tmp</TT
>.  This is
	because both directories typically have data that is constantly 
	changing.  Not creating separate partitions for these filesystems
	puts you at risk of having log file fill up our <TT
CLASS="FILENAME"
>/</TT
>
	partition.</P
><P
>An example of a server partition is:
	<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="COMPUTEROUTPUT"
>Filesystem            Size  Used Avail Use% Mounted on
/dev/hda2             9.7G  1.3G  8.0G  14% /
/dev/hda1             128M   44M   82M  34% /boot
/dev/hda3             4.9G  4.0G  670M  86% /usr
/dev/hda5             4.9G  2.1G  2.5G  46% /var
/dev/hda7              31G   24G  5.6G  81% /home
/dev/hda8             4.9G  2.0G  670M  43% /opt
	</TT
></PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>The problem with having many partitions is that it splits
	the total amount of free disk space into many small pieces.  One way
	to avoid this problem is to use to create Logical Volumes.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="LVM"
></A
>5.12.2. Logical Volume Manager (LVM)</H2
><P
>Using LVM allows administrators the flexibility to create 
	logical disks that can be expanded dynamically as more disk space 
	is required.</P
><P
>This is done first by creating partitions with as an 
	0x8e Linux LVM partition type.  Then the <I
CLASS="GLOSSTERM"
>Physical Partitions
	</I
> are added to a <I
CLASS="GLOSSTERM"
>Volume Group</I
> and 
	broken up into chunks, or <I
CLASS="GLOSSTERM"
>Physical Extents</I
>
	<I
CLASS="GLOSSTERM"
>Volume Group</I
>. These extends can then be grouped
	into <I
CLASS="GLOSSTERM"
>Logical Volumes</I
>.  These Logical Volumes 
	then can be formatted just like a physical partition.  The big 
	difference is that they can be expanded by adding more extents to 
	them.</P
><P
>Right now, a full discussion of LVM is beyond the scope of this 
	guide.  However, and excellent resource for learning more about LVM
	can be found at <A
HREF="http://www.tldp.org/HOWTO/LVM-HOWTO.html"
TARGET="_top"
>	http://www.tldp.org/HOWTO/LVM-HOWTO.html</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="SPACE-REQ"
></A
>5.12.3. Space requirements</H2
><P
>The Linux distribution you install will give some indication
	of how much disk space you need for various configurations. Programs
	installed separately may also do the same.  This will help you plan
	your disk space usage, but you should prepare for the future and
	reserve some extra space for things you will
	notice later that you need.</P
><P
>The amount you need for user files depends on what your
	users wish to do.  Most people seem to need as much space for their
	files as possible, but the amount they will live happily with varies
	a lot.  Some people do only light text processing and will survive
	nicely with a few megabytes, others do heavy
	image processing and will need gigabytes.</P
><P
>By the way, when comparing file sizes given in
	kilobytes or megabytes and disk space given in megabytes, it can be
	important to know that the two units can be different. Some disk
	manufacturers like to pretend that a kilobyte is 1000 bytes and a
	megabyte is 1000 kilobytes, while all the rest of the computing
	world uses 1024 for both factors.  Therefore, a 345 MB hard disk
	is really a 330 MB hard disk.</P
><P
>Swap space allocation is discussed in <A
HREF="#SWAP-ALLOCATION"
>Section 6.5</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="ALLOC-SPACE-EX"
></A
>5.12.4. Examples of hard disk allocation</H2
><P
>I used to have a 10 GB hard disk.  Now I am using a 30 GB
	hard disk.  I'll explain how and why I partitioned those
	disks.</P
><P
>First, I created a <TT
CLASS="FILENAME"
>/boot</TT
> partition 
	at 128 MG.  This is larger than I will need, and big enough to
	give me space if I need it.  I created a separate 
	<TT
CLASS="FILENAME"
>/boot</TT
> partition to ensure that this 
	filesystem will never get filled up, and therefore will be 
	bootable.  Then I created a 5 GB <TT
CLASS="FILENAME"
>/var</TT
> 
	partition.  Since the <TT
CLASS="FILENAME"
>/var</TT
> filesystem is 
	where log files and email is stored I wanted to isolate it
	from my root partition.  (I have had log files grow overnight 
	and fill my root filesystem in the past.) Next, I created a 15 GB 
	<TT
CLASS="FILENAME"
>/home</TT
> partition.  This is handy in the event 
	of a system crash.  If I ever have to re-install Linux from scratch, 
	I can tell the installation program to not format this partition, and
	instead remount it without the data being lost. Finally 
	since I had 512 MG of RAM I created a 1024 MG (or 1 GB) swap 
	partition.  This left me with roughly a 9 GB root filesystem.  I using 
	my old 10 GB hard drive, I created an 8 GB <TT
CLASS="FILENAME"
>/usr</TT
> 
	partition and left 2 GB unused.  This is incase I need more space  
	in the future.</P
><P
>In the end, my partition tables looked like this:

		<DIV
CLASS="TABLE"
><A
NAME="AEN3270"
></A
><P
><B
>Table 5-3. My Partitions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>9 GB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>root filesystem</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1 GB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>swap partition</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>5 GB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>/var</TT
> 
		filesystem</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>15 GB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>/home</TT
> 
		filesystem</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
> 8 GB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><TT
CLASS="FILENAME"
>/usr</TT
>
		filesystem</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
> 2 GB</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>scratch partition</TD
></TR
></TBODY
></TABLE
></DIV
>
	</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="ADDING-DISK"
></A
>5.12.5. Adding more disk space for Linux</H2
><P
>Adding more disk space for Linux is easy, at least after the
	hardware has been properly installed  (the hardware installation
	is outside the scope of this book).  You format it if necessary,
	then create the partitions and filesystem as described above,
	and add the proper lines to <TT
CLASS="FILENAME"
>/etc/fstab</TT
>
	
	so that it is mounted automatically.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="SPACE-SAVING-TIPS"
></A
>5.12.6. Tips for saving disk space</H2
><P
>The best tip for saving disk space is to avoid installing
	unnecessary programs.  Most Linux distributions have an
	option to install only part of the packages they contain,
	and by analyzing your needs you might notice that you don't
	need most of them.  This will help save a lot of disk space,
	since many programs are quite large.  Even if you do need a
	particular package or program, you might not need all of it.
	For example, some on-line documentation might be unnecessary,
	as might some of the Elisp files for GNU Emacs, some of the
	fonts for X11, or some of the libraries for programming.</P
><P
>If you cannot uninstall packages, you might look into
	compression.  Compression programs such as <B
CLASS="COMMAND"
>gzip</B
>
	
	or <B
CLASS="COMMAND"
>zip</B
>
	 will compress (and uncompress)
	individual files or groups of files.  The <B
CLASS="COMMAND"
>gzexe</B
>
	
	system will compress and uncompress programs invisibly to the
	user (unused programs are compressed, then uncompressed as they
	are used).  The experimental DouBle system will compress all
	files in a filesystem, invisibly to the programs that use them.
	(If you are familiar with products such as Stacker for MS-DOS 
	or DriveSpace for Windows, the principle is the same.)</P
><P
>Another way to save space is to take special care when 
	formatting you partitions.  Most modern filesystems will allow
	you to specify the block size.  The block size is chunk size that 
	the filesystem will use to read and write data.  Larger block sizes
	will help disk I/O performance when using large files, such as databases.
	This happens because the disk can read or write data for a longer 
	period of time before having to search for the next block.  The  
		&#13;</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="MEMORY-MANAGEMENT"
></A
>Chapter 6. Memory Management</H1
><A
NAME="AEN3325"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"Minnet, jag har tappat mitt minne,
	är jag svensk eller finne, kommer inte ihåg..."</SPAN
>
	(Bosse Österberg)
	</P
><P
>A Swedish drinking song, (rough) translation: ``Memory, I
	have lost my memory.  Am I Swedish or Finnish?  I can't
	remember''</P
></BLOCKQUOTE
><P
> This section describes the Linux memory management
	features, i.e., virtual memory and the disk buffer cache.
	The purpose and workings and the things the system administrator
	needs to take into consideration are described.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="VM-INTRO"
></A
>6.1. What is virtual memory?</H1
><P
>Linux supports <I
CLASS="GLOSSTERM"
>virtual memory</I
>, that
	is, using a disk as an extension of RAM so that the effective
	size of usable memory grows correspondingly.  The kernel will
	write the contents of a currently unused block of memory to the
	hard disk so that the memory can be used for another purpose.
	When the original contents are needed again, they are read back
	into memory.  This is all made completely transparent to the
	user; programs running under Linux only see the larger amount of
	memory available and don't notice that parts of them reside on
	the disk from time to time.  Of course, reading and writing the
	hard disk is slower (on the order of a thousand times slower)
	than using real memory, so the programs don't run as fast.
	The part of the hard disk that is used as virtual memory is
	called the <I
CLASS="GLOSSTERM"
>swap space</I
>.</P
><P
>Linux can use either a normal file in the filesystem or a
	separate partition for swap space.  A swap partition is
	faster, but it is easier to change the size of a swap file
	(there's no need to repartition the whole hard disk, and
	possibly install everything from scratch).  When you know how
	much swap space you need, you should go for a swap partition,
	but if you are uncertain, you can use a swap file first, use
	the system for a while so that you can get a feel for how much
	swap you need, and then make a swap partition when you're
	confident about its size.</P
><P
>You should also know that Linux allows one to use several swap
	partitions and/or swap files at the same time.  This means
	that if you only occasionally need an unusual amount of swap space,
	you can set up an extra swap file at such times, instead of
	keeping the whole amount allocated all the time.</P
><P
>A note on operating system terminology: computer science 
	usually distinguishes between swapping (writing the whole process
	out to swap space) and paging (writing only fixed size parts,
	usually a few kilobytes, at a time). Paging is usually more
	efficient, and that's what Linux does, but traditional Linux
	terminology talks about swapping anyway.
	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SWAP-SPACE"
></A
>6.2. Creating a swap space</H1
><P
>A swap file is an ordinary file; it is in no way special
	to the kernel.	The only thing that matters to the kernel is that it
	has no holes, and that it is prepared for use with
	<B
CLASS="COMMAND"
>mkswap</B
>.  It must reside on a local disk, however;
	it can't reside in a filesystem that has been mounted
	over NFS due to implementation reasons.</P
><P
>The bit about holes is important. The swap file reserves
	the disk space so that the kernel can quickly swap out a page
	without having to go through all the things that are necessary
	when allocating a disk sector to a file.  The kernel merely
	uses any sectors that have already been allocated to the file.
	Because a hole in a file means that there are no disk sectors
	allocated (for that place in the file), it is not good for the
	kernel to try to use them.</P
><P
>One good way to create the swap file without holes is through
	the following command:

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>dd if=/dev/zero of=/extra-swap bs=1024 
	count=1024</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>1024+0 records in
	1024+0 records out</TT
>
	<TT
CLASS="PROMPT"
>$</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>

	where <TT
CLASS="FILENAME"
>/extra-swap</TT
> is the name of the swap
	file and the size of is given after the <TT
CLASS="LITERAL"
>count=</TT
>.
	It is best for the size to be a multiple of 4, because the
	kernel writes out <I
CLASS="GLOSSTERM"
>memory pages</I
>, which
	are 4 kilobytes in size.  If the size is not a multiple of 4,
	the last couple of kilobytes may be unused.</P
><P
>A swap partition is also not special in any way.	You create
	it just like any other partition; the only difference is that
	it is used as a raw partition, that is, it will not contain any
	filesystem at all.  It is a good idea to mark swap partitions
	as type 82 (Linux swap); this will the make partition listings
	clearer, even though it is not strictly necessary to the
	kernel.</P
><P
>After you have created a swap file or a swap partition, you
	need to write a signature to its beginning; this contains some
	administrative information and is used by the kernel.  The
	command to do this is <B
CLASS="COMMAND"
>mkswap</B
>, used like this:

        <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>	<TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>mkswap /extra-swap 1024</B
></TT
>
	<TT
CLASS="COMPUTEROUTPUT"
>Setting up swapspace, size = 1044480 
	bytes</TT
>
	<TT
CLASS="PROMPT"
>$</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
>

	Note that the swap space is still not in use yet: it exists,
	but the kernel does not use it to provide virtual memory.</P
><P
>You should be very careful when using
	<B
CLASS="COMMAND"
>mkswap</B
>, since it does not check that the
	file or partition isn't used for anything else.  <EM
>You
	can easily overwrite important files and partitions with
	<B
CLASS="COMMAND"
>mkswap</B
>!</EM
> Fortunately, you should
	only need to use <B
CLASS="COMMAND"
>mkswap</B
> when you install
	your system.</P
><P
>The Linux memory manager limits the size of each swap space to
	2 GB.  You can, however, use up to
	8 swap spaces simultaneously, for a total of 16GB.
	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="USING-SWAP"
></A
>6.3. Using a swap space</H1
><P
>An initialized swap space is taken into use with
	<B
CLASS="COMMAND"
>swapon</B
>.  This command tells the kernel that
	the swap space can be used.  The path to the swap space is given
	as the argument, so to start swapping on a temporary swap file
	one might use the following command.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>swapon /extra-swap</B
></TT
>
<TT
CLASS="PROMPT"
>$</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	Swap spaces can be used automatically by listing them in
	the <TT
CLASS="FILENAME"
>/etc/fstab</TT
> file.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/dev/hda8        none        swap        sw     0     0
/swapfile        none        swap        sw     0     0</PRE
></FONT
></TD
></TR
></TABLE
>

	The startup scripts will run the command <B
CLASS="COMMAND"
>swapon
	-a</B
>, which will start swapping on all the swap
	spaces listed in <B
CLASS="COMMAND"
>/etc/fstab</B
>.  Therefore,
	the <B
CLASS="COMMAND"
>swapon</B
> command is usually used only when
	extra swap is needed.</P
><P
>You can monitor the use of swap spaces with
	<B
CLASS="COMMAND"
>free</B
>.  It will tell the total amount of swap
	space used.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>free</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>             total       used       free     shared   
 buffers
Mem:         15152      14896        256      12404       2528
-/+ buffers:            12368       2784
Swap:        32452       6684      25768</TT
>
<TT
CLASS="PROMPT"
>$</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	The first line of output (<TT
CLASS="LITERAL"
>Mem:</TT
>) shows the
	physical memory.  The total column does not show the physical
	memory used by the kernel, which is usually about a megabyte.
	The used column shows the amount of memory used (the second
	line does not count buffers).  The free column shows completely
	unused memory.	The shared column shows the amount of memory
	shared by several processes; the more, the merrier.  The buffers
	column shows the current size of the disk buffer cache.</P
><P
>That last line (<TT
CLASS="LITERAL"
>Swap:</TT
>) shows similar
	information for the swap spaces.  If this line is all zeroes,
	your swap space is not activated.</P
><P
>The same information is available via
	<B
CLASS="COMMAND"
>top</B
>, or using the proc filesystem in file
	<TT
CLASS="FILENAME"
>/proc/meminfo</TT
>.  It is currently difficult
	to get information on the use of a specific swap space.</P
><P
>A swap space can be removed from use with
	<B
CLASS="COMMAND"
>swapoff</B
>.  It is usually not necessary to do it,
	except for temporary swap spaces.  Any pages in use in the swap
	space are swapped in first; if there is not sufficient physical
	memory to hold them, they will then be swapped out (to some other
	swap space).  If there is not enough virtual memory to hold all
	of the pages Linux will start to thrash; after a long while it
	should recover, but meanwhile the system is unusable.  You should
	check (e.g., with <B
CLASS="COMMAND"
>free</B
>) that there is enough
	free memory before removing a swap space from use.</P
><P
>All the swap spaces that are used automatically
	with <B
CLASS="COMMAND"
>swapon -a</B
> can be removed from use
	with <B
CLASS="COMMAND"
>swapoff -a</B
>; it looks at the file
	<TT
CLASS="FILENAME"
>/etc/fstab</TT
> to find what to remove.
	Any manually used swap spaces will remain in use.</P
><P
>Sometimes a lot of swap space can be in use even though
	there is a lot of free physical memory.  This can happen for
	instance if at one point there is need to swap, but later a big
	process that occupied much of the physical memory terminates
	and frees the memory.  The swapped-out data is not automatically
	swapped in until it is needed, so the physical memory may remain
	free for a long time.  There is no need to worry about this,
	but it can be comforting to know what is happening.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SHARING-SWAP"
></A
>6.4. Sharing swap spaces with other operating systems</H1
><P
>Virtual memory is built into many operating systems.
	Since they each need it only when they are running, i.e., never at
	the same time, the swap spaces of all but the currently running
	one are being wasted.  It would be more efficient for them to
	share a single swap space.  This is possible, but can require a
	bit of hacking.  The  Tips-HOWTO at
	<A
HREF="../../../HOWTO/Tips-HOWTO.html"
TARGET="_top"
> 
	http://www.tldp.org/HOWTO/Tips-HOWTO.html</A
>, which contains 
	some advice on how to
	implement this.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SWAP-ALLOCATION"
></A
>6.5. Allocating swap space</H1
><P
>Some people will tell you that you should allocate twice as 
	much swap space as you have physical memory, but this is a bogus
	rule. Here's how to do it properly:

	<P
></P
><UL
><LI
><P
> Estimate your total memory needs.  This is the largest
	amount of memory you'll probably need at a time, that is the
	sum of the memory requirements of all the programs you want to
	run at the same time.  This can be done by running at the same
	time all the programs you are likely to ever be running at the
	same time.  </P
><P
>For instance, if you want to run X, you should allocate
	about 8 MB for it, gcc wants several megabytes (some
	files need an unusually large amount, up to tens of
	megabytes, but usually about four should do), and so on.
	The kernel will use about a megabyte by itself, and the
	usual shells and other small utilities perhaps a few
	hundred kilobytes (say a megabyte together).  There is
	no need to try to be exact, rough estimates are fine,
	but you might want to be on the pessimistic side.</P
><P
>Remember that if there are going to be several people
	using the system at the same time, they are all going
	to consume memory.  However, if two people run the same
	program at the same time, the total memory consumption
	is usually not double, since code pages and shared
	libraries exist only once.</P
><P
>The <B
CLASS="COMMAND"
>free</B
> and <B
CLASS="COMMAND"
>ps</B
>
	commands are useful for estimating the memory needs.
	
	</P
></LI
><LI
><P
>Add some security to the estimate in step 1.  This is because
	estimates of program sizes will probably be wrong, because
	you'll probably forget some programs you want to run, and to
	make certain that you have some extra space just in case.  A
	couple of megabytes should be fine.  (It is better to allocate
	too much than too little swap space, but there's no need to
	over-do it and allocate the whole disk, since unused swap space
	is wasted space; see later about adding more swap.)  Also,
	since it is nicer to deal with even numbers, you can round the
	value up to the next full megabyte.</P
></LI
><LI
><P
>Based on the computations above, you know how much memory
	you'll be needing in total.  So, in order to allocate swap
	space, you just need to subtract the size of your physical
	memory from the total memory needed, and you know how much
	swap space you need.  (On some versions of UNIX, you need to
	allocate space for an image of the physical memory as well, so
	the amount computed in step 2 is what you need and you shouldn't
	do the subtraction.)</P
></LI
><LI
><P
>If your calculated swap space is very much larger than your
	physical memory (more than a couple times larger), you should
	probably invest in more physical memory, otherwise performance
	will be too low.</P
></LI
></UL
>
    
	</P
><P
>It's a good idea to have at least some swap space, even if
	your calculations indicate that you need none. Linux uses
	swap space somewhat aggressively, so that as much physical
	memory as possible can be kept free. Linux will swap out
	memory pages that have not been used, even if the memory
	is not yet needed for anything. This avoids waiting for
	swapping when it is needed: the swapping can be done
	earlier, when the disk is otherwise idle.</P
><P
>Swap space can be divided among several disks. This
	can sometimes improve performance, depending on the
	relative speeds of the disks and the access patterns
	of the disks. You might want to experiment with a few
	schemes, but be aware that doing the experiments
	properly is quite difficult. You should not believe
	claims that any one scheme is superior to any other,
	since it won't always be true.
	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="BUFFER-CACHE"
></A
>6.6. The buffer cache</H1
><P
>Reading from a disk
	is very slow compared to accessing (real) memory.  In addition,
	it is common to read the same part of a disk several times
	during relatively short periods of time.  For example, one
	might first read an e-mail message, then read the letter into
	an editor when replying to it, then make the mail program read
	it again when copying it to a folder.  Or, consider how often
	the command <B
CLASS="COMMAND"
>ls</B
> might be run on a system with
	many users.  By reading the information from disk only once
	and then keeping it in memory until no longer needed, one can
	speed up all but the first read.  This is called <I
CLASS="GLOSSTERM"
>disk
	buffering</I
>, and the memory used for the purpose is
	called the <I
CLASS="GLOSSTERM"
>buffer cache</I
>.</P
><P
>Since memory is, unfortunately, a finite, nay, scarce
	resource, the buffer cache usually cannot be big enough (it
	can't hold all the data one ever wants to use).  When the cache
	fills up, the data that has been unused for the longest time
	is discarded and the memory thus freed is used for the new
	data.</P
><P
>Disk buffering works for writes as well.	On the one hand,
	data that is written is often soon read again (e.g., a source
	code file is saved to a file, then read by the compiler),
	so putting data that is written in the cache is a good idea.
	On the other hand, by only putting the data into the cache, not
	writing it to disk at once, the program that writes runs quicker.
	The writes can then be done in the background, without slowing
	down the other programs.</P
><P
>Most operating systems have buffer caches (although
	they might be called something else), but not all of
	them work according to the above principles.  Some are
	<I
CLASS="GLOSSTERM"
>write-through</I
>: the data is written to disk
	at once (it is kept in the cache as well, of course).  The cache
	is called <I
CLASS="GLOSSTERM"
>write-back</I
> if the writes are done
	at a later time.  Write-back is more efficient than write-through,
	but also a bit more prone to errors: if the machine crashes,
	or the power is cut at a bad moment, or the floppy is removed
	from the disk drive before the data in the cache waiting to be
	written gets written, the changes in the cache are usually lost.
	This might even mean that the filesystem (if there is one) is
	not in full working order, perhaps because the unwritten data
	held important changes to the bookkeeping information.</P
><P
>Because of this, you should never turn off the
	power without using a proper shutdown procedure 
	or remove a floppy from the
	disk drive until it has been unmounted (if it was mounted)
	or after whatever program is using it has signaled that it
	is finished and the floppy drive light doesn't shine anymore.
	The <B
CLASS="COMMAND"
>sync</B
> command <I
CLASS="GLOSSTERM"
>flushes</I
>
	the buffer, i.e., forces all unwritten data to be written to disk,
	and can be used when one wants to be sure that everything is
	safely written.  In traditional UNIX systems, there is a program
	called <B
CLASS="COMMAND"
>update</B
> running in the background
	which does a <B
CLASS="COMMAND"
>sync</B
> every 30 seconds, so
	it is usually not necessary to use <B
CLASS="COMMAND"
>sync</B
>.
	Linux has an additional daemon, <B
CLASS="COMMAND"
>bdflush</B
>,
	which does a more imperfect sync more frequently to avoid the
	sudden freeze due to heavy disk I/O that <B
CLASS="COMMAND"
>sync</B
>
	sometimes causes.</P
><P
>Under Linux, <B
CLASS="COMMAND"
>bdflush</B
> is started by
	<B
CLASS="COMMAND"
>update</B
>.  There is usually no reason to worry
	about it, but if <B
CLASS="COMMAND"
>bdflush</B
> happens to die for
	some reason, the kernel will warn about this, and you should
	start it by hand (<B
CLASS="COMMAND"
>/sbin/update</B
>).</P
><P
>The cache does not actually buffer files, but blocks, which
	are the smallest units of disk I/O (under Linux, they are usually
	1 KB).	This way, also directories, super blocks, other filesystem
	bookkeeping data, and non-filesystem disks are cached.</P
><P
>The effectiveness of a cache is primarily decided by its
	size.  A small cache is next to useless: it will hold so little
	data that all cached data is flushed from the cache before it
	is reused.  The critical size depends on how much data is read
	and written, and how often the same data is accessed.  The only
	way to know is to experiment.</P
><P
>If the cache is of a fixed size, it is not very good to have
	it too big, either, because that might make the free memory too
	small and cause swapping (which is also slow).	To make the most
	efficient use of real memory, Linux automatically uses all free
	RAM for buffer cache, but also automatically makes the cache
	smaller when programs need more memory.</P
><P
>Under Linux, you do not need to do anything to make use
	of the cache, it happens completely automatically.  Except for
	following the proper procedures for shutdown and removing
	floppies, you do not need to worry about it.  </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SYSTEM-MONITORING"
></A
>Chapter 7. System Monitoring</H1
><A
NAME="AEN3453"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"That's Hall Monitor to you!"</SPAN
>Spongebob
	Squarepants</P
></BLOCKQUOTE
><P
>One of the most important responsibilities a system administrator 
	has, is monitoring their systems.  As a system administrator you'll need 
	the ability to find out what is happening on your system at any given 
	time.  Whether it's the percentage of system's resources currently used, 
	what commands are being run, or who is logged on.  This chapter will cover 
	how to monitor your system, and in some cases, how to resolve problems 
	that may arise.</P
><P
>When a performance issue arises, there are 4 main areas to consider:
	CPU, Memory, Disk I/O, and Network.  The ability to determine where the
	bottleneck is can save you a lot of time.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SYSTEM-RESOURCES"
></A
>7.1. System Resources</H1
><P
>Being able to monitor the performance of your system
        is essential.  If system resources become to low it can cause a lot of
	problems.  System resources can be taken up by individual users, or by
	services your system may host such as email or web pages.  The ability to
	know what is happening can help determine whether system upgrades are needed, 
	or if some services need to be moved to another machine.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="TOP"
></A
>7.1.1. The <B
CLASS="COMMAND"
>top</B
> command.</H2
><P
>The most common of these commands is <B
CLASS="COMMAND"
>top</B
>.
	The <B
CLASS="COMMAND"
>top</B
> will display a continually updating report
	of system resource usage.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>top</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
> 12:10:49  up 1 day,  3:47,  7 users,  load average: 0.23, 0.19, 0.10
125 processes: 105 sleeping, 2 running, 18 zombie, 0 stopped
CPU states:   5.1% user   1.1% system   0.0% nice   0.0% iowait  93.6% idle
Mem:   512716k av,  506176k used,    6540k free,       0k shrd,   21888k buff
Swap: 1044216k av,  161672k used,  882544k free                  199388k cached

  PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME CPU COMMAND
 2330 root      15   0  161M  70M  2132 S     4.9 14.0  1000m   0 X
 2605 weeksa    15   0  8240 6340  3804 S     0.3  1.2   1:12   0 kdeinit
 3413 weeksa    15   0  6668 5324  3216 R     0.3  1.0   0:20   0 kdeinit
18734 root      15   0  1192 1192   868 R     0.3  0.2   0:00   0 top
 1619 root      15   0   776  608   504 S     0.1  0.1   0:53   0 dhclient
    1 root      15   0   480  448   424 S     0.0  0.0   0:03   0 init
    2 root      15   0     0    0     0 SW    0.0  0.0   0:00   0 keventd
    3 root      15   0     0    0     0 SW    0.0  0.0   0:00   0 kapmd
    4 root      35  19     0    0     0 SWN   0.0  0.0   0:00   0 ksoftirqd_CPU0
    9 root      25   0     0    0     0 SW    0.0  0.0   0:00   0 bdflush
    5 root      15   0     0    0     0 SW    0.0  0.0   0:00   0 kswapd
   10 root      15   0     0    0     0 SW    0.0  0.0   0:00   0 kupdated
   11 root      25   0     0    0     0 SW    0.0  0.0   0:00   0 mdrecoveryd
   15 root      15   0     0    0     0 SW    0.0  0.0   0:01   0 kjournald
   81 root      25   0     0    0     0 SW    0.0  0.0   0:00   0 khubd
 1188 root      15   0     0    0     0 SW    0.0  0.0   0:00   0 kjournald
 1675 root      15   0   604  572   520 S     0.0  0.1   0:00   0 syslogd
 1679 root      15   0   428  376   372 S     0.0  0.0   0:00   0 klogd
 1707 rpc       15   0   516  440   436 S     0.0  0.0   0:00   0 portmap
 1776 root      25   0   476  428   424 S     0.0  0.0   0:00   0 apmd
 1813 root      25   0   752  528   524 S     0.0  0.1   0:00   0 sshd
 1828 root      25   0   704  548   544 S     0.0  0.1   0:00   0 xinetd
 1847 ntp       15   0  2396 2396  2160 S     0.0  0.4   0:00   0 ntpd
 1930 root      24   0    76    4     0 S     0.0  0.0   0:00   0 rpc.rquotad</TT
></PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>The top portion of the report lists information such as
	the system time, uptime, CPU usage, physical ans swap memory usage,
	and number of processes.  Below that is a list of the processes sorted
	by CPU utilization.</P
><P
>You can modify the output of <B
CLASS="COMMAND"
>top</B
> while 
	is is running.  If you hit an <TT
CLASS="OPTION"
>i</TT
>, top will no longer
	display idle processes.  Hit <TT
CLASS="OPTION"
>i</TT
> again to see them
	again.  Hitting <TT
CLASS="OPTION"
>M</TT
> will sort by memory usage, 
	<TT
CLASS="OPTION"
>S</TT
> will sort by how long they processes have been 
	running, and <TT
CLASS="OPTION"
>P</TT
> will sort by CPU usage again.</P
><P
>In addition to viewing options, you can also modify processes
	from within the <B
CLASS="COMMAND"
>top</B
> command.  You can use 
	<TT
CLASS="OPTION"
>u</TT
> to view processes owned by a specific user, 
	<TT
CLASS="OPTION"
>k</TT
> to kill processes, and <TT
CLASS="OPTION"
>r</TT
> to 
	renice them.</P
><P
>For more in-depth information about processes you can look in
	the <TT
CLASS="FILENAME"
>/proc</TT
> filesystem.  In the <TT
CLASS="FILENAME"
>/proc</TT
>
	filesystem you will find a series of sub-directories with numeric names.
	These directories are associated with the processes ids of currently 
	running processes.  In each directory you will find a series of files 
	containing information about the process.</P
><P
>YOU MUST TAKE EXTREME CAUTION TO NOT MODIFY THESE FILES, DOING 
	SO MAY CAUSE SYSTEM PROBLEMS!</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="IOSTAT"
></A
>7.1.2. The <B
CLASS="COMMAND"
>iostat</B
> command.</H2
><P
>The <B
CLASS="COMMAND"
>iostat</B
> will display the current CPU load
	average and disk I/O information.  This is a great command to monitor 
	your disk I/O usage.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>iostat</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>Linux 2.4.20-24.9 (myhost)       12/23/2003

avg-cpu:  %user   %nice    %sys   %idle
          62.09    0.32    2.97   34.62

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
dev3-0            2.22        15.20        47.16    1546846    4799520</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	For 2.4 kernels the devices is names using the device's major
	and minor number.  In this case the device listed is <TT
CLASS="FILENAME"
>	/dev/hda</TT
>.  To have <B
CLASS="COMMAND"
>iostat</B
> print this
	out for you, use the <TT
CLASS="OPTION"
>-x</TT
>.
<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>iostat -x</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>Linux 2.4.20-24.9 (myhost)       12/23/2003

avg-cpu:  %user   %nice    %sys   %idle
          62.01    0.32    2.97   34.71

Device:  rrqm/s wrqm/s r/s  w/s rsec/s wsec/s rkB/s wkB/s avgrq-sz avgqu-sz await svctm %util
/dev/hdc   0.00   0.00 .00 0.00   0.00   0.00  0.00  0.00     0.00     2.35  0.00  0.00 14.71
/dev/hda   1.13   4.50 .81 1.39  15.18  47.14  7.59 23.57    28.24     1.99 63.76 70.48 15.56
/dev/hda1  1.08   3.98 .73 1.27  14.49  42.05  7.25 21.02    28.22     0.44 21.82  4.97  1.00
/dev/hda2  0.00   0.51 .07 0.12   0.55   5.07  0.27  2.54    30.35     0.97 52.67 61.73  2.99
/dev/hda3  0.05   0.01 .02 0.00   0.14   0.02  0.07  0.01     8.51     0.00 12.55  2.95  0.01</TT
></PRE
></FONT
></TD
></TR
></TABLE
>
	</P
><P
>The <B
CLASS="COMMAND"
>iostat</B
> man page contains a detailed 
	explanation of what each of these columns mean.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="PS"
></A
>7.1.3. The <B
CLASS="COMMAND"
>ps</B
> command</H2
><P
>The <B
CLASS="COMMAND"
>ps</B
> will provide you a list of
	processes currently running.  There is a wide variety of options 
	that this command gives you.</P
><P
>A common use would be to list all processes currently running.
	To do this you would use the <B
CLASS="COMMAND"
>ps -ef</B
> command. 
	(Screen output from this command is too large to include, the following
	is only a partial output.)

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Dec22 ?        00:00:03 init
root         2     1  0 Dec22 ?        00:00:00 [keventd]
root         3     1  0 Dec22 ?        00:00:00 [kapmd]
root         4     1  0 Dec22 ?        00:00:00 [ksoftirqd_CPU0]
root         9     1  0 Dec22 ?        00:00:00 [bdflush]
root         5     1  0 Dec22 ?        00:00:00 [kswapd]
root         6     1  0 Dec22 ?        00:00:00 [kscand/DMA]
root         7     1  0 Dec22 ?        00:01:28 [kscand/Normal]
root         8     1  0 Dec22 ?        00:00:00 [kscand/HighMem]
root        10     1  0 Dec22 ?        00:00:00 [kupdated]
root        11     1  0 Dec22 ?        00:00:00 [mdrecoveryd]
root        15     1  0 Dec22 ?        00:00:01 [kjournald]
root        81     1  0 Dec22 ?        00:00:00 [khubd]
root      1188     1  0 Dec22 ?        00:00:00 [kjournald]
root      1675     1  0 Dec22 ?        00:00:00 syslogd -m 0
root      1679     1  0 Dec22 ?        00:00:00 klogd -x
rpc       1707     1  0 Dec22 ?        00:00:00 portmap
root      1813     1  0 Dec22 ?        00:00:00 /usr/sbin/sshd
ntp       1847     1  0 Dec22 ?        00:00:00 ntpd -U ntp
root      1930     1  0 Dec22 ?        00:00:00 rpc.rquotad
root      1934     1  0 Dec22 ?        00:00:00 [nfsd]
root      1942     1  0 Dec22 ?        00:00:00 [lockd]
root      1943     1  0 Dec22 ?        00:00:00 [rpciod]
root      1949     1  0 Dec22 ?        00:00:00 rpc.mountd
root      1961     1  0 Dec22 ?        00:00:00 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf
root      2057     1  0 Dec22 ?        00:00:00 /usr/bin/spamd -d -c -a
root      2066     1  0 Dec22 ?        00:00:00 gpm -t ps/2 -m /dev/psaux
bin       2076     1  0 Dec22 ?        00:00:00 /usr/sbin/cannaserver -syslog -u bin
root      2087     1  0 Dec22 ?        00:00:00 crond
daemon    2195     1  0 Dec22 ?        00:00:00 /usr/sbin/atd
root      2215     1  0 Dec22 ?        00:00:11 /usr/sbin/rcd
weeksa    3414  3413  0 Dec22 pts/1    00:00:00 /bin/bash
weeksa    4342  3413  0 Dec22 pts/2    00:00:00 /bin/bash
weeksa   19121 18668  0 12:58 pts/2    00:00:00 ps -ef</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>The first column shows who owns the process.  The second
	column is the process ID.  The Third column is the parent process
	ID.  This is the process that generated, or started, the process. 
	The forth column is the CPU usage (in
	percent). The fifth column is the start time, of date if the process 
	has been running long enough. The sixth column is the tty associated 
	with the process, if applicable. The seventh column is the cumulitive 
	CPU usage (total amount of CPU time is has used while running). The
	eighth column is the command itself.</P
><P
>With this information you can see exacly what is running on 
	your system and kill run-away processes, or those that are causing 
	problems.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="VMSTAT"
></A
>7.1.4. The <B
CLASS="COMMAND"
>vmstat</B
> command</H2
><P
>The <B
CLASS="COMMAND"
>vmstat</B
> command  will provide a report 
	showing statistics for system processes, memory, swap, 
	I/O, and the CPU.  These statistics are generated using data from the 
	last time the command was run to the present.  In the case of the 
	command never being run, the data will be from the last reboot until 
	the present.</P
><P
>&#13;<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>vmstat</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>   procs                      memory      swap          io     system      cpu
 r  b  w   swpd   free   buff  cache   si   so    bi    bo   in    cs us sy id
 0  0  0 181604  17000  26296 201120    0    2     8    24  149     9 61  3 36</TT
></PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>The following was taken from the 
	<B
CLASS="COMMAND"
>vmstat</B
> man page.</P
><A
NAME="AEN3528"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><P
CLASS="LITERALLAYOUT"
>FIELD&nbsp;DESCRIPTIONS<br>
Procs<br>
&nbsp;&nbsp;&nbsp;&nbsp;r:&nbsp;The&nbsp;number&nbsp;of&nbsp;processes&nbsp;waiting&nbsp;for&nbsp;run&nbsp;time.<br>
&nbsp;&nbsp;&nbsp;&nbsp;b:&nbsp;The&nbsp;number&nbsp;of&nbsp;processes&nbsp;in&nbsp;uninterruptable&nbsp;sleep.<br>
&nbsp;&nbsp;&nbsp;&nbsp;w:&nbsp;The&nbsp;number&nbsp;of&nbsp;processes&nbsp;swapped&nbsp;out&nbsp;but&nbsp;otherwise&nbsp;runnable.&nbsp;&nbsp;This<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field&nbsp;is&nbsp;calculated,&nbsp;but&nbsp;Linux&nbsp;never&nbsp;desperation&nbsp;swaps.<br>
<br>
Memory<br>
&nbsp;&nbsp;&nbsp;&nbsp;swpd:&nbsp;the&nbsp;amount&nbsp;of&nbsp;virtual&nbsp;memory&nbsp;used&nbsp;(kB).<br>
&nbsp;&nbsp;&nbsp;&nbsp;free:&nbsp;the&nbsp;amount&nbsp;of&nbsp;idle&nbsp;memory&nbsp;(kB).<br>
&nbsp;&nbsp;&nbsp;&nbsp;buff:&nbsp;the&nbsp;amount&nbsp;of&nbsp;memory&nbsp;used&nbsp;as&nbsp;buffers&nbsp;(kB).<br>
<br>
Swap<br>
&nbsp;&nbsp;&nbsp;&nbsp;si:&nbsp;Amount&nbsp;of&nbsp;memory&nbsp;swapped&nbsp;in&nbsp;from&nbsp;disk&nbsp;(kB/s).<br>
&nbsp;&nbsp;&nbsp;&nbsp;so:&nbsp;Amount&nbsp;of&nbsp;memory&nbsp;swapped&nbsp;to&nbsp;disk&nbsp;(kB/s).<br>
<br>
IO<br>
&nbsp;&nbsp;&nbsp;&nbsp;bi:&nbsp;Blocks&nbsp;sent&nbsp;to&nbsp;a&nbsp;block&nbsp;device&nbsp;(blocks/s).<br>
&nbsp;&nbsp;&nbsp;&nbsp;bo:&nbsp;Blocks&nbsp;received&nbsp;from&nbsp;a&nbsp;block&nbsp;device&nbsp;(blocks/s).<br>
<br>
System<br>
&nbsp;&nbsp;&nbsp;&nbsp;in:&nbsp;The&nbsp;number&nbsp;of&nbsp;interrupts&nbsp;per&nbsp;second,&nbsp;including&nbsp;the&nbsp;clock.<br>
&nbsp;&nbsp;&nbsp;&nbsp;cs:&nbsp;The&nbsp;number&nbsp;of&nbsp;context&nbsp;switches&nbsp;per&nbsp;second.<br>
<br>
CPU<br>
&nbsp;&nbsp;&nbsp;&nbsp;These&nbsp;are&nbsp;percentages&nbsp;of&nbsp;total&nbsp;CPU&nbsp;time.<br>
&nbsp;&nbsp;&nbsp;&nbsp;us:&nbsp;user&nbsp;time<br>
&nbsp;&nbsp;&nbsp;&nbsp;sy:&nbsp;system&nbsp;time<br>
&nbsp;&nbsp;&nbsp;&nbsp;id:&nbsp;idle&nbsp;time</P
></P
></BLOCKQUOTE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="LSOF"
></A
>7.1.5. The <B
CLASS="COMMAND"
>lsof</B
> command</H2
><P
>The <B
CLASS="COMMAND"
>lsof</B
> command will print out a list of
	every file that is in use.  Since Linux considers everythihng a file, 	
	this list can be very long. However, this command
	can be useful in diagnosing problems.  An example of this is if you wish
	to unmount a filesystem, but you are being told that it is in use.  You
	could use this command and <B
CLASS="COMMAND"
>grep</B
> for the name of the 
	filesystem to see who is using it.</P
><P
>Or suppose you want to see all files in use by a particular process.
	To do this you would use <B
CLASS="COMMAND"
>lsof -p -processid-</B
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="MORE-UTILS"
></A
>7.1.6. Finding More Utilities</H2
><P
>To learn more about what command line tools are available, Chris 
	Karakas has wrote a reference guide titled <A
HREF="http://www.karakas-online.de/gnu-linux-tools-summary/"
TARGET="_top"
> GNU/Linux 
	Command-Line Tools Summary</A
>.  It's a good resource for learning
	what tools are out there and how to do a number of tasks.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="FS-USAGE"
></A
>7.2. Filesystem Usage</H1
><P
>Many reports are currently talking about how cheap storage has
	gotten, but if you're like most of us it isn't cheap enough.  Most of 
	us have a limited amount of space, and need to be able to monitor it 
	and control how it's used.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="DF"
></A
>7.2.1. The df command</H2
><P
>The <B
CLASS="COMMAND"
>df</B
> is the simplest tool available to 
	view disk usage.  Simply type in <B
CLASS="COMMAND"
>df</B
> and you'll 
	be shown disk usage for all your mounted filesystems in 1K blocks

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>user@server:~&#62; </TT
><TT
CLASS="PROMPT"
></TT
><TT
CLASS="USERINPUT"
><B
>df</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/hda3              5242904    759692   4483212  15% /
tmpfs                   127876         8    127868   1% /dev/shm
/dev/hda1               127351     33047     87729  28% /boot
/dev/hda9             10485816     33508  10452308   1% /home
/dev/hda8              5242904    932468   4310436  18% /srv
/dev/hda7              3145816     32964   3112852   2% /tmp
/dev/hda5              5160416    474336   4423928  10% /usr
/dev/hda6              3145816    412132   2733684  14% /var</TT
></PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>You can also use the <B
CLASS="COMMAND"
>-h</B
> to see the output in
	"human-readable" format.  This will be in K, Megs, or Gigs depending 
	on the size of the filesystem.  Alternately, you can also use the 
	<B
CLASS="COMMAND"
>-B</B
> to specify block size.</P
><P
>In addition to space usage, you could use the 
	<B
CLASS="COMMAND"
>-i</B
> option to view the number of used and available 
	inodes.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>user@server:~&#62; </TT
><TT
CLASS="USERINPUT"
><B
>df -i</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>Filesystem            Inodes   IUsed   IFree IUse% Mounted on
/dev/hda3                  0       0       0    -  /
tmpfs                  31969       5   31964    1% /dev/shm
/dev/hda1              32912      47   32865    1% /boot
/dev/hda9                  0       0       0    -  /home
/dev/hda8                  0       0       0    -  /srv
/dev/hda7                  0       0       0    -  /tmp
/dev/hda5             656640   26651  629989    5% /usr
/dev/hda6                  0       0       0    -  /var</TT
></PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="DU"
></A
>7.2.2. The du command</H2
><P
>Now that you know how much space has been used on a filesystem 
	how can you find out where that data is?  To view usage by a directory 
	or file you can use <B
CLASS="COMMAND"
>du</B
>.  Unless you specify a 
	filename <B
CLASS="COMMAND"
>du</B
> will act recursively.  For example:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>user@server:~&#62; </TT
><TT
CLASS="USERINPUT"
><B
>du file.txt</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>1300    file.txt</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	Or like the <B
CLASS="COMMAND"
>df</B
> I can use the <B
CLASS="COMMAND"
>-h</B
>
	and get the same output in "human-readable" form.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>user@server:~&#62; </TT
><TT
CLASS="USERINPUT"
><B
>du -h file.txt</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>1.3M     file.txt</TT
></PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Unless you specify a filename <B
CLASS="COMMAND"
>du</B
> will act 
	recursively.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>user@server:~&#62; </TT
><TT
CLASS="USERINPUT"
><B
>du -h /usr/local</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>4.0K    /usr/local/games
16K     /usr/local/include/nessus/net
180K    /usr/local/include/nessus
208K    /usr/local/include
62M     /usr/local/lib/nessus/plugins/.desc
97M     /usr/local/lib/nessus/plugins
164K    /usr/local/lib/nessus/plugins_factory
97M     /usr/local/lib/nessus
12K     /usr/local/lib/pkgconfig
2.7M    /usr/local/lib/ladspa
104M    /usr/local/lib
112K    /usr/local/man/man1
4.0K    /usr/local/man/man2
4.0K    /usr/local/man/man3
4.0K    /usr/local/man/man4
16K     /usr/local/man/man5
4.0K    /usr/local/man/man</TT
></PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>If you just want a summary of that directory you can use the 
	<B
CLASS="COMMAND"
>-s</B
> option.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>user@server:~&#62; </TT
><TT
CLASS="USERINPUT"
><B
>du -hs /usr/local</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>210M    /usr/local</TT
></PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="QUOTAS"
></A
>7.2.3. Quotas</H2
><P
>For more information about quotas you can read 
	<A
HREF="../../../HOWTO/Quota.html"
TARGET="_top"
>The Quota HOWTO
	</A
>.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="MONITORING-USERS"
></A
>7.3. Monitoring Users</H1
><A
NAME="AEN3598"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Just because you're paranoid doesn't mean they 
	AREN'T out to get you... Source Unknown</P
></BLOCKQUOTE
><P
>From time to time there are going to be occasions where you will
	want to know exactly what people are doing on your system.  Maybe you 
	notice that a lot of RAM is being used, or a lot of CPU activity.  
	You are going to want to see who is on the system, what they are 
	running, and what kind of resources they are using.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="WHO"
></A
>7.3.1. The who command</H2
><P
>The easiest way to see who is on the system is to do a 
	<B
CLASS="COMMAND"
>who</B
> or <B
CLASS="COMMAND"
>w</B
>.  The --&#62;
	<B
CLASS="COMMAND"
>who</B
> is a simple tool that lists out who is logged --&#62;
	on the system and what port or terminal they are logged on at.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>user@server:~&#62;</TT
> <TT
CLASS="USERINPUT"
><B
> who</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>bjones   pts/0        May 23 09:33
wally    pts/3        May 20 11:35
aweeks   pts/1        May 22 11:03
aweeks   pts/2        May 23 15:04</TT
></PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="PS-U"
></A
>7.3.2. The ps command -again!</H2
><P
>In the previous section we can see that user aweeks is logged 
	onto both <TT
CLASS="FILENAME"
>pts/1</TT
> and <TT
CLASS="FILENAME"
>pts/2</TT
>,
	but what if we want to see what they are doing?  We could to a
	<B
CLASS="COMMAND"
>ps -u aweeks</B
> and get the following output

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>user@server:~&#62; </TT
><TT
CLASS="USERINPUT"
><B
>ps -u aweeks</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>	
20876 pts/1    00:00:00 bash
20904 pts/2    00:00:00 bash
20951 pts/2    00:00:00 ssh
21012 pts/1    00:00:00 ps</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	From this we can see that the user is doing a <B
CLASS="COMMAND"
>ps</B
> 
	<B
CLASS="COMMAND"
>ssh</B
>.</P
><P
>This is a much more consolidated use of the 
	<B
CLASS="COMMAND"
>ps</B
> than discussed previously.</P
><P
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="W"
></A
>7.3.3. The w command</H2
><P
>Even easier than using the <B
CLASS="COMMAND"
>who</B
> and 
	<B
CLASS="COMMAND"
>ps -u</B
> commands is to use the <B
CLASS="COMMAND"
>w</B
>.
	<B
CLASS="COMMAND"
>w</B
> will print out not only who is on the system, 
	but also the commands they are running.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>user@server:~&#62; </TT
><TT
CLASS="USERINPUT"
><B
>w</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>aweeks   :0        09:32   ?xdm?  30:09   0.02s -:0
aweeks   pts/0     09:33    5:49m  0.00s  0.82s kdeinit: kded
aweeks   pts/2     09:35    8.00s  0.55s  0.36s vi sag-0.9.sgml
aweeks   pts/1     15:03   59.00s  0.03s  0.03s /bin/bash</TT
></PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>From this we can see that I have a <B
CLASS="COMMAND"
>kde</B
> session
	running, I'm working in this document :-), and have another terminal
	open sitting idle at a bash prompt.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="SKILL"
></A
>7.3.4. The skill command</H2
><P
> To Be Added</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="NICE"
></A
>7.3.5. nice and renice</H2
><P
>To Be Added</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="BOOTS-AND-SHUTDOWNS"
></A
>Chapter 8. Boots And Shutdowns</H1
><A
NAME="AEN3647"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><P
CLASS="LITERALLAYOUT"
>Start&nbsp;me&nbsp;up<br>
Ah...&nbsp;you've&nbsp;got&nbsp;to...&nbsp;you've&nbsp;got&nbsp;to<br>
Never,&nbsp;never&nbsp;never&nbsp;stop<br>
Start&nbsp;it&nbsp;up<br>
Ah...&nbsp;start&nbsp;it&nbsp;up,&nbsp;never,&nbsp;never,&nbsp;never<br>
&nbsp;You&nbsp;make&nbsp;a&nbsp;grown&nbsp;man&nbsp;cry,<br>
&nbsp;&nbsp;you&nbsp;make&nbsp;a&nbsp;grown&nbsp;man&nbsp;cry<br>
(Rolling&nbsp;Stones)</P
></P
></BLOCKQUOTE
><P
> This section explains what goes on when a Linux system is
	brought up and taken down, and how it should be done properly.
	If proper procedures are not followed, files might be corrupted
	or lost.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="BOOT-OVERVIEW"
></A
>8.1. An overview of boots and shutdowns</H1
><P
>The act of turning on a computer system and causing its
	operating system to be loaded
	is called <I
CLASS="GLOSSTERM"
>booting</I
>.  The name comes from
	an image of the computer pulling itself up from its bootstraps,
	but the act itself slightly more realistic.</P
><P
>During bootstrapping, the computer first loads a small piece
	of code called the <I
CLASS="GLOSSTERM"
>bootstrap loader</I
>, which
	in turn loads and starts the operating system.	The bootstrap
	loader is usually stored in a fixed location on a hard disk
	or a floppy.  The reason for this two step process is that
	the operating system is big and complicated, but the first
	piece of code that the computer loads must be very small (a
	few hundred bytes), to avoid making the firmware unnecessarily
	complicated.</P
><P
>Different computers do the bootstrapping differently.
	For PCs, the computer (its BIOS) reads in the first sector
	(called the <I
CLASS="GLOSSTERM"
>boot sector</I
>) of a floppy or
	hard disk.  The bootstrap loader is contained within this sector.
	It loads the operating system from elsewhere on the disk (or
	from some other place).</P
><P
>After Linux has been loaded, it initializes the hardware and
	device drivers, and then runs <B
CLASS="COMMAND"
>init</B
>.  
<B
CLASS="COMMAND"
>init</B
>
	starts other processes to allow users to log in, and do things.
	The details of this part will be discussed below.</P
><P
>In order to shut down a Linux system, first all processes
	are told to terminate (this makes them close any files and
	do other necessary things to keep things tidy), then filesystems
	and swap areas are unmounted, and finally a message is printed
	to the console that the power can be turned off.  If the proper
	procedure is not followed, terrible things can and will happen;
	most importantly, the filesystem buffer cache might not be flushed,
	which means that all data in it is lost and the filesystem on
	disk is inconsistent, and therefore possibly unusable.
	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="BOOT-PROCESS"
></A
>8.2. The boot process in closer look</H1
><P
>When a PC is booted, the BIOS will do various tests to
	check that everything looks all right, and will then start the actual 
	booting.  This process is called the <I
CLASS="GLOSSTERM"
>power on self test
	</I
>, or POST for short.  It will choose a disk
	drive (typically the first floppy drive, if there is a floppy
	inserted, otherwise the first hard disk, if one is installed
	in the computer; the order might be configurable, however)
	and will then read its very first sector.  This is called the
	<I
CLASS="GLOSSTERM"
>boot sector</I
>; for a hard disk, it is also
	called the <I
CLASS="GLOSSTERM"
>master boot record</I
>, since a
	hard disk can contain several partitions, each with their own
	boot sectors.</P
><P
>The boot sector contains a small program (small enough to
	fit into one sector) whose responsibility is to read the actual
	operating system from the disk and start it.  When booting Linux
	from a floppy disk, the boot sector contains code that just reads
	the first few hundred blocks (depending on the actual kernel
	size, of course) to a predetermined place in memory.  On a Linux
	boot floppy, there is no filesystem, the kernel is just stored
	in consecutive sectors, since this simplifies the boot process.
	It is possible, however, to boot from a floppy with a filesystem,
	by using LILO, the LInux LOader, or GRUB, the GRand Unifying 
	Bootloader.</P
><P
>When booting from the hard disk, the code in the master
	boot record will examine the partition table (also in the master
	boot record), identify the active partition (the partition that is
	marked to be bootable), read the boot sector from that partition,
	and then start the code in that boot sector.  The code in the
	partition's boot sector does what a floppy disk's boot sector
	does: it will read in the kernel from the partition and start it.
	The details vary, however, since it is generally not useful to
	have a separate partition for just the kernel image, so the
	code in the partition's boot sector can't just read the disk
	in sequential order, it has to find the sectors wherever the
	filesystem has put them.  There are several ways around this
	problem, but the most common way is to use  a boot loader like
	LILO or GRUB.  (The details
	about how to do this are irrelevant for this discussion, however;
	see the LILO or GRUB documentation for more information; it is most
	thorough.)</P
><P
>When booting, the bootloader will normally go right ahead
	and read in and boot the default kernel.  It is also possible
	to configure the boot loader to be able to boot one of several kernels,
	or even other operating systems than Linux, and it is possible
	for the user to choose which kernel or operating system is to
	be booted at boot time.  LILO, for example, can be configured so that if one
	holds down the <B
CLASS="KEYCAP"
>alt</B
>, <B
CLASS="KEYCAP"
>shift</B
>, or
	<B
CLASS="KEYCAP"
>ctrl</B
> key at boot time (when LILO is loaded),
	LILO will ask what is to be booted and not boot the default
	right away.  Alternatively, the bootloader can be configured so that it
	will always ask, with an optional timeout that will cause the
	default kernel to be booted.</P
><P
>It is also possible to give a <I
CLASS="GLOSSTERM"
>kernel
	command line argument</I
>, after the name of the kernel
	or operating system.  For a list of possible options you can read
	<A
HREF="../../../HOWTO/BootPrompt-HOWTO.html"
TARGET="_top"
> 
	http://www.tldp.org/HOWTO/BootPrompt-HOWTO.html</A
>.</P
><P
>Booting from floppy and from hard disk have both their
	advantages, but generally booting from the hard disk is nicer,
	since it avoids the hassle of playing around with floppies.
	It is also faster.  Most Linux distributions will setup the bootloader
	for you during the install process.</P
><P
>After the Linux kernel has been read into the memory, by
	whatever means, and is started for real, roughly the following
	things happen:
	
	<P
></P
><UL
><LI
><P
>	The Linux kernel is installed compressed, so it will first
	uncompress itself.  The beginning of the kernel image
	contains a small program that does this.
	</P
></LI
><LI
><P
>	If you have a super-VGA card that Linux
	recognizes and that has some special text modes (such as 100
	columns by 40 rows), Linux asks you which mode
	you want to use.  During the kernel compilation, it is
	possible to preset a video mode, so that this is never asked.
	This can also be done with LILO, GRUB or <B
CLASS="COMMAND"
>rdev</B
>.
	</P
></LI
><LI
><P
>	After this, the kernel checks what other hardware there is
	(hard disks, floppies, network adapters, etc), and configures
	some of its device drivers appropriately; while it does this,
	it outputs messages about its findings.  For example, when I
	boot, I it looks like this:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="COMPUTEROUTPUT"
>LILO boot:
Loading linux.
Console: colour EGA+ 80x25, 8 virtual consoles
Serial driver version 3.94 with no serial options enabled
tty00 at 0x03f8 (irq = 4) is a 16450
tty01 at 0x02f8 (irq = 3) is a 16450
lp_init: lp1 exists (0), using polling driver
Memory: 7332k/8192k available (300k kernel code, 384k reserved, 176k 
data)
Floppy drive(s): fd0 is 1.44M, fd1 is 1.2M
Loopback device init
Warning WD8013 board not found at i/o = 280.
Math coprocessor using irq13 error reporting.
Partition check:
  hda: hda1 hda2 hda3
VFS: Mounted root (ext filesystem).
Linux version 0.99.pl9-1 (root@haven) 05/01/93 14:12:20</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	The exact texts are different on different systems, depending
	on the hardware, the version of Linux being used, and how
	it has been configured.
	</P
></LI
><LI
><P
> Then the kernel will try to mount the root
	filesystem.  The place is configurable at compilation time,  or
	any time with <B
CLASS="COMMAND"
>rdev</B
> or the bootloader. The filesystem
	type is detected automatically.  If the mounting of the root
	filesystem fails, for example because you didn't remember to
	include the corresponding filesystem driver in the kernel, the
	kernel panics and halts the system (there isn't much it can do,
	anyway).  </P
><P
>The root filesystem is usually mounted read-only (this can
	be set in the same way as the place).  This makes it possible
	to check the filesystem while it is mounted; it is not a good
	idea to check a filesystem that is mounted read-write.
	</P
></LI
><LI
><P
> After this, the kernel starts
	the program <B
CLASS="COMMAND"
>init</B
> (located in
	<TT
CLASS="FILENAME"
>/sbin/init</TT
>) in the background (this will
	always become process number 1).  <B
CLASS="COMMAND"
>init</B
> does
	various startup chores.  The exact things it does depends on how
	it is configured; see <A
HREF="#INIT"
>Section 2.3.1</A
> for more information
	(not yet written).  It will at least start some essential
	background daemons.  </P
></LI
><LI
><P
> <B
CLASS="COMMAND"
>init</B
> then switches to
	multi-user mode, and starts a <B
CLASS="COMMAND"
>getty</B
> for virtual
	consoles and serial lines.  <B
CLASS="COMMAND"
>getty</B
> is the
	program which lets people log in via virtual consoles and serial
	terminals.  <B
CLASS="COMMAND"
>init</B
> may also start some other
	programs, depending on how it is configured.  </P
></LI
><LI
><P
> After this, the boot is complete, and the system
	is up and running normally.  </P
></LI
></UL
>
    	</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BOOTLOADERS"
></A
>8.2.1. A Word About Bootloaders</H2
><P
>TO BE ADDED</P
><P
>This section will give an overview of the difference between
	GRUB and LILO.</P
><P
>For more information on LILO, you can read  
	<A
HREF="../../../HOWTO/LILO.html"
TARGET="_top"
>	http://www.tldp.org/HOWTO/LILO.html</A
></P
><P
>For more information on GRUB, you can visit  
	<A
HREF="http://www.gnu.org/software/grub/grub.html"
TARGET="_top"
>	http://www.gnu.org/software/grub/grub.html</A
></P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SHUTDOWN"
></A
>8.3. More about shutdowns</H1
><P
>It is important to follow the correct procedures when you shut
	down a Linux system.  If you fail do so, your filesystems probably
	will become trashed and the files probably will become scrambled.
	This is because Linux has a disk cache that won't write things
	to disk at once, but only at intervals.  This greatly improves
	performance but also means that if you just turn off the power
	at a whim the cache may hold a lot of data and that what is on
	the disk may not be a fully working filesystem (because only
	some things have been written to the disk).</P
><P
>Another reason against just flipping the power switch is that
	in a multi-tasking system there can be lots of things going on
	in the background, and shutting the power can be quite
	disastrous.  By using the proper shutdown sequence, you ensure
	that all background processes can save their data.</P
><P
>The command for properly shutting down a Linux system
	is <B
CLASS="COMMAND"
>shutdown</B
>.  It is usually used in one of
	two ways.</P
><P
>If you are running a system where you are the only user,
	the usual way of using <B
CLASS="COMMAND"
>shutdown</B
> is to quit
	all running programs, log out on all virtual consoles, log
	in as root on one of them (or stay logged in as root if you
	already are, but you should change to root's home directory or
	the root directory, to avoid problems with unmounting), then
	give the command <B
CLASS="COMMAND"
>shutdown -h now</B
> (substitute
	<TT
CLASS="LITERAL"
>now</TT
> with a plus sign and a number in minutes
	if you want a delay, though you usually don't on a single user
	system).</P
><P
>Alternatively, if your system has many users, use the command
	<B
CLASS="COMMAND"
>shutdown -h +time message</B
>, where 
<TT
CLASS="LITERAL"
>time</TT
>
	is the
	time in minutes until the system is halted, and 
<TT
CLASS="LITERAL"
>message</TT
>
	is a short explanation of why the system is shutting down.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>shutdown -h +10 'We will install a new 
disk.  System should
&#62; be back on-line in three hours.'</B
></TT
>
<TT
CLASS="PROMPT"
>#</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	This will warn everybody that the system will shut down in
	ten minutes, and that they'd better get lost or lose data.
	The warning is printed to every terminal on which someone is
	logged in, including all <B
CLASS="COMMAND"
>xterm</B
>s:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="COMPUTEROUTPUT"
>Broadcast message from root (ttyp0) Wed Aug  2 01:03:25 1995...

We will install a new disk.  System should
be back on-line in three hours.
The system is going DOWN for system halt in 10 minutes !!</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	The warning is automatically repeated a few times before the boot,
	with shorter and shorter intervals as the time runs out.</P
><P
>When the real shutting down starts after any delays, all
	filesystems (except the root one) are unmounted, user processes
	(if anybody is still logged in) are killed, daemons are shut down,
	all filesystem are unmounted, and generally everything settles
	down.  When that is done, <B
CLASS="COMMAND"
>init</B
> prints out a
	message that you can power down the machine.  Then, and only then,
	should you move your fingers towards the power switch.</P
><P
>Sometimes, although rarely on any good system, it is
	impossible to shut down properly.  For instance, if the kernel
	panics and crashes and burns and generally misbehaves, it might
	be completely impossible to give any new commands, hence shutting
	down properly is somewhat difficult, and just about everything
	you can do is hope that nothing has been too severely damaged
	and turn off the power.  If the troubles are a bit less severe
	(say, somebody hit your keyboard with an axe), and the kernel
	and the <B
CLASS="COMMAND"
>update</B
> program still run normally,
	it is probably a good idea to wait a couple of minutes to give
	<B
CLASS="COMMAND"
>update</B
> a chance to flush the buffer cache,
	and only cut the power after that.</P
><P
>In the old days, some people like to shut down using the command
	<B
CLASS="COMMAND"
>sync</B
> three times, waiting for the disk I/O to stop, 
	then turn off the power.  If there are no running programs, this is 
	equivalent to using <B
CLASS="COMMAND"
>shutdown</B
>.  However, it
	does not unmount any filesystems and this can lead to problems
	with the ext2fs ``clean filesystem'' flag.  The triple-sync
	method is <EM
>not recommended</EM
>.</P
><P
>(In case you're wondering: the reason for three syncs is
	that in the early days of UNIX, when the commands were
	typed separately, that usually gave sufficient time for most
	disk I/O to be finished.)
	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="REBOOTING"
></A
>8.4. Rebooting</H1
><P
>Rebooting means booting the system again.  This can be
	accomplished by first shutting it down completely, turning
	power off, and then turning it back on.  A simpler way is to
	ask <B
CLASS="COMMAND"
>shutdown</B
> to reboot the system, instead
	of merely halting it.  This is accomplished by using the
	<TT
CLASS="OPTION"
>-r</TT
> option to <B
CLASS="COMMAND"
>shutdown</B
>,
	for example, by giving the command <B
CLASS="COMMAND"
>shutdown -r
	now</B
>.</P
><P
>Most Linux systems run <B
CLASS="COMMAND"
>shutdown -r now</B
>
	when ctrl-alt-del is pressed on the keyboard.  This reboots the
	system.  The action on ctrl-alt-del is configurable, however, and
	it might be better to allow for some delay before the reboot on
	a multiuser machine.  Systems that are physically accessible to
	anyone might even be configured to do nothing when ctrl-alt-del
	is pressed.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SINGLE-USER"
></A
>8.5. Single user mode</H1
><P
>The <B
CLASS="COMMAND"
>shutdown</B
> command can also be used
	to bring the system down to single user mode, in which no one
	can log in, but root can use the console.  This is useful for
	system administration tasks that can't be done while the system is
	running normally.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="EMERG-BOOT-FLOPPY"
></A
>8.6. Emergency boot floppies</H1
><P
>It is not always possible to boot a computer from the hard 
disk.
	For example, if you make a mistake in configuring LILO, you might
	make your system unbootable.  For these situations, you need an
	alternative way of booting that will always work (as long as the
	hardware works).  For typical PCs, this means booting from the
	floppy drive.</P
><P
>Most Linux distributions allow one to create an
	<I
CLASS="GLOSSTERM"
>emergency boot floppy</I
> during installation.
	It is a good idea to do this.  However, some such boot disks
	contain only the kernel, and assume you will be using the programs
	on the distribution's installation disks to fix whatever problem
	you have.  Sometimes those programs aren't enough; for example,
	you might have to restore some files from backups made with
	software not on the installation disks.</P
><P
>Thus, it might be necessary to create a custom root floppy
	as well.  The Bootdisk HOWTO by Graham Chapman  contains instructions 
	for doing this.  You can find this HOWTO at 
	<A
HREF="../../../HOWTO/Bootdisk-HOWTO/index.html"
TARGET="_top"
>	http://www.tldp.org/HOWTO/Bootdisk-HOWTO/index.html</A
>.
	You must, of course, remember to keep your emergency boot and
	root floppies up to date.</P
><P
>You can't use the floppy drive you use to mount the root
	floppy for anything else.  This can be inconvenient if you only
	have one floppy drive.	However, if you have enough memory, you
	can configure your boot floppy to load the root disk to a ramdisk
	(the boot floppy's kernel needs to be specially configured for
	this).	Once the root floppy has been loaded into the ramdisk,
	the floppy drive is free to mount other disks.	</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="INIT-INTRO"
></A
>Chapter 9. <B
CLASS="COMMAND"
>init</B
></H1
><A
NAME="AEN3771"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"Uuno on numero yksi"</SPAN
>
	(Slogan for a series of Finnish movies.)</P
></BLOCKQUOTE
><P
>This chapter describes the <B
CLASS="COMMAND"
>init</B
> process,
	which is the first user level process started by the kernel.
	<B
CLASS="COMMAND"
>init</B
> has many important duties, such as
	starting <B
CLASS="COMMAND"
>getty</B
> (so that users can log in),
	implementing run levels, and taking care of orphaned processes.
	This chapter explains how <B
CLASS="COMMAND"
>init</B
> is configured
	and how you can make use of the different run levels.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="INIT-PROCESS"
></A
>9.1. <B
CLASS="COMMAND"
>init</B
> comes first</H1
><P
><B
CLASS="COMMAND"
>init</B
> is one of those programs that
	are absolutely essential to the operation of a Linux system,
	but that you still can mostly ignore. A good Linux distribution
	will come with a configuration for <B
CLASS="COMMAND"
>init</B
>
	that will work for most systems, and on these systems there is
	nothing you need to do about <B
CLASS="COMMAND"
>init</B
>. Usually,
	you only need to worry about <B
CLASS="COMMAND"
>init</B
> if you hook
	up serial terminals, dial-in (not dial-out) modems, or if you
	want to change the default run level.</P
><P
>When the kernel has started itself (has been loaded
	into memory, has started running, and has initialized all
	device drivers and data structures and such), it finishes its
	own part of the boot process by starting a user level program,
	<B
CLASS="COMMAND"
>init</B
>. Thus, <B
CLASS="COMMAND"
>init</B
> is always
	the first process (its process number is always 1).</P
><P
>The kernel looks for <B
CLASS="COMMAND"
>init</B
>
	in a few locations that have been historically used
	for it, but the proper location for it (on a Linux
	system) is <TT
CLASS="FILENAME"
>/sbin/init</TT
>. If the
	kernel can't find <B
CLASS="COMMAND"
>init</B
>, it tries to run
	<TT
CLASS="FILENAME"
>/bin/sh</TT
>, and if that also fails, the startup
	of the system fails.</P
><P
>When <B
CLASS="COMMAND"
>init</B
> starts, it finishes the
	boot process by doing a number of administrative tasks, such
	as checking filesystems, cleaning up <TT
CLASS="FILENAME"
>/tmp</TT
>,
	starting various services, and starting a <B
CLASS="COMMAND"
>getty</B
>
	for each terminal and virtual console where users should be able
	to log in (see <A
HREF="#LOG-IN-AND-OUT"
>Chapter 10</A
>).</P
><P
>After the system is properly up, <B
CLASS="COMMAND"
>init</B
>
	restarts <B
CLASS="COMMAND"
>getty</B
> for each terminal
	after a user has logged out (so that the next user can log
	in). <B
CLASS="COMMAND"
>init</B
> also adopts orphan processes: when
	a process starts a child process and dies before its child, the
	child immediately becomes a child of <B
CLASS="COMMAND"
>init</B
>.
	This is important for various technical reasons, but it is good
	to know it, since it makes it easier to understand process lists
	and process tree graphs.
	There are a few variants of <B
CLASS="COMMAND"
>init</B
>
	available. Most Linux distributions
	use <B
CLASS="COMMAND"
>sysvinit</B
> (written by Miquel
	van Smoorenburg), which is based on the System V
	<B
CLASS="COMMAND"
>init</B
> design.  The BSD versions of Unix have
	a different <B
CLASS="COMMAND"
>init</B
>. The primary difference
	is run levels: System V has them, BSD does not (at least
	traditionally). This difference is not essential.  We'll look
	at <B
CLASS="COMMAND"
>sysvinit</B
> only.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="CONFIG-INIT"
></A
>9.2. Configuring <B
CLASS="COMMAND"
>init</B
> to start 
<B
CLASS="COMMAND"
>getty</B
>: the 
<TT
CLASS="FILENAME"
>/etc/inittab</TT
> file</H1
><P
>When it starts up, <B
CLASS="COMMAND"
>init</B
> reads the 
	<TT
CLASS="FILENAME"
>/etc/inittab</TT
>
	configuration file. While the system is running, it will
	re-read it, if sent the HUP signal (<B
CLASS="COMMAND"
>kill -HUP 1</B
>);
	this feature makes it unnecessary to boot the system to make
	changes to the <B
CLASS="COMMAND"
>init</B
> configuration take
	effect.</P
><P
>The <TT
CLASS="FILENAME"
>/etc/inittab</TT
> file is
	a bit complicated. We'll start with the simple case
	of configuring <B
CLASS="COMMAND"
>getty</B
> lines.	Lines in
	<TT
CLASS="FILENAME"
>/etc/inittab</TT
> consist of four colon-delimited
	fields:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>id:runlevels:action:process</PRE
></FONT
></TD
></TR
></TABLE
>

	The fields are described below. In addition,
	<TT
CLASS="FILENAME"
>/etc/inittab</TT
> can contain empty lines, and
	lines that begin with a number sign (`<TT
CLASS="LITERAL"
>#</TT
>');
	these are both ignored.
	
	<DIV
CLASS="GLOSSLIST"
><DL
><DT
><B
>id</B
></DT
><DD
><P
>		This identifies the line in the file. For
		<B
CLASS="COMMAND"
>getty</B
> lines, it specifies the terminal
		it runs on (the characters after <TT
CLASS="FILENAME"
>/dev/tty</TT
>
		in the device file name). For other lines,
		it doesn't matter (except for length restrictions),
		but it should be unique.
		</P
></DD
><DT
><B
>runlevels</B
></DT
><DD
><P
>		The run levels the line should be considered
		for. The run levels are given as single digits,
		without delimiters. (Run levels are described
		in the next section.)
		</P
></DD
><DT
><B
>action</B
></DT
><DD
><P
>		What action should be taken by the line, e.g.,
		<TT
CLASS="LITERAL"
>respawn</TT
> to run the command in the
		next field again, when it exits, or <TT
CLASS="LITERAL"
>once</TT
>
		to run it just once.
		</P
></DD
><DT
><B
>process</B
></DT
><DD
><P
>		The command to run.
		</P
></DD
></DL
></DIV
>

	To start a <B
CLASS="COMMAND"
>getty</B
> on the first virtual terminal
	(<TT
CLASS="FILENAME"
>/dev/tty1</TT
>), in all the normal multi-user
	run levels (2-5), one would write the following line:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>1:2345:respawn:/sbin/getty 9600 tty1</PRE
></FONT
></TD
></TR
></TABLE
>

	The first field says that this is the line for 
	<TT
CLASS="FILENAME"
>/dev/tty1</TT
>.
	The second field says that it applies to run levels 2, 3, 4,
	and 5. The third field means that the command should be run
	again, after it exits (so that one can log in, log out, and
	then log in again). The last field is the command that runs
	<B
CLASS="COMMAND"
>getty</B
> on the first virtual terminal.</P
><P
>Different versions of <B
CLASS="COMMAND"
>getty</B
> are run 
	differently. Consult your manual page, and make sure it is
	the correct  manual page.</P
><P
>If you wanted to add terminals or dial-in modem lines to a
	system, you'd add more lines to <TT
CLASS="FILENAME"
>/etc/inittab</TT
>,
	one for each terminal or dial-in line. For more details, see the
	manual pages <B
CLASS="COMMAND"
>init</B
>, <TT
CLASS="FILENAME"
>inittab</TT
>,
	and <B
CLASS="COMMAND"
>getty</B
>.</P
><P
>If a command fails when it starts,
	and <B
CLASS="COMMAND"
>init</B
> is configured to
	<TT
CLASS="LITERAL"
>restart</TT
> it, it will use a lot of
	system resources: <B
CLASS="COMMAND"
>init</B
> starts it,
	it fails, <B
CLASS="COMMAND"
>init</B
> starts it, it fails,
	<B
CLASS="COMMAND"
>init</B
> starts it, it fails, and so on, ad
	infinitum. To prevent this, <B
CLASS="COMMAND"
>init</B
> will keep
	track of how often it restarts a command, and if the frequency
	grows to high, it will delay for five minutes before restarting
	again.	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="RUN-LEVELS-INTRO"
></A
>9.3. Run levels</H1
><P
>A <I
CLASS="GLOSSTERM"
>run level</I
> is a state of
	<B
CLASS="COMMAND"
>init</B
> and the whole system that defines what
	system services are operating. Run levels are identified by
	numbers. Some system administrators 
	use run levels to define which subsystems are working, e.g.,
	whether X is running, whether the network is operational, and
	so on. Others have all subsystems always running or start and
	stop them individually, without changing run levels, since run
	levels are too coarse for controlling their systems.  You need
	to decide for yourself, but it might be easiest to follow the
	way your Linux distribution does things.</P
><P
>The following table defines how most Linux Distributions
	define the different run levels.  However, run-levels 2 through 5 
	can be modified to suit your own tastes.</P
><DIV
CLASS="TABLE"
><A
NAME="RUN-LEVELS-TABLE"
></A
><P
><B
>Table 9-1. Run level numbers</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>0</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Halt the system.</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Single-user mode (for special 
			administration).</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>2</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Local Multiuser with Networking
			but without network service (like NFS)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>3</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Full Multiuser with Networking 
			</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>4</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Not Used 
			</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>5</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Full Multiuser with Networking
			and X Windows(GUI)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>6</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>Reboot.</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Services that get started at a certain runtime are determined
	by the contents of the various <TT
CLASS="FILENAME"
>rcN.d</TT
> directories. 
	Most distributions locate these directories either at
	<TT
CLASS="FILENAME"
>/etc/init.d/rcN.d</TT
> or 
	<TT
CLASS="FILENAME"
>/etc/rcN.d</TT
>. (Replace the N with the run-level
	number.)</P
><P
>		
	</P
><P
>In each run-level you will find a series of if links pointing 
	to start-up scripts located in <TT
CLASS="FILENAME"
>/etc/init.d</TT
>.  
	The names of these links all start as either K or S, followed by a 
	number.  If the name of the link starts with an S, then that indicates
	the service will be started when you go into that run level.  If the 
	name of the link starts with a K, the service will be killed (if 
	running).</P
><P
>The number following the K or S indicates the order the scripts
	will be run.  Here is a sample of what an 
	<TT
CLASS="FILENAME"
>/etc/init.d/rc3.d</TT
> may look like.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>ls -l /etc/init.d/rc3.d</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>lrwxrwxrwx  1 root root 10 2004-11-29 22:09 K12nfsboot -&#62; ../nfsboot
lrwxrwxrwx  1 root root  6 2005-03-29 13:42 K15xdm -&#62; ../xdm
lrwxrwxrwx  1 root root  9 2004-11-29 22:08 S01pcmcia -&#62; ../pcmcia
lrwxrwxrwx  1 root root  9 2004-11-29 22:06 S01random -&#62; ../random
lrwxrwxrwx  1 root root 11 2005-03-01 11:56 S02firewall -&#62; ../firewall
lrwxrwxrwx  1 root root 10 2004-11-29 22:34 S05network -&#62; ../network
lrwxrwxrwx  1 root root  9 2004-11-29 22:07 S06syslog -&#62; ../syslog
lrwxrwxrwx  1 root root 10 2004-11-29 22:09 S08portmap -&#62; ../portmap
lrwxrwxrwx  1 root root  9 2004-11-29 22:07 S08resmgr -&#62; ../resmgr
lrwxrwxrwx  1 root root  6 2004-11-29 22:09 S10nfs -&#62; ../nfs
lrwxrwxrwx  1 root root 12 2004-11-29 22:40 S12alsasound -&#62; ../alsasound
lrwxrwxrwx  1 root root  8 2004-11-29 22:09 S12fbset -&#62; ../fbset
lrwxrwxrwx  1 root root  7 2004-11-29 22:10 S12sshd -&#62; ../sshd
lrwxrwxrwx  1 root root  8 2005-02-01 09:24 S12xntpd -&#62; ../xntpd
lrwxrwxrwx  1 root root  7 2004-12-02 20:34 S13cups -&#62; ../cups
lrwxrwxrwx  1 root root  6 2004-11-29 22:09 S13kbd -&#62; ../kbd
lrwxrwxrwx  1 root root 13 2004-11-29 22:10 S13powersaved -&#62; ../powersaved
lrwxrwxrwx  1 root root  9 2004-11-29 22:09 S14hwscan -&#62; ../hwscan
lrwxrwxrwx  1 root root  7 2004-11-29 22:10 S14nscd -&#62; ../nscd
lrwxrwxrwx  1 root root 10 2004-11-29 22:10 S14postfix -&#62; ../postfix
lrwxrwxrwx  1 root root  6 2005-02-04 13:27 S14smb -&#62; ../smb
lrwxrwxrwx  1 root root  7 2004-11-29 22:10 S15cron -&#62; ../cron
lrwxrwxrwx  1 root root  8 2004-12-22 20:35 S15smbfs -&#62; ../smbfs</TT
>
<TT
CLASS="PROMPT"
></TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	</P
><P
>How run levels start are configured in 
	<TT
CLASS="FILENAME"
>/etc/inittab</TT
> by lines like the following:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>l2:2:wait:/etc/init.d/rc 2</PRE
></FONT
></TD
></TR
></TABLE
>

	The first field is an arbitrary label, the second one means
	that this applies for run level 2. The third field means
	that <B
CLASS="COMMAND"
>init</B
> should run the command in the
	fourth field once, when the run level is entered, and that
	<B
CLASS="COMMAND"
>init</B
> should wait for it to complete. The
	<TT
CLASS="FILENAME"
>/etc/init.d/rc</TT
> command runs whatever
	commands are necessary to start and stop services to enter run
	level 2.</P
><P
>The command in the fourth field does all the hard work of
	setting up a run level. It starts services that aren't already
	running, and stops services that shouldn't be running in the
	new run level any more. Exactly what the command is, and how run
	levels are configured, depends on the Linux distribution.</P
><P
>When <B
CLASS="COMMAND"
>init</B
> starts, it looks for a line
	in <TT
CLASS="FILENAME"
>/etc/inittab</TT
> that specifies the default
	run level:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>id:2:initdefault:</PRE
></FONT
></TD
></TR
></TABLE
>

	You can ask <B
CLASS="COMMAND"
>init</B
> to go to a non-default run
	level at startup by giving the kernel a command line argument
	of <TT
CLASS="LITERAL"
>single</TT
> or <TT
CLASS="LITERAL"
>emergency</TT
>.
	Kernel command line arguments can be given via LILO, for example.
	This allows you to choose the single user mode (run level 1).</P
><P
>While the system is running, the <B
CLASS="COMMAND"
>telinit</B
>
	command can change the run level. When the run level is
	changed, <B
CLASS="COMMAND"
>init</B
> runs the relevant command from
	<TT
CLASS="FILENAME"
>/etc/inittab</TT
>.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="INITTAB"
></A
>9.4. Special configuration in 
<TT
CLASS="FILENAME"
>/etc/inittab</TT
></H1
><P
>The <TT
CLASS="FILENAME"
>/etc/inittab</TT
> has some special
	features that allow <B
CLASS="COMMAND"
>init</B
> to react to special
	circumstances. These special features are marked by special
	keywords in the third field.  Some examples:
	
	<DIV
CLASS="GLOSSLIST"
><DL
><DT
><B
><TT
CLASS="LITERAL"
>powerwait</TT
></B
></DT
><DD
><P
>		Allows <B
CLASS="COMMAND"
>init</B
> to shut the system
		down, when the power fails. This assumes the use of
		a UPS, and software that watches the UPS and informs
		<B
CLASS="COMMAND"
>init</B
> that the power is off.
		</P
></DD
><DT
><B
><TT
CLASS="LITERAL"
>ctrlaltdel</TT
></B
></DT
><DD
><P
>		Allows <B
CLASS="COMMAND"
>init</B
> to reboot the system, when
		the user presses ctrl-alt-del on the console keyboard.
		Note that the system administrator can configure the
		reaction to ctrl-alt-del to be something else instead,
		e.g., to be ignored, if the system is in a public
		location. (Or to start <B
CLASS="COMMAND"
>nethack</B
>.)
		</P
></DD
><DT
><B
><TT
CLASS="LITERAL"
>sysinit</TT
></B
></DT
><DD
><P
>		Command to be run when the system is booted. This command
		usually cleans up <TT
CLASS="FILENAME"
>/tmp</TT
>, for example.
		</P
></DD
></DL
></DIV
>
	
	The list above is not exhaustive. See your
	<TT
CLASS="FILENAME"
>inittab</TT
> manual page for all possibilities,
	and for details on how to use the above ones.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="BOOT-SINGLE-USER"
></A
>9.5. Booting in single user mode</H1
><P
>An important run level is <I
CLASS="GLOSSTERM"
>single user 
	mode</I
> (run level 1),
	in which only the system administrator is using the machine
	and as few system services, including logins, as possible are
	running. Single user mode is necessary for a few administrative
	tasks, such as running <B
CLASS="COMMAND"
>fsck</B
> on a
	<TT
CLASS="FILENAME"
>/usr</TT
> partition, since this requires that
	the partition be unmounted, and that can't happen, unless just
	about all system services are killed.</P
><P
>A running system can be taken to single user mode by using
	<B
CLASS="COMMAND"
>telinit</B
> to request run level 1. At bootup,
	it can be entered by giving the word <TT
CLASS="LITERAL"
>single</TT
>
	or <TT
CLASS="LITERAL"
>emergency</TT
> on the kernel command line: the
	kernel gives the command line to <B
CLASS="COMMAND"
>init</B
> as well,
	and <B
CLASS="COMMAND"
>init</B
> understands from that word that it
	shouldn't use the default run level. (The kernel command line is
	entered in a way that depends on how you boot the system.)</P
><P
>Booting into single user mode is sometimes necessary so
	that one can run <B
CLASS="COMMAND"
>fsck</B
> by hand, before anything
	mounts or otherwise touches a broken <TT
CLASS="FILENAME"
>/usr</TT
>
	partition (any activity on a broken filesystem is likely to
	break it more, so <B
CLASS="COMMAND"
>fsck</B
> should be run as soon
	as possible).</P
><P
>The bootup scripts <B
CLASS="COMMAND"
>init</B
> runs
	will automatically enter single user mode, if the automatic
	<B
CLASS="COMMAND"
>fsck</B
> at bootup fails. This is an attempt to
	prevent the system from using a filesystem that is so broken that
	<B
CLASS="COMMAND"
>fsck</B
> can't fix it automatically. Such breakage
	is relatively rare, and usually involves a broken hard disk or an
	experimental kernel release, but it's good to be prepared.</P
><P
>As a security measure, a properly configured system
	will ask for the root password before starting the shell in
	single user mode. Otherwise, it would be simple to just enter
	a suitable line to LILO to get in as root. (This will break if
	<TT
CLASS="FILENAME"
>/etc/passwd</TT
> has been broken by filesystem
	problems, of course, and in that case you'd better have a boot
	floppy handy.)</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="LOG-IN-AND-OUT"
></A
>Chapter 10. Logging In And Out</H1
><A
NAME="AEN3982"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"I don't care to belong to a club
	that accepts people like me as a member."</SPAN
>
	(Groucho Marx)</P
></BLOCKQUOTE
><P
>	This section describes what happens when a user logs
	in or out.  The various interactions of background processes,
	log files, configuration files, and so on are described in
	some detail.
	</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="LOGIN-VIA-TERMINAL"
></A
>10.1. Logins via terminals</H1
><P
><A
HREF="#TERMINAL-LOGINS"
>Section 2.3.2</A
> shows how logins happen via
	terminals.  First, <B
CLASS="COMMAND"
>init</B
> makes sure there is
	a <B
CLASS="COMMAND"
>getty</B
> program for the terminal connection
	(or console).  <B
CLASS="COMMAND"
>getty</B
> listens at the terminal
	and waits for the user to notify that he is ready to login in
	(this usually means that the user must type something).  When it
	notices a user, <B
CLASS="COMMAND"
>getty</B
> outputs a welcome message
	(stored in <TT
CLASS="FILENAME"
>/etc/issue</TT
>), and prompts for
	the username, and finally runs the <B
CLASS="COMMAND"
>login</B
>
	program.  <B
CLASS="COMMAND"
>login</B
> gets the username as a
	parameter, and prompts the user for the password.  If these
	match, <B
CLASS="COMMAND"
>login</B
> starts the shell configured
	for the user; else it just exits and terminates the process
	(perhaps after giving the user another chance at entering the
	username and password).  <B
CLASS="COMMAND"
>init</B
> notices that
	the process terminated, and starts a new <B
CLASS="COMMAND"
>getty</B
>
	for the terminal.
	</P
><DIV
CLASS="FIGURE"
><A
NAME="TERMINAL-LOGINS-TABLE"
></A
><P
><B
>Figure 10-1. Logins via terminals: the interaction of 
<B
CLASS="COMMAND"
>init</B
>, 
<B
CLASS="COMMAND"
>getty</B
>, <B
CLASS="COMMAND"
>login</B
>, and the 
shell.</B
></P
><P
><IMG
SRC="logins-via-terminals.png"></P
></DIV
><P
> Note that the only new process is the
	one created by <B
CLASS="COMMAND"
>init</B
> (using the
	<TT
CLASS="FUNCTION"
>fork</TT
> system call); <B
CLASS="COMMAND"
>getty</B
>
	and <B
CLASS="COMMAND"
>login</B
> only replace the program running in
	the process (using the <TT
CLASS="FUNCTION"
>exec</TT
> system call).
	</P
><P
> A separate program, for noticing the user, is needed
	for serial lines, since it can be (and traditionally was)
	complicated to notice when a terminal becomes active.
	<B
CLASS="COMMAND"
>getty</B
> also adapts to the speed and other
	settings of the connection, which is important especially for
	dial-in connections, where these parameters may change from call
	to call.  </P
><P
> There are several versions of <B
CLASS="COMMAND"
>getty</B
>
	and <B
CLASS="COMMAND"
>init</B
> in use, all with their good and
	bad points.  It is a good idea to learn about the versions on
	your system, and also about the other versions (you could use the
	Linux Software Map to search them).  If you don't have dial-ins,
	you probably don't have to worry about <B
CLASS="COMMAND"
>getty</B
>,
	but <B
CLASS="COMMAND"
>init</B
> is still important.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="LOGIN-VIA-NETWORK"
></A
>10.2. Logins via the network</H1
><P
>Two computers in the same network are usually linked via a
	single physical cable.	When they communicate over the network,
	the programs in each computer that take part in the communication
	are linked via a <I
CLASS="GLOSSTERM"
>virtual connection</I
>, a sort
	of imaginary cable.  As far as the programs at either end of the
	virtual connection are concerned, they have a monopoly on their
	own cable.  However, since the cable is not real, only imaginary,
	the operating systems of both computers can have several virtual
	connections share the same physical cable.  This way, using just
	a single cable, several programs can communicate without having
	to know of or care about the other communications.  It is even
	possible to have several computers use the same cable; the virtual
	connections exist between two computers, and the other computers
	ignore those connections that they don't take part in.	</P
><P
> That's a complicated and over-abstracted description of
	the reality.  It might, however, be good enough to understand
	the important reason why network logins are somewhat different
	from normal logins.  The virtual connections are established
	when there are two programs on different computers that wish
	to communicate.  Since it is in principle possible to login
	from any computer in a network to any other computer, there is
	a huge number of potential virtual communications.  Because of
	this, it is not practical to start a <B
CLASS="COMMAND"
>getty</B
>
	for each potential login.  </P
><P
> There is a single process inetd (corresponding to
	<B
CLASS="COMMAND"
>getty</B
>) that handles all network logins.
	When it notices an incoming network login (i.e., it notices
	that it gets a new virtual connection to some other computer),
	it starts a new process to handle that single login.  The original
	process remains and continues to listen for new logins.  </P
><P
> To make things a bit more complicated, there is
	more than one communication protocol for network logins.
	The two most important ones are <B
CLASS="COMMAND"
>telnet</B
> and
	<B
CLASS="COMMAND"
>rlogin</B
>.  In addition to logins, there are many
	other virtual connections that may be made (for FTP, Gopher, HTTP,
	and other network services).  It would be ineffective to have a
	separate process listening for a particular type of connection,
	so instead there is only one listener that can recognize the type
	of the connection and can start the correct type of program to
	provide the service.  This single listener is called 
<B
CLASS="COMMAND"
>inetd</B
>;
	see the <I
CLASS="CITETITLE"
>Linux Network Administrators' Guide</I
>
	for more information.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="WHAT-LOGIN-DOES"
></A
>10.3. What <B
CLASS="COMMAND"
>login</B
> does</H1
><P
>The <B
CLASS="COMMAND"
>login</B
> program takes care of
	authenticating the user (making sure that the username and
	password match), and of setting up an initial environment for
	the user by setting permissions for the serial line and starting
	the shell.  </P
><P
> Part of the initial setup is outputting the contents of
	the file <TT
CLASS="FILENAME"
>/etc/motd</TT
> (short for message of the
	day) and checking for electronic mail.	These can be disabled
	by creating a file called <TT
CLASS="FILENAME"
>.hushlogin</TT
> in
	the user's home directory.  </P
><P
> If the file <TT
CLASS="FILENAME"
>/etc/nologin</TT
>
	exists, logins are disabled.  That file is typically
	created by <B
CLASS="COMMAND"
>shutdown</B
> and relatives.
	<B
CLASS="COMMAND"
>login</B
> checks for this file, and will
	refuse to accept a login if it exists.	If it does exist,
	<B
CLASS="COMMAND"
>login</B
> outputs its contents to the terminal
	before it quits.  </P
><P
> <B
CLASS="COMMAND"
>login</B
> logs all failed login attempts in
	a system log file (via <B
CLASS="COMMAND"
>syslog</B
>).  It also logs
	all logins by root.  Both of these can be useful when tracking
	down intruders.  </P
><P
> Currently logged in people are listed in
	<TT
CLASS="FILENAME"
>/var/run/utmp</TT
>.  This file is valid only
	until the system is next rebooted or shut down; it is cleared
	when the system is booted.  It lists each user and the terminal
	(or network connection) he is using, along with some other useful
	information.  The <B
CLASS="COMMAND"
>who</B
>, <B
CLASS="COMMAND"
>w</B
>,
	and other similar commands look in <TT
CLASS="FILENAME"
>utmp</TT
>
	to see who are logged in.  </P
><P
> All successful logins are recorded into
	<TT
CLASS="FILENAME"
>/var/log/wtmp</TT
>.  This file will grow without
	limit, so it must be cleaned regularly, for example by having
	a weekly <B
CLASS="COMMAND"
>cron</B
> job to clear it.
	The <B
CLASS="COMMAND"
>last</B
> command browses
	<TT
CLASS="FILENAME"
>wtmp</TT
>.  </P
><P
> Both <TT
CLASS="FILENAME"
>utmp</TT
> and
	<TT
CLASS="FILENAME"
>wtmp</TT
> are in a binary format (see the
	<TT
CLASS="FILENAME"
>utmp</TT
> manual page); it is unfortunately not
	convenient to examine them without special programs.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="X-XDM"
></A
>10.4. X and xdm</H1
><P
> XXX X implements logins via xdm; also: xterm -ls </P
><P
>TO BE ADDED</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="ACCESS-CONTROL"
></A
>10.5. Access control</H1
><P
> The user database is traditionally contained in the
	<TT
CLASS="FILENAME"
>/etc/passwd</TT
> file.	Some systems use
	<I
CLASS="GLOSSTERM"
>shadow passwords</I
>, and have moved the
	passwords to <B
CLASS="COMMAND"
>/etc/shadow</B
>.  Sites with many
	computers that share the accounts use NIS or some other method
	to store the user database; they might also automatically copy
	the database from one central location to all other computers.
	</P
><P
> The user database contains not only the passwords, but
	also some additional information about the users, such as their
	real names, home directories, and login shells.  This other
	information needs to be public, so that anyone can read it.
	Therefore the password is stored encrypted.  This does have
	the drawback that anyone with access to the encrypted password
	can use various cryptographic methods to guess it, without
	trying to actually log into the computer.  Shadow passwords try
	to avoid this by moving the password into another file, which
	only root can read (the password is still stored encrypted).
	However, installing shadow passwords later onto a system that
	did not support them can be difficult.	</P
><P
> With or without passwords, it is important to make
	sure that all passwords in a system are good, i.e., not easily
	guessed.  The <B
CLASS="COMMAND"
>crack</B
> program can be used
	to crack passwords; any password it can find is by definition
	not a good one.  While <B
CLASS="COMMAND"
>crack</B
> can be run
	by intruders, it can also be run by the system administrator
	to avoid bad passwords.  Good passwords can also be enforced
	by the <B
CLASS="COMMAND"
>passwd</B
> program; this is in fact more
	effective in CPU cycles, since cracking passwords requires quite
	a lot of computation.  </P
><P
> The user group database is kept in
	<TT
CLASS="FILENAME"
>/etc/group</TT
>; for systems with shadow
	passwords, there can be a <TT
CLASS="FILENAME"
>/etc/shadow.group</TT
>.
	</P
><P
> root usually can't login via most terminals
	or the network, only via terminals listed in the
	<TT
CLASS="FILENAME"
>/etc/securetty</TT
> file.  This makes it necessary
	to get physical access to one of these terminals.  It is, however,
	possible to log in via any terminal as any other user, and use
	the <B
CLASS="COMMAND"
>su</B
> command to become root.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SHELL-STARTUP"
></A
>10.6. Shell startup</H1
><P
> When an interactive login shell starts, it automatically
	executes one or more pre-defined files.  Different shells execute
	different files; see the documentation of each shell for further
	information.  </P
><P
> Most shells first run some global file, for example, the
	Bourne shell (<B
CLASS="COMMAND"
>/bin/sh</B
>) and its derivatives
	execute <TT
CLASS="FILENAME"
>/etc/profile</TT
>; in addition,
	they execute <TT
CLASS="FILENAME"
>.profile</TT
> in the user's
	home directory.  <TT
CLASS="FILENAME"
>/etc/profile</TT
> allows the
	system administrator to have set up a common user environment,
	especially by setting the <TT
CLASS="ENVAR"
>PATH</TT
> to include local
	command directories in addition to the normal ones.  On the other
	hand, <TT
CLASS="FILENAME"
>.profile</TT
> allows the user to customize
	the environment to his own tastes by overriding, if necessary,
	the default environment.  </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="MANAGING-USERS"
></A
>Chapter 11. Managing user accounts</H1
><A
NAME="AEN4095"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"The similarities of sysadmins and drug
	dealers: both measure stuff in Ks, and both have users."</SPAN
>
	(Old, tired computer joke.)</P
></BLOCKQUOTE
><P
> This chapter explains how to create new user accounts,
	how to modify the properties of those accounts, and how to remove
	the accounts.  Different Linux systems have different tools for
	doing this.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="ACCOUNT"
></A
>11.1. What's an account?</H1
><P
> When a computer is used by many people it is usually
	necessary to differentiate between the users, for example, so that
	their private files can be kept private.  This is important even
	if the computer can only be used by a single person at a time,
	as with most microcomputers.  Thus, each user is given a unique 
	username, and that name is used to log in.</P
><P
> There's more to a user than just a name, however. An
	<I
CLASS="GLOSSTERM"
>account</I
> is all the files, resources,
	and information belonging to one user. The term hints at banks,
	and in a commercial system each account usually has some money
	attached to it, and that money vanishes at different speeds
	depending on how much the user stresses the system. For example,
	disk space might have a price per megabyte and day, and processing
	time might have a price per second.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="ADDUSER"
></A
>11.2. Creating a user</H1
><P
> The Linux kernel itself treats users are mere numbers.
	Each user is identified by a unique integer, the <I
CLASS="GLOSSTERM"
>user
	id</I
> or <I
CLASS="GLOSSTERM"
>uid</I
>, because numbers are
	faster and easier for a computer to process than textual names.
	A separate database outside the kernel assigns a textual name,
	the <I
CLASS="GLOSSTERM"
>username</I
>, to each user id.  The database
	contains additional information as well.  </P
><P
> To create a user, you need to add information about
	the user to the user database, and create a home directory for
	him. It may also be necessary to educate the user, and set up
	a suitable initial environment for him.  </P
><P
> Most Linux distributions come with a program for
	creating accounts. There are several such programs available.
	Two command line alternatives are <B
CLASS="COMMAND"
>adduser</B
>
	and <B
CLASS="COMMAND"
>useradd</B
>; there may be a GUI tool as well.
	Whatever the program, the result is that there is little if
	any manual work to be done. Even if the details are many and
	intricate, these programs make everything seem trivial.  However,
	<A
HREF="#MANUAL-ADDUSER"
>Section 11.2.4</A
> describes how to do it by hand.
	</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="ETC-PASSWD"
></A
>11.2.1. <TT
CLASS="FILENAME"
>/etc/passwd</TT
> and other informative 
files</H2
><P
> The basic user database in a Unix system is the text file,
	<TT
CLASS="FILENAME"
>/etc/passwd</TT
> (called the <I
CLASS="GLOSSTERM"
>password
	file</I
>), which lists all valid usernames and their
	associated information. The file has one line per username,
	and is divided into seven colon-delimited fields:

	<P
></P
><UL
><LI
><P
>Username.</P
></LI
><LI
><P
>Previously this was where the user's password was stored.
		</P
></LI
><LI
><P
>Numeric user id.</P
></LI
><LI
><P
>Numeric group id.</P
></LI
><LI
><P
>Full name or other description of 
		account.</P
></LI
><LI
><P
>Home directory.</P
></LI
><LI
><P
>Login shell (program to run at 
		login).</P
></LI
></UL
>

	The format is explained in more detail on the
	<TT
CLASS="FILENAME"
>passwd</TT
> manual page.  </P
><P
>	Most Linux systems use <I
CLASS="GLOSSTERM"
>shadow passwords</I
>. 
	As mentioned, previously passwords were stored in the 
	<TT
CLASS="FILENAME"
>/etc/passwd</TT
> file.  This newer method
	of storing the password: the encrypted
	password is stored in a separate file, 
	<TT
CLASS="FILENAME"
>/etc/shadow</TT
>,
	which only root can read. The <TT
CLASS="FILENAME"
>/etc/passwd</TT
>
	file only contains a special marker in the second field.
	Any program that needs to verify a user is setuid, and
	can therefore access the shadow password file. Normal
	programs, which only use the other fields in the password
	file, can't get at the password.
	</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="UID-GID"
></A
>11.2.2. Picking numeric user and group ids</H2
><P
> On most systems it doesn't matter what the numeric user
	and group ids are, but if you use the Network filesystem (NFS),
	you need to have the same uid and gid on all systems. This
	is because NFS also identifies users with the numeric uids.
	If you aren't using NFS, you can let your account creation tool
	pick them automatically.  </P
><P
> If you are using NFS, you'll have to be invent a mechanism
	for synchronizing account information. One alternative is to
	the NIS system (see XXX network-admin-guide).  </P
><P
> However, you should try to avoid re-using numeric uids
	(and textual usernames), because the new owner of the uid (or
	username) may get access to the old owner's files (or mail,
	or whatever).  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="ETC-SKEL"
></A
>11.2.3. Initial environment: <TT
CLASS="FILENAME"
>/etc/skel</TT
></H2
><P
> When the home directory for a new user is created, it is
	initialized with files from the <TT
CLASS="FILENAME"
>/etc/skel</TT
>
	directory.  The system administrator can create files in
	<TT
CLASS="FILENAME"
>/etc/skel</TT
> that will provide a nice
	default environment for users.	For example, he might create a
	<TT
CLASS="FILENAME"
>/etc/skel/.profile</TT
> that sets the EDITOR
	environment variable to some editor that is friendly towards
	new users.  </P
><P
> However, it is usually best to try to keep
	<TT
CLASS="FILENAME"
>/etc/skel</TT
> as small as possible, since it
	will be next to impossible to update existing users' files. For
	example, if the name of the friendly editor changes, all existing
	users would have to edit their <TT
CLASS="FILENAME"
>.profile</TT
>. The
	system administrator could try to do it automatically, with a
	script, but that is almost certain going to break someone's file.
	</P
><P
> Whenever possible, it is better to put global configuration
	into global files, such as <TT
CLASS="FILENAME"
>/etc/profile</TT
>. This
	way it is possible to update it without breaking users'
	own setups.  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="MANUAL-ADDUSER"
></A
>11.2.4. Creating a user by hand</H2
><P
> To create a new account manually, follow these steps:


	<P
></P
><UL
><LI
><P
> Edit <TT
CLASS="FILENAME"
>/etc/passwd</TT
> with
	<B
CLASS="COMMAND"
>vipw</B
> and add a new line for the new account. Be
	careful with the syntax. <EM
>Do not edit directly with an
	editor!</EM
> <B
CLASS="COMMAND"
>vipw</B
> locks the file, so
	that other commands won't try to update it at the same time. You
	should make the password field be `<TT
CLASS="LITERAL"
>*</TT
>', so
	that it is impossible to log in.  </P
></LI
><LI
><P
> Similarly, edit <TT
CLASS="FILENAME"
>/etc/group</TT
>
	with <B
CLASS="COMMAND"
>vigr</B
>, if you need to create a new group
	as well.  </P
></LI
><LI
><P
> Create the home directory of the user with
	<B
CLASS="COMMAND"
>mkdir</B
>.  </P
></LI
><LI
><P
> Copy the files from
	<TT
CLASS="FILENAME"
>/etc/skel</TT
> to the new home directory.
	</P
></LI
><LI
><P
> Fix ownerships and permissions with
	<B
CLASS="COMMAND"
>chown</B
> and <B
CLASS="COMMAND"
>chmod</B
>. The
	<TT
CLASS="OPTION"
>-R</TT
> option is most useful.  The correct
	permissions vary a little from one site to another, but usually
	the following commands do the right thing:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="USERINPUT"
><B
>cd /home/newusername
chown -R username.group .
chmod -R go=u,go-w .
chmod go= .</B
></TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	</P
></LI
><LI
><P
> Set the password with <B
CLASS="COMMAND"
>passwd</B
>.
	</P
></LI
></UL
>
	</P
><P
> After you set the password in the last step, the account
	will work. You shouldn't set it until everything else has been
	done, otherwise the user may inadvertently log in while you're
	still copying the files.  </P
><P
>	It is sometimes necessary to create dummy
	accounts
	that are not used by people. For example, to set up an anonymous
	FTP server (so that anyone can download files from it, without
	having to get an account first), you need to create an account
	called ftp. In such cases, it is usually not necessary to set
	the password (last step above).  Indeed, it is better not to, so
	that no-one can use the account, unless they first become root,
	since root can become any user.  </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="USER-PROPERTIES"
></A
>11.3. Changing user properties</H1
><P
>	There are a few commands for changing various
	properties of an account (i.e., the relevant field
	in <TT
CLASS="FILENAME"
>/etc/passwd</TT
>):

	<DIV
CLASS="GLOSSLIST"
><DL
><DT
><B
><B
CLASS="COMMAND"
>chfn</B
></B
></DT
><DD
><P
> Change the full name field.
		</P
></DD
><DT
><B
><B
CLASS="COMMAND"
>chsh</B
></B
></DT
><DD
><P
> Change the login shell.
		</P
></DD
><DT
><B
><B
CLASS="COMMAND"
>passwd</B
></B
></DT
><DD
><P
>Change the password.
		</P
></DD
></DL
></DIV
>

	The super-user may use these commands to change the properties
	of any account. Normal users can only change the properties
	of their own account. It may sometimes be necessary to disable
	these commands (with <B
CLASS="COMMAND"
>chmod</B
>) for normal users,
	for example in an environment with many novice users.  </P
><P
>	Other tasks need to be done by hand. For example, to
	change the username, you need to edit 
	<TT
CLASS="FILENAME"
>/etc/passwd</TT
>
	directly (with <B
CLASS="COMMAND"
>vipw</B
>, remember). Likewise, to add
	or remove the user to more groups, you need to edit
	<TT
CLASS="FILENAME"
>/etc/group</TT
> (with <B
CLASS="COMMAND"
>vigr</B
>). Such 
	tasks tend to
	be rare, however, and should be done with caution: for
	example, if
	you change the username, e-mail will no longer reach the
	user, unless you also create a mail alias.
	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="DELUSER"
></A
>11.4. Removing a user</H1
><P
> To remove a user, you first remove all
	his files, mailboxes, mail aliases, print jobs,
	<B
CLASS="COMMAND"
>cron</B
> and <B
CLASS="COMMAND"
>at</B
> jobs,
	and all other references to the user.  Then you remove the
	relevant lines from <TT
CLASS="FILENAME"
>/etc/passwd</TT
> and
	<TT
CLASS="FILENAME"
>/etc/group</TT
> (remember to remove the username
	from all groups it's been added to). It may be a good idea to
	first disable the account (see below), before you start removing
	stuff, to prevent the user from using the account while it is
	being removed.	</P
><P
>	Remember that users may have files outside their home
	directory. The <B
CLASS="COMMAND"
>find</B
> command can find them:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>find / -user username</PRE
></FONT
></TD
></TR
></TABLE
>

	However, note that the above command will take a
	<EM
>long</EM
> time, if you have large disks. If you
	mount network disks, you need to be careful so that you won't
	trash the network or the server.  </P
><P
> Some Linux distributions come with special
	commands to do this; look for <B
CLASS="COMMAND"
>deluser</B
> or
	<B
CLASS="COMMAND"
>userdel</B
>.  However, it is easy to do it by
	hand as well, and the commands might not do everything.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="DISABLE-USER"
></A
>11.5. Disabling a user temporarily</H1
><P
> It is sometimes necessary to temporarily disable an
	account, without removing it. For example, the user might not
	have paid his fees, or the system administrator may suspect that
	a cracker has got the password of that account.  </P
><P
> The best way to disable an account is to change its shell
	into a special program that just prints a message. This way,
	whoever tries to log into the account, will fail, and will
	know why. The message can tell the user to contact the system
	administrator so that any problems may be dealt with.  </P
><P
>	It would also be possible to change the username
	or password to something else, but then the user
	won't know what is going on. Confused users mean more
	work.
	</P
><P
> A simple way to create the special programs is to write
	`tail scripts':

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>#!/usr/bin/tail +2
This account has been closed due to a security breach.
Please call 555-1234 and wait for the men in black to arrive.</PRE
></FONT
></TD
></TR
></TABLE
>

	The first two characters (`<TT
CLASS="LITERAL"
>#!</TT
>') tell the
	kernel that the rest of the line is a command that needs to be
	run to interpret this file. The <B
CLASS="COMMAND"
>tail</B
> command
	in this case outputs everything except the first line to the
	standard output.  </P
><P
>	If user billg is suspected of a security breach,
	the system administrator would do something like this:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>chsh -s 
/usr/local/lib/no-login/security billg</B
></TT
>
<TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>su - tester</B
></TT
>
This account has been closed due to a security breach.
Please call 555-1234 and wait for the men in black to arrive.
<TT
CLASS="PROMPT"
>#</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	The purpose of the <B
CLASS="COMMAND"
>su</B
> is to test that the
	change worked, of course.  </P
><P
> Tail scripts should be kept in a separate directory,
	so that their names don't interfere with normal user commands.
	</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="BACKUPS-INTRO"
></A
>Chapter 12. Backups</H1
><A
NAME="AEN4252"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><P
CLASS="LITERALLAYOUT"
>Hardware&nbsp;is&nbsp;indeterministically&nbsp;reliable.&nbsp;<br>
Software&nbsp;is&nbsp;deterministically&nbsp;unreliable.<br>
People&nbsp;are&nbsp;indeterministically&nbsp;unreliable.<br>
Nature&nbsp;is&nbsp;deterministically&nbsp;reliable.</P
></P
></BLOCKQUOTE
><P
> This chapter explains about why, how, and when to make
	backups, and how to restore things from backups.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="BACKUPS"
></A
>12.1. On the importance of being backed up</H1
><P
> Your data is valuable.  It will cost you time and effort
	re-create it, and that costs money or at least personal grief
	and tears; sometimes it can't even be re-created, e.g., if it
	is the results of some experiments.  Since it is an investment,
	you should protect it and take steps to avoid losing it.  </P
><P
> There are basically four reasons why you might lose data:
	hardware failures, software bugs, human action, or natural
	disasters.  Although modern hardware tends to be quite reliable, it 
	can still break seemingly spontaneously.  The most critical piece
	of hardware for storing data is the hard disk, which relies on
	tiny magnetic fields remaining intact in a world filled with
	electromagnetic noise.	Modern software doesn't even tend to
	be reliable; a rock solid program is an exception, not a rule.
	Humans are quite unreliable, they will either make a mistake, or
	they will be malicious and destroy data on purpose.  Nature might
	not be evil, but it can wreak havoc even when being good.  All in
	all, it is a small miracle that anything works at all.	</P
><P
> Backups are a way to protect the investment in data.
	By having several copies of the data, it does not matter as much
	if one is destroyed (the cost is only that of the restoration
	of the lost data from the backup).  </P
><P
> It is important to do backups properly.	Like everything
	else that is related to the physical world, backups will fail
	sooner or later.  Part of doing backups well is to make sure
	they work; you don't want to notice that your backups didn't work.
	Adding insult to injury, you might have a bad crash just as
	you're making the backup; if you have only one backup medium,
	it might destroyed as well, leaving you with the smoking ashes
	of hard work.
	Or you might notice, when trying to restore, that you forgot to
	back up something important, like the user database on a 15000
	user site.  Best of all, all your backups might be working
	perfectly, but the last known tape drive reading the kind of
	tapes you used was the one that now has a bucketful of water
	in it.	</P
><P
> When it comes to backups, paranoia is in the job
	description.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="BACKUP-MEDIA"
></A
>12.2. Selecting the backup medium</H1
><P
> The most important decision regarding backups is the choice
	of backup medium.  You need to consider cost, reliability, speed,
	availability, and usability.  </P
><P
> Cost is important, since you should preferably have
	several times more backup storage than what you need for the data.
	A cheap medium is usually a must.  </P
><P
> Reliability is extremely important, since a broken
	backup can make a grown man cry.  A backup medium must be able
	to hold data without corruption for years.  The way you use the
	medium affects it reliability as a backup medium.  A hard disk
	is typically very reliable, but as a backup medium it is not
	very reliable, if it is in the same computer as the disk you
	are backing up.  </P
><P
> Speed is usually not very important, if backups can be done
	without interaction.  It doesn't matter if a backup takes two
	hours, as long as it needs no supervision.  On the other hand,
	if the backup can't be done when the computer would otherwise
	be idle, then speed is an issue.  </P
><P
> Availability is obviously necessary, since you can't
	use a backup medium if it doesn't exist.  Less obvious is the
	need for the medium to be available even in the future, and on
	computers other than your own.	Otherwise you may not be able
	to restore your backups after a disaster.  </P
><P
> Usability is a large factor in how often backups are made.
	The easier it is to make backups, the better.  A backup medium
	mustn't be hard or boring to use.  </P
><P
> The typical alternatives are floppies and tapes.
	Floppies are very cheap, fairly reliable, not very fast,
	very available, but not very usable for large amounts of data.
	Tapes are cheap to somewhat expensive, fairly reliable, fairly
	fast, quite available, and, depending on the size of the tape,
	quite comfortable.  </P
><P
> There are other alternatives.  They are usually not very
	good on availability, but if that is not a problem, they can
	be better in other ways.  For example, magneto-optical disks
	can have good sides of both floppies (they're random access,
	making restoration of a single file quick) and tapes (contain
	a lot of data).  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="BACKUP-TOOLS"
></A
>12.3. Selecting the backup tool</H1
><P
> There are many tools that can be used to make
	backups.  The traditional UNIX tools used for backups
	are <B
CLASS="COMMAND"
>tar</B
>, <B
CLASS="COMMAND"
>cpio</B
>, and
	<B
CLASS="COMMAND"
>dump</B
>.  In addition, there are large number
	of third party packages (both freeware and commercial) that
	can be used.  The choice of backup medium can affect the choice
	of tool.  </P
><P
> <B
CLASS="COMMAND"
>tar</B
> and <B
CLASS="COMMAND"
>cpio</B
> are
	similar, and mostly equivalent from a backup point of view.
	Both are capable of storing files on tapes, and retrieving
	files from them.  Both are capable of using almost any media,
	since the kernel device drivers take care of the low level
	device handling and the devices all tend to look alike to user
	level programs.  Some UNIX versions of <B
CLASS="COMMAND"
>tar</B
>
	and <B
CLASS="COMMAND"
>cpio</B
> may have problems with unusual files
	(symbolic links, device files, files with very long pathnames, and
	so on), but the Linux versions should handle all files correctly.
	</P
><P
> <B
CLASS="COMMAND"
>dump</B
> is different in that it reads
	the filesystem directly and not via the filesystem.  It is
	also written specifically for backups; <B
CLASS="COMMAND"
>tar</B
>
	and <B
CLASS="COMMAND"
>cpio</B
> are really for archiving files,
	although they work for backups as well.  </P
><P
> Reading the filesystem directly has some advantages.
	It makes it possible to back files up without affecting their time
	stamps; for <B
CLASS="COMMAND"
>tar</B
> and <B
CLASS="COMMAND"
>cpio</B
>,
	you would have to mount the filesystem read-only first.
	Directly reading the filesystem is also more effective, if
	everything needs to be backed up, since it can be done with
	much less disk head movement.  The major disadvantage is that
	it makes the backup program specific to one filesystem type;
	the Linux <B
CLASS="COMMAND"
>dump</B
> program understands the ext2
	filesystem only.  </P
><P
> <B
CLASS="COMMAND"
>dump</B
> also directly supports
	backup levels (which we'll be discussing below); with
	<B
CLASS="COMMAND"
>tar</B
> and <B
CLASS="COMMAND"
>cpio</B
> this has to
	be implemented with other tools.  </P
><P
> A comparison of the third party backup tools is beyond
	the scope of this book.  The Linux Software Map lists many of
	the freeware ones.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SIMPLE-BACKUPS"
></A
>12.4. Simple backups</H1
><P
> A simple backup scheme is to back up everything once,
	then back up everything that has been modified since the
	previous backup.  The first backup is called a <I
CLASS="GLOSSTERM"
>full
	backup</I
>, the subsequent ones are <I
CLASS="GLOSSTERM"
>incremental
	backups</I
>.  A full backup is often more laborious
	than incremental ones, since there is more data to write to the
	tape and a full backup might not fit onto one tape (or floppy).
	Restoring from incremental backups can be many times more work
	than from a full one.  Restoration can be optimized so that
	you always back up everything since the previous full backup;
	this way, backups are a bit more work, but there should never
	be a need to restore more than a full backup and an incremental
	backup.  </P
><P
> If you want to make backups every day and have six
	tapes, you could use tape 1 for the first full backup (say, on
	a Friday), and tapes 2 to 5 for the incremental backups (Monday
	through Thursday).  Then you make a new full backup on tape 6
	(second Friday), and start doing incremental ones with tapes 2
	to 5 again.  You don't want to overwrite tape 1 until you've got
	a new full backup, lest something happens while you're making
	the full backup.  After you've made a full backup to tape 6,
	you want to keep tape 1 somewhere else, so that when your other
	backup tapes are destroyed in the fire, you still have at least
	something left.  When you need to make the next full backup,
	you fetch tape 1 and leave tape 6 in its place.  </P
><P
> If you have more than six tapes, you can use the extra
	ones for full backups.	Each time you make a full backup, you
	use the oldest tape.  This way you can have full backups from
	several previous weeks, which is good if you want to find an old,
	now deleted file, or an old version of a file.	</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="TAR-BACKUPS"
></A
>12.4.1. Making backups with <B
CLASS="COMMAND"
>tar</B
></H2
><P
>	A full backup can easily be made with <B
CLASS="COMMAND"
>tar</B
>:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>tar --create --file /dev/ftape 
/usr/src</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>tar: Removing leading / from absolute path names in 
the archive</TT
>
<TT
CLASS="PROMPT"
>#</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	The example above uses the GNU version of <B
CLASS="COMMAND"
>tar</B
>
	and its long option names.  The traditional version of
	<B
CLASS="COMMAND"
>tar</B
> only understands single character
	options.  The GNU version can also handle backups that don't
	fit on one tape or floppy, and also very long paths; not all
	traditional versions can do these things.  (Linux only uses
	GNU <B
CLASS="COMMAND"
>tar</B
>.)  </P
><P
> If your backup doesn't fit on one tape, you need to use
	the <TT
CLASS="OPTION"
>--multi-volume</TT
> (<TT
CLASS="OPTION"
>-M</TT
>) option:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>tar -cMf /dev/fd0H1440 
/usr/src</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>tar: Removing leading / from absolute path names in 
the archive
Prepare volume #2 for /dev/fd0H1440 and hit return:</TT
>
<TT
CLASS="PROMPT"
>#</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	Note that you should format the floppies before you begin the
	backup, or else use another window or virtual terminal and do
	it when <B
CLASS="COMMAND"
>tar</B
> asks for a new floppy.  </P
><P
> After you've made a backup, you should check that it is OK,
	using the <TT
CLASS="OPTION"
>--compare</TT
> (<TT
CLASS="OPTION"
>-d</TT
>) option:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>tar --compare --verbose -f 
/dev/ftape</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>usr/src/
usr/src/linux
usr/src/linux-1.2.10-includes/
....</TT
>
<TT
CLASS="PROMPT"
>#</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	Failing to check a backup means that you will not notice that your
	backups aren't working until after you've lost the original data.
	</P
><P
> An incremental backup can be done with
	<B
CLASS="COMMAND"
>tar</B
> using the <TT
CLASS="OPTION"
>--newer</TT
>
	(<TT
CLASS="OPTION"
>-N</TT
>) option:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>tar --create --newer '8 Sep 1995' 
--file /dev/ftape /usr/src 
--verbose</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>tar: Removing leading / from absolute path names in 
the archive
usr/src/
usr/src/linux-1.2.10-includes/
usr/src/linux-1.2.10-includes/include/
usr/src/linux-1.2.10-includes/include/linux/
usr/src/linux-1.2.10-includes/include/linux/modules/
usr/src/linux-1.2.10-includes/include/asm-generic/
usr/src/linux-1.2.10-includes/include/asm-i386/
usr/src/linux-1.2.10-includes/include/asm-mips/
usr/src/linux-1.2.10-includes/include/asm-alpha/
usr/src/linux-1.2.10-includes/include/asm-m68k/
usr/src/linux-1.2.10-includes/include/asm-sparc/
usr/src/patch-1.2.11.gz</TT
>
<TT
CLASS="PROMPT"
>#</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	Unfortunately, <B
CLASS="COMMAND"
>tar</B
> can't notice when a file's
	inode information has changed, for example, that its permission
	bits have been changed, or when its name has been changed.
	This can be worked around using <B
CLASS="COMMAND"
>find</B
> and
	comparing current filesystem state with lists of files that have
	been previously backed up.  Scripts and programs for doing this
	can be found on Linux ftp sites.  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="TAR-RESTORE"
></A
>12.4.2. Restoring files with <B
CLASS="COMMAND"
>tar</B
></H2
><P
> The <TT
CLASS="OPTION"
>--extract</TT
> (<TT
CLASS="OPTION"
>-x</TT
>)
	option for <B
CLASS="COMMAND"
>tar</B
> extracts files:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>tar --extract --same-permissions 
--verbose --file 
/dev/fd0H1440</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>usr/src/
usr/src/linux
usr/src/linux-1.2.10-includes/
usr/src/linux-1.2.10-includes/include/
usr/src/linux-1.2.10-includes/include/linux/
usr/src/linux-1.2.10-includes/include/linux/hdreg.h
usr/src/linux-1.2.10-includes/include/linux/kernel.h
...</TT
>
<TT
CLASS="PROMPT"
>#</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	You also extract only specific files or directories (which
	includes all their files and subdirectories) by naming on the
	command line:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>tar xpvf /dev/fd0H1440 
usr/src/linux-1.2.10-includes/include/linux/hdreg.h</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>usr/src/linux-1.2.10-includes/include/linux/hdreg.h</TT
>
<TT
CLASS="PROMPT"
>#</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	Use the <TT
CLASS="OPTION"
>--list</TT
> (<TT
CLASS="OPTION"
>-t</TT
>) option,
	if you just want to see what files are on a backup volume:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>tar --list --file 
/dev/fd0H1440</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>usr/src/
usr/src/linux
usr/src/linux-1.2.10-includes/
usr/src/linux-1.2.10-includes/include/
usr/src/linux-1.2.10-includes/include/linux/
usr/src/linux-1.2.10-includes/include/linux/hdreg.h
usr/src/linux-1.2.10-includes/include/linux/kernel.h
...</TT
>
<TT
CLASS="PROMPT"
>#</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	Note that <B
CLASS="COMMAND"
>tar</B
> always reads the backup volume
	sequentially, so for large volumes it is rather slow.  It is not
	possible, however, to use random access database techniques when
	using a tape drive or some other sequential medium.  </P
><P
> <B
CLASS="COMMAND"
>tar</B
> doesn't handle deleted files
	properly. If you need to restore a filesystem from a full and
	an incremental backup, and you have deleted a file between
	the two backups, it will exist again after you have done the
	restore. This can be a big problem, if the file has sensitive
	data that should no longer be available.  </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="MULTI-LEVEL-BACKUPS"
></A
>12.5. Multilevel backups</H1
><P
> The simple backup method outlined in the previous section
	is often quite adequate for personal use or small sites.  For more
	heavy duty use, multilevel backups are more appropriate.  </P
><P
> The simple method has two backup levels: full and
	incremental backups.  This can be generalized to any number of
	levels.  A full backup would be level 0, and the different levels
	of incremental backups levels 1, 2, 3, etc.  At each incremental
	backup level you back up everything that has changed since the
	previous backup at the same or a previous level.  </P
><P
> The purpose for doing this is that it allows a longer
	<I
CLASS="GLOSSTERM"
>backup history</I
> cheaply.	In the example in
	the previous section, the backup history went back to the previous
	full backup.  This could be extended by having more tapes, but
	only a week per new tape, which might be too expensive.  A longer
	backup history is useful, since deleted or corrupted files are
	often not noticed for a long time.  Even a version of a file that
	is not very up to date is better than no file at all.  </P
><P
> With multiple levels the backup history can be extended
	more cheaply.  For example, if we buy ten tapes, we could use
	tapes 1 and 2 for monthly backups (first Friday each month),
	tapes 3 to 6 for weekly backups (other Fridays; note that there
	can be five Fridays in one month, so we need four more tapes),
	and tapes 7 to 10 for daily backups (Monday to Thursday).
	With only four more tapes, we've been able to extend the backup
	history from two weeks (after all daily tapes have been used)
	to two months.	It is true that we can't restore every version
	of each file during those two months, but what we can restore
	is often good enough.  </P
><P
><A
HREF="#BACKUP-HISTORY-TIMELINE"
>Figure 12-1</A
> shows which backup
	level is used each day, and which backups can be restored from
	at the end of the month.  </P
><DIV
CLASS="FIGURE"
><A
NAME="BACKUP-HISTORY-TIMELINE"
></A
><P
><B
>Figure 12-1. A sample multilevel backup schedule.</B
></P
><P
><IMG
SRC="backup-timeline.png"></P
></DIV
><P
> Backup levels can also be used to keep filesystem
	restoration time to a minimum.	If you have many incremental
	backups with monotonously growing level numbers, you need to
	restore all of them if you need to rebuild the whole filesystem.
	Instead you can use level numbers that aren't monotonous, and
	keep down the number of backups to restore.  </P
><P
> To minimize the number of tapes needed to restore, you
	could use a smaller level for each incremental tape.  However,
	then the time to make the backups increases (each backup copies
	everything since the previous full backup).  A better scheme is
	suggested by the <B
CLASS="COMMAND"
>dump</B
> manual page and described
	by the table XX (efficient-backup-levels).  Use the following
	succession of backup levels: 3, 2, 5, 4, 7, 6, 9, 8, 9, etc.
	This keeps both the backup and restore times low.  The most you
	have to backup is two day's worth of work.  The number of tapes
	for a restore depends on how long you keep between full backups,
	but it is less than in the simple schemes.  </P
><DIV
CLASS="TABLE"
><A
NAME="EFFICIENT-BACKUP-LEVELS"
></A
><P
><B
>Table 12-1. Efficient backup scheme using many backup levels</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
>Tape</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>Level</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>Backup 
(days)</TH
><TH
ALIGN="LEFT"
VALIGN="TOP"
>Restore 
tapes</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>0</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>n/a</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>2</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>3</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1, 
2</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>3</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>2</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>2</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1, 
3</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>4</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>5</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1, 2, 
4</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>5</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>4</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>2</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1, 2, 
5</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>6</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>7</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1, 2, 
5, 6</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>7</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>6</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>2</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1, 2, 
5, 7</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>8</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>9</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1, 2, 
5, 7, 8</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>9</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>8</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>2</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1, 2, 
5, 7, 9</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>10</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>9</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1, 2, 
5, 7, 9, 10</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>11</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>9</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1, 2, 
5, 7, 9, 10, 
11</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>...</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>9</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
>1, 
2, 5, 7, 9, 10, 11, 
...</TD
></TR
></TBODY
></TABLE
></DIV
><P
> A fancy scheme can reduce the amount of labor needed, but
	it does mean there are more things to keep track of.  You must
	decide if it is worth it.  </P
><P
> <B
CLASS="COMMAND"
>dump</B
> has built-in support for backup
	levels.  For <B
CLASS="COMMAND"
>tar</B
> and <B
CLASS="COMMAND"
>cpio</B
>
	it must be implemented with shell scripts.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="WHAT-TO-BACKUP"
></A
>12.6. What to back up</H1
><P
> You want to back up as much as possible.  The major
	exception is software that can be easily reinstalled,
	but even they may have configuration files that it is
	important to back up, lest you need to do all the work to
	configure them all over again.	Another major exception is
	the <TT
CLASS="FILENAME"
>/proc</TT
> filesystem; since that only
	contains data that the kernel always generates automatically,
	it is never a good idea to back it up.	Especially the
	<TT
CLASS="FILENAME"
>/proc/kcore</TT
> file is unnecessary, since it
	is just an image of your current physical memory; it's pretty
	large as well.	</P
><P
> Gray areas include the news spool, log files, and many
	other things in <TT
CLASS="FILENAME"
>/var</TT
>.  You must decide what
	you consider important.  </P
><P
> The obvious things to back up are user files
	(<TT
CLASS="FILENAME"
>/home</TT
>) and system configuration files
	(<TT
CLASS="FILENAME"
>/etc</TT
>, but possibly other things scattered
	all over the filesystem).  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="COMPRESSED-BACKUPS"
></A
>12.7. Compressed backups</H1
><P
> Backups take a lot of space, which can cost quite
	a lot of money.  To reduce the space needed, the backups
	can be compressed.  There are several ways of doing this.
	Some programs have support for for compression built in; for
	example, the <TT
CLASS="OPTION"
>--gzip</TT
> (<TT
CLASS="OPTION"
>-z</TT
>)
	option for GNU <B
CLASS="COMMAND"
>tar</B
> pipes the whole backup
	through the <B
CLASS="COMMAND"
>gzip</B
> compression program, before
	writing it to the backup medium.  </P
><P
> Unfortunately, compressed backups can cause trouble.
	Due to the nature of how compression works, if a single bit is
	wrong, all the rest of the compressed data will be unusable.
	Some backup programs have some built in error correction, but no
	method can handle a large number of errors.  This means that if
	the backup is compressed the way GNU <B
CLASS="COMMAND"
>tar</B
> does
	it, with the whole output compressed as a unit, a single error
	makes all the rest of the backup lost.	Backups must be reliable,
	and this method of compression is not a good idea.  </P
><P
> An alternative way is to compress each file separately.
	This still means that the one file is lost, but all other files
	are unharmed.  The lost file would have been corrupted anyway,
	so this situation is not much worse than not using compression
	at all.  The <B
CLASS="COMMAND"
>afio</B
> program (a variant of
	<B
CLASS="COMMAND"
>cpio</B
>) can do this.  </P
><P
>	Compression takes some time, which may make the backup program
	unable to write data fast enough for a tape drive.
	This can be avoided by buffering the output (either internally, if
	the backup program if smart enough, or by using another program),
	but even that might not work well enough.  This should only be
	a problem on slow computers.  </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="TASK-AUTOMATION"
></A
>Chapter 13. Task Automation --To Be Added</H1
><A
NAME="AEN4487"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"Never put off until tomorrow what you can do 
	the day after tomorrow.<SPAN
CLASS="QUOTE"
>'Mark Twain'</SPAN
>"</SPAN
></P
><A
NAME="AEN4491"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Basic discussion on scripting, cron &#38; at - refer to 
	other HOWTO's for details.  Discuss non-crontab cron jobs	
	such at those in the /etc directory.</P
></BLOCKQUOTE
></BLOCKQUOTE
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="KEEPING-TIME"
></A
>Chapter 14. Keeping Time</H1
><A
NAME="AEN4495"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"Time is an illusion.  Lunchtime double
	so."</SPAN
> (Douglas Adams.)</P
></BLOCKQUOTE
><P
> This chapter explains how a Linux system keeps time,
	and what you need to do to avoid causing trouble.  Usually,
	you don't need to do anything about time, but it is good to
	understand it.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="LOCALTIME"
></A
>14.1. The concept of localtime</H1
><P
> Time measurement is based on mostly regular natural
	phenomena, such as alternating light and dark periods caused
	by the rotation of the planet. The total time taken by two
	successive periods is constant, but the lengths of the light
	and dark period vary. One simple constant is noon.  </P
><P
> Noon is the time of the day when the Sun is at its
	highest position.  Since (according to recent research) the Earth is 
	round, noon happens at different times in different places.  This 
	leads to the concept of <I
CLASS="GLOSSTERM"
>local time</I
>.  Humans
	measure time in many units, most of which are tied to natural
	phenomena like noon.  As long as you stay in the same place,
	it doesn't matter that local times differ.  </P
><P
> As soon as you need to communicate with distant places,
	you'll notice the need for a common time.  In modern times,
	most of the places in the world communicate with most other
	places in the world, so a global standard for measuring time
	has been defined.  This time is called <I
CLASS="GLOSSTERM"
>universal
	time</I
> (UT or UTC, formerly known as Greenwich Mean Time
	or GMT, since it used to be local time in Greenwich, England).
	When people with different local times need to communicate,
	they can express times in universal time, so that there is no
	confusion about when things should happen.  </P
><P
> Each local time is called a time zone.  While geography
	would allow all places that have noon at the same time have the
	same time zone, politics makes it difficult.  For various reasons,
	many countries use <I
CLASS="GLOSSTERM"
>daylight savings time</I
>,
	that is, they move their clocks to have more natural light
	while they work, and then move the clocks back during winter.
	Other countries do not do this.  Those that do, do not agree when
	the clocks should be moved, and they change the rules from year
	to year.  This makes time zone conversions definitely non-trivial.
	</P
><P
> Time zones are best named by the location or by telling
	the difference between local and universal time.  In the US
	and some other countries, the local time zones have a name and
	a three letter abbreviation.  The abbreviations are not unique,
	however, and should not be used unless the country is also named.
	It is better to talk about the local time in, say, Helsinki,
	than about East European time, since not all countries in Eastern
	Europe follow the same rules.  </P
><P
> Linux has a time zone package that knows about all
	existing time zones, and that can easily be updated when the
	rules change.  All the system administrator needs to do is to
	select the appropriate time zone.  Also, each user can set his
	own time zone; this is important since many people work with
	computers in different countries over the Internet.  When the
	rules for daylight savings time change in your local time zone,
	make sure you'll upgrade at least that part of your Linux system.
	Other than setting the system time zone and upgrading the time
	zone data files, there is little need to bother about time.
	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="HW-SW-CLOCKS"
></A
>14.2. The hardware and software clocks</H1
><P
> A personal computer has a battery driven hardware clock.
	The battery ensures that the clock will work even if the rest of
	the computer is without electricity.  The hardware clock can be
	set from the BIOS setup screen or from whatever operating system
	is running.  </P
><P
> The Linux kernel keeps track of time independently from
	the hardware clock.  During the boot, Linux sets its own clock
	to the same time as the hardware clock.  After this, both clocks
	run independently.  Linux maintains its own clock because looking
	at the hardware is slow and complicated.  </P
><P
> The kernel clock always shows universal time.  This way,
	the kernel does not need to know about time zones at all. The
	simplicity results in higher reliability and makes it easier
	to update the time zone information.  Each process handles time
	zone conversions itself (using standard tools that are part of
	the time zone package).  </P
><P
> The hardware clock can be in local time or in universal
	time.  It is usually better to have it in universal time,
	because then you don't need to change the hardware clock when
	daylight savings time begins or ends (UTC does not have DST).
	Unfortunately, some PC operating systems, including MS-DOS,
	Windows, and OS/2, assume the hardware clock shows local time.
	Linux can handle either, but if the hardware clock shows local
	time, then it must be modified when daylight savings time begins
	or ends (otherwise it wouldn't show local time).  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SHOWING-SETTING-TIME"
></A
>14.3. Showing and setting time</H1
><P
> In Linux, the system time zone is determined
	by the symbolic link <TT
CLASS="FILENAME"
>/etc/localtime</TT
>.
	This link points to a time zone data file that describes
	the local time zone.  The time zone data files are located at 
	either <TT
CLASS="FILENAME"
>/usr/lib/zoneinfo</TT
> or 
	<TT
CLASS="FILENAME"
>/usr/share/zoneinfo</TT
> depending on what distribution
	of Linux you use.</P
><P
> For example, on a SuSE system located in New Jersey the 
	<TT
CLASS="FILENAME"
>/etc/localtime</TT
> link would point to 
	<TT
CLASS="FILENAME"
>/usr/share/zoneinfo/US/Eastern</TT
>.  On a Debian system
	the <TT
CLASS="FILENAME"
>/etc/localtime</TT
> link would point to
	<TT
CLASS="FILENAME"
>/usr/lib/zoneinfo/US/Eastern</TT
>.</P
><P
> If you fail to find the <TT
CLASS="FILENAME"
>zoneinfo</TT
> 
	directory in either the <TT
CLASS="FILENAME"
>/usr/lib</TT
> or 
	<TT
CLASS="FILENAME"
>/usr/share</TT
> directories, either do a 
	<B
CLASS="COMMAND"
>find /usr -print | grep zoneinfo</B
> or consult 
	your distribution's documentation.
	</P
><P
> What happens when you have a users located in a different
	timezone?  A user can change his private time zone by setting the
	TZ environment variable.  If it is unset, the system time zone
	is assumed. The syntax of the TZ variable is described in the
	<TT
CLASS="FUNCTION"
>tzset</TT
> manual page.  </P
><P
>	The <B
CLASS="COMMAND"
>date</B
> command shows the current date and 
	time.
	
	For example:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>date</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>Sun Jul 14 21:53:41 EET DST 1996</TT
>
<TT
CLASS="PROMPT"
>$</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	That time is Sunday, 14th of July, 1996, at about ten before
	ten at the evening, in the time zone called ``EET DST''
	(which might be East European Daylight Savings Time).
	<B
CLASS="COMMAND"
>date</B
> can also show the universal time:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>$</TT
> <TT
CLASS="USERINPUT"
><B
>date -u</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>Sun Jul 14 18:53:42 UTC 1996</TT
>
<TT
CLASS="PROMPT"
>$</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	<B
CLASS="COMMAND"
>date</B
> is also used to set the kernel's software 
	clock:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>date 07142157</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>Sun Jul 14 21:57:00 EET DST 1996</TT
>
<TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>date</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>Sun Jul 14 21:57:02 EET DST 1996</TT
>
<TT
CLASS="PROMPT"
>#</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	See the <B
CLASS="COMMAND"
>date</B
> manual page for more details;
	the syntax is a bit arcane.  Only root can set the time.
	While each user can have his own time zone, the clock is the
	same for everyone.  </P
><P
>Beware of the <B
CLASS="COMMAND"
>time</B
> command.  This is not
	used to get the system time.  Instead it's used to time how long 
	something takes.  Refer the the time man page.</P
><P
> <B
CLASS="COMMAND"
>date</B
> only shows or sets the software
	clock.	The <B
CLASS="COMMAND"
>clock</B
> commands synchronizes
	the hardware and software clocks.  It is used when the system
	boots, to read the hardware clock and set the software clock.
	If you need to set both clocks, you first set the software clock
	with <B
CLASS="COMMAND"
>date</B
>, and then the hardware clock with
	<B
CLASS="COMMAND"
>clock -w</B
>.  </P
><P
> The <TT
CLASS="OPTION"
>-u</TT
> option to <B
CLASS="COMMAND"
>clock</B
>
	tells it that the hardware clock is in universal time.
	You <EM
>must</EM
> use the <TT
CLASS="OPTION"
>-u</TT
>
	option correctly.  If you don't, your computer will be quite
	confused about what the time is.  </P
><P
> The clocks should be changed with care.	Many parts of a
	Unix system require the clocks to work correctly.  For example,
	the <B
CLASS="COMMAND"
>cron</B
> daemon runs commands periodically.
	If you change the clock, it can be confused of whether
	it needs to run the commands or not.  On one early Unix
	system, someone set the clock twenty years into the future,
	and <B
CLASS="COMMAND"
>cron</B
> wanted to run all the periodic
	commands for twenty years all at once.	Current versions of
	<B
CLASS="COMMAND"
>cron</B
> can handle this correctly, but you should
	still be careful.  Big jumps or backward jumps are more dangerous
	than smaller or forward ones.  </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="CLOCK-WRONG"
></A
>14.4. When the clock is wrong</H1
><P
> The Linux software clock is not always accurate.  It is
	kept running by a periodic <I
CLASS="GLOSSTERM"
>timer interrupt</I
>
	generated by PC hardware.  If the system has too many processes
	running, it may take too long to service the timer interrupt, and
	the software clock starts slipping behind.  The hardware clock
	runs independently and is usually more accurate.  If you boot
	your computer often (as is the case for most systems that aren't
	servers), it will usually keep fairly accurate time.  </P
><P
> If you need to adjust the hardware clock, it is usually
	simplest to reboot, go into the BIOS setup screen, and do it
	from there.  This avoids all trouble that changing system time
	might cause.  If doing it via BIOS is not an option, set the new
	time with <B
CLASS="COMMAND"
>date</B
> and <B
CLASS="COMMAND"
>clock</B
>
	(in that order), but be prepared to reboot, if some part of the
	system starts acting funny.  </P
><P
> Another method would be to use either <B
CLASS="COMMAND"
>hwclock -w</B
>
	or <B
CLASS="COMMAND"
>hwclock --systohc</B
> to sync the hardware clock
	to the software clock.  If you want to sync your software clock to your 
	hardware clock then you would use <B
CLASS="COMMAND"
>hwclock -s</B
> or 
	<B
CLASS="COMMAND"
>hwclock --hwtosys</B
>.  For more information on this 
	command read <B
CLASS="COMMAND"
>man hwclock</B
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="NTP"
></A
>14.5. NTP - Network Time Protocol</H1
><P
> A networked computer (even if just over a modem) can
        check its own clock automatically by comparing it to the time
        on another computer known to keep accurate time.  Network Time 
	Protocol (or NTP) does exactly that. It is a method of verifying 
	and correcting your computer's time by synchronizing it with a 
	another system. With NTP your system's time can be maintained 
	to within milliseconds of Coordinated Universal Time.  Visit
	<A
HREF="http://www.time.gov/about.html/"
TARGET="_top"
>	http://www.time.gov/about.html</A
> for more info.
	</P
><P
> For more casual Linux users, this is just a nice luxury.  
	At my home all our clocks are set based upon what my Linux system 
	says the time is.  For larger organizations this "luxury" can 
	become essential.  Being able to search log files for events based 
	upon time can make life a lot easier and take a lot of the "guess work"
	out of debugging.
	</P
><P
> Another example of how important NTP can be is with a SAN.  
	Some SAN's require NTP be configured and running properly to allow 
	for proper synchronization over filesystem usage, and proper 
	timestamp control.  Some SANs (and some applications) can become 
	confused when dealing with files that have timestamps that are in 
	the future.
	</P
><P
> Most Linux distributions come with a NTP package of some kind,
	either a .deb or .rpm package.  You can use that to install NTP, or you 
	can download the source files from <A
HREF="http://www.ntp.org/downloads.html"
TARGET="_top"
>	http://www.ntp.org/downloads.html</A
> and compile it yourself.  Either way, 
	the basic configuration is the same.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="BASIC-NTP-CONFIG"
></A
>14.6. Basic NTP configuration</H1
><P
>The NTP program is configured using either the 
	<TT
CLASS="FILENAME"
>/etc/ntp.conf	</TT
> or <TT
CLASS="FILENAME"
>/etc/xntp.conf</TT
> 
	file depending on what distribution of Linux you have.  I won't go 
	into too much detail on how to configure NTP.  Instead I'll just 
	cover the basics.</P
><P
>An example of a basic ntp.conf file would look like:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="COMPUTEROUTPUT"
># --- GENERAL CONFIGURATION ---
server  aaa.bbb.ccc.ddd
server  127.127.1.0
fudge   127.127.1.0 stratum 10

# Drift file.

driftfile /etc/ntp/drift</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>The most basic ntp.conf file will simply list 2 servers, one 
	that it wishes to synchronize with, and a pseudo IP address for
	itself (in this case 127.127.1.0). The pseudo IP is used in case of 
	network problems or if the remote NTP server goes down. NTP will 
	synchronize against itself until the it can start synchronizing with 
	the remote server again.  It is recommended that you list at 
	least 2 remote servers that you can synchronize against.  One will 
	act as a primary server and the other as a backup.</P
><P
>You should also list a location for a drift file.  Over time
	NTP will "learn" the system clock's error rate and automatically 
	adjust for it.</P
><P
>The restrict option can be used to provide better control and
	security over what NTP can do, and who can effect it.  For example:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="COMPUTEROUTPUT"
># Prohibit general access to this service.
restrict default ignore

# Permit systems on this network to synchronize with this
# time service. But not modify our time.
restrict aaa.bbb.ccc.ddd nomodify

# Allow the following unrestricted access to ntpd

restrict aaa.bbb.ccc.ddd
restrict 127.0.0.1</TT
></PRE
></FONT
></TD
></TR
></TABLE
>

	It is advised that you wait until you have NTP working properly before
	adding the restrict option.  You can accidental restrict yourself from
	synchronizing and waste time debugging why.
	</P
><P
>NTP slowly corrects your systems time.  Be patient!  A simple test
	is to change your system clock by 10 minutes before you go to bed and then
	check it when you get up.  The time should be correct.</P
><P
>Many people get the idea that instead of running the NTP
	daemon, they should just setup a <B
CLASS="COMMAND"
>cron</B
> job 
	job to periodically run the <B
CLASS="COMMAND"
>ntpdate</B
> command.
	There are 2 main disadvantages of using using this method.</P
><P
>The first is that <B
CLASS="COMMAND"
>ntpdate</B
> does a "brute force"
	method of changing the time.  So if your computer's time is off my 5 
	minutes, it immediately corrects it.  In some environments, this can 
	cause problems if time drastically changes.  For example, if you are 
	using time sensitive security software, you can inadvertently kill
	someones access.  The NTP daemon slowly changes the time to avoid 
	causing this kind of disruption.</P
><P
>The other reason is that the NTP daemon can be configured to
	try to learn your systems <I
CLASS="GLOSSTERM"
>time drift</I
> and 
	then automatically adjust for it.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="NTP-TOOLKIT"
></A
>14.7. NTP Toolkit</H1
><P
>There are a number of utilities available to check if
	NTP is doing it's job. The <B
CLASS="COMMAND"
>ntpq -p</B
> command
	will print out your system's current time status.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>ntpq -p</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
*cudns.cit.corne ntp0.usno.navy.  2 u  832 1024  377   43.208    0.361   2.646
 LOCAL(0)        LOCAL(0)        10 l   13   64  377    0.000    0.000   0.008</TT
></PRE
></FONT
></TD
></TR
></TABLE
>
	</P
><P
> The <B
CLASS="COMMAND"
>ntpdc -c loopinfo</B
> will display 
	how far off the system time is in seconds, based upon the last time
	the remote server was contacted.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>ntpdc -c loopinfo</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>offset:               -0.004479 s
frequency:            133.625 ppm
poll adjust:          30
watchdog timer:       404 s</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
><B
CLASS="COMMAND"
>ntpdc -c kerninfo</B
> will display 
	the current remaining correction.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>ntpdc -c kerninfo</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>pll offset:           -0.003917 s
pll frequency:        133.625 ppm
maximum error:        0.391414 s
estimated error:      0.003676 s
status:               0001  pll
pll time constant:    6
precision:            1e-06 s
frequency tolerance:  512 ppm
pps frequency:        0.000 ppm
pps stability:        512.000 ppm
pps jitter:           0.0002 s
calibration interval: 4 s
calibration cycles:   0
jitter exceeded:      0
stability exceeded:   0
calibration errors:   0</TT
>
	</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> A slightly more different version of 
	<B
CLASS="COMMAND"
>ntpdc -c kerninfo</B
> is <B
CLASS="COMMAND"
>ntptime</B
>
<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>ntptime</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>ntp_gettime() returns code 0 (OK)
  time c35e2cc7.879ba000  Thu, Nov 13 2003 11:16:07.529, (.529718),
  maximum error 425206 us, estimated error 3676 us
ntp_adjtime() returns code 0 (OK)
  modes 0x0 (),
  offset -3854.000 us, frequency 133.625 ppm, interval 4 s,
  maximum error 425206 us, estimated error 3676 us,
  status 0x1 (PLL),
  time constant 6, precision 1.000 us, tolerance 512 ppm,
  pps frequency 0.000 ppm, stability 512.000 ppm, jitter 200.000 us,
  intervals 0, jitter exceeded 0, stability exceeded 0, errors 0.</TT
></PRE
></FONT
></TD
></TR
></TABLE
>
	</P
><P
> Yet another way to see how well NTP is working is 
	with the <B
CLASS="COMMAND"
>ntpdate -d</B
> command.	This will 
	contact an NTP server and determine the time difference
	but not change your system's time.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>ntpdate -d 132.236.56.250</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>13 Nov 14:43:17 ntpdate[29631]: ntpdate 4.1.1c-rc1@1.836 Thu Feb 13 12:17:20 EST 2003 (1)
transmit(132.236.56.250)
receive(132.236.56.250)
transmit(132.236.56.250)
receive(132.236.56.250)
transmit(132.236.56.250)
receive(132.236.56.250)
transmit(132.236.56.250)
receive(132.236.56.250)
transmit(132.236.56.250)
server 132.236.56.250, port 123
stratum 2, precision -17, leap 00, trust 000
refid [192.5.41.209], delay 0.06372, dispersion 0.00044
transmitted 4, in filter 4
reference time:    c35e5998.4a46cfc8  Thu, Nov 13 2003 14:27:20.290
originate timestamp: c35e5d55.d69a6f82  Thu, Nov 13 2003 14:43:17.838
transmit timestamp:  c35e5d55.d16fc9bc  Thu, Nov 13 2003 14:43:17.818
filter delay:  0.06522  0.06372  0.06442  0.06442
         0.00000  0.00000  0.00000  0.00000
filter offset: 0.000036 0.001020 0.000527 0.000684
         0.000000 0.000000 0.000000 0.000000
delay 0.06372, dispersion 0.00044
offset 0.001020

13 Nov 14:43:17 ntpdate[29631]: adjust time server 132.236.56.250 offset 0.001020 sec</TT
></PRE
></FONT
></TD
></TR
></TABLE
>
	</P
><P
> If you want actually watch the system
	synchronize you can use <B
CLASS="COMMAND"
>ntptrace</B
>.

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>ntptrace 132.236.56.250</B
></TT
>
<TT
CLASS="COMPUTEROUTPUT"
>cudns.cit.cornell.edu: stratum 2, offset -0.003278, synch distance 0.02779
truetime.ntp.com: stratum 1, offset -0.014363, synch distance 0.00000, refid 'ACTS'</TT
></PRE
></FONT
></TD
></TR
></TABLE
>
	</P
><P
>If you need your system time synchronized immediately 
	you can use the <B
CLASS="COMMAND"
>ntpdate remote-servername</B
> 
	to force a synchronization.  No waiting!

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><TT
CLASS="PROMPT"
>#</TT
> <TT
CLASS="USERINPUT"
><B
>ntpdate 132.236.56.250</B
></TT
>
13 Nov 14:56:28 ntpdate[29676]: adjust time server 132.236.56.250 offset -0.003151 sec
<TT
CLASS="COMPUTEROUTPUT"
></TT
></PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="NTP-SERVERS"
></A
>14.8. Some known NTP servers</H1
><P
>A list of public NTP servers can be obtained from:
	<A
HREF="http://www.eecis.udel.edu/~mills/ntp/servers.html/"
TARGET="_top"
>	http://www.eecis.udel.edu/~mills/ntp/servers.html</A
>.  Please read
	the usage information on the page prior so using a server.  Not all
	servers have the available bandwidth to allow a large number of systems
	synchronizing against them.  Therefore it is a good idea to contact
	a system's administrator prior to using his/her server for NTP services.
	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="NTP-LINKS"
></A
>14.9. NTP Links</H1
><P
>More detailed information on NTP can be obtained from the
	NTP homepage:<A
HREF="http://www.ntp.org/"
TARGET="_top"
>http://www.ntp.org</A
>.
	</P
><P
>Or from <A
HREF="http://www.ntp.org/ntpfaq/NTP-a-faq.htm"
TARGET="_top"
>	http://www.ntp.org/ntpfaq/NTP-a-faq.htm</A
></P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SYSTEM-LOGS"
></A
>Chapter 15. System Logs --To Be Added</H1
><P
>Log info, rotation, monitoring, etc..</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SYSTEM-UPDATES"
></A
>Chapter 16. System Updates --To Be Added</H1
><A
NAME="AEN4675"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"A lie gets halfway around the world before 
	the truth has a chance to get its pants on."</SPAN
> Winston Churchill
	</P
></BLOCKQUOTE
><P
>Discussion on how and when to update the system.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="KERNEL"
></A
>Chapter 17. The Linux Kernel Source</H1
><A
NAME="AEN4681"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"Black holes are where God divided by zero.
	"</SPAN
> Steven Wright</P
></BLOCKQUOTE
><P
>BASIC info on the kernel source and compiling it. It will 
	also provide some info on kdb debugger. Refer 
	to other kernel HOWTO's for more info.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="FINDING-HELP"
></A
>Chapter 18. Finding Help</H1
><A
NAME="AEN4687"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"Help me if you can I'm feeling down. And I do
appreciate you being 'round."</SPAN
> - The 
Beatles</P
></BLOCKQUOTE
><P
>Help is out there.  You just have to know where to look.  With
	Linux there are an amazing number of places you can go.  There are 
	mailing lists, IRC channels, web pages with public forums, and many
	other resources available.  This chapter will try to help you get the
	most out of your quest for help.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="NEWSGROUPS-MAILLING-LISTS"
></A
>18.1. Newsgroups and Mailing Lists</H1
><P
>	This guide cannot teach you everything about Linux.  There
	just isn't enough space.  It is almost inevitable that at some point
	you will find something you need to do, that isn't covered in
	this (or any other) document at the LDP.
	</P
><P
>	One of the nicest things about Linux is the large number of forums
	devoted to it.  There are forums relating to almost all facets of
	Linux ranging from newbie FAQs to in depth kernel development issues. 
 
	To receive the most from them, there are a few things you can do.
	</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="RIGHT-FORUM"
></A
>18.1.1. Finding The Right Forum</H2
><P
>	The first thing to do is to find an appropriate forum.  There are many
	newsgroups and mailing lists devoted to Linux, so try to find and use 
	the one which most closely matches your question.  For example, there
	isn't much point in you asking a question about sendmail in a forum
	devoted to Linux kernel development.  At best the people there will 
	think you are stupid and you will get few responses, at worst you may 
	receive lots of highly insulting replies (flames). A quick look
	through the newsgroups available finds comp.mail.sendmail, which
	looks like an appropriate place to ask a sendmail question.  Your news
	client probably has a list of the newsgroups available to you, but if
	not then a full list of newsgroups is available at <A
HREF="http://groups.google.com/groups?group=*"
TARGET="_top"
>	http://groups.google.com/groups?group=*</A
>.
	</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BEFORE-YOU-POST"
></A
>18.1.2. Before You Post</H2
><P
>	Now that you have found your appropriate forum, you may think you are 
	ready to post your question.  Stop. You aren't ready yet.  Have you already
	looked for the answer yourself?  There are a huge number of HOWTOs and
	FAQs available, if any of them relate to the thing you are having a
	problem with then <EM
>read them first</EM
>.  Even if they 
	don't contain the answer to your problem, what they will do is give you a
	better understanding of the subject area, and that understanding will 
	allow you to ask a more informed and sensible question.  There are also archives
	of newsgroups and mailing lists and it is entirely possible that your
	question has been asked and answered previously.  <A
HREF="http://www.google.com/"
TARGET="_top"
>http://www.google.com</A
> or a similar
	search engine should be something you try <EM
>before</EM
>
	posting a question.
	</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="WRITING-YOUR-POST"
></A
>18.1.3. Writing Your Post</H2
><P
>Okay, you have found your appropriate forum, you have read the
	relevant HOWTOs and FAQs, you have searched the web, but you still 
	have not found the answer you need.  Now you can start writing your post.
	It is always a good idea to make it clear that you already have read 
	up on the subject by saying something like ``I have read the 
	Winmodem-HOWTO and the PPP FAQ, but neither contained what I was looking for,
	searching for `Winmodem Linux PPP Setup' on google didn't return 
	anything of use either''.  This shows you to be someone who is willing to make 
	an effort rather than a lazy idiot who requires spoonfeeding.  The former
	is likely to receive help if anyone knows the answer, the latter
	is likely to meet with either stony silence or outright 
	derision.</P
><P
>Write in clear, grammatical and correctly spelt English.  This 
	is incredibly important.  It marks you as a precise and considered 
	thinker. There are no such words as ``u'' or ``b4.''  Try to make yourself look
	like an educated and intelligent person rather than an idiot.  It will
	help.  I promise.</P
><P
>Similarly do not type in all capitals LIKE THIS.  That is
	considered shouting and looks very rude.</P
><P
>Provide clear details stating what the problem is and what you 
	have already tried to do to fix it.  A question like ``My linux has stopped
	working, what can I do?'' is totally useless.  Where has it stopped
	working?  In what way has it stopped working?  You need to be as 
	precise as possible.  There are limits however.  Try not to include irrelevant
	information either.  If you are having problems with your mail client 
	it is unlikely that a dump of your kernel boot log
	(<B
CLASS="COMMAND"
>dmesg</B
>) would be of help.</P
><P
>	
	</P
><P
>Don't ask for replies by private email.  The point of most Linux
	forums is that everybody can learn something from each other.  Asking
	for private replies simply removes value from the newsgroup or mailing
	list.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FORMATTING-YOUR-POST"
></A
>18.1.4. Formatting Your Post</H2
><P
> Do not post in HTML.  Many Linux users have mail clients which
	can't easily read HTML email.  Whilst with some effort, they
	<EM
>can</EM
> read HTML email, they usually don't.  If you 
	send them HTML mail it often gets deleted unread.  Send plain text
	emails, they will reach a wider audience that way.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FOLLOW-UP"
></A
>18.1.5. Follow Up</H2
><P
>After your problem has been solved, post a short followup
	explaining what the problem was and how you solved it.  People will
	appreciate this as it not only gives a sense of closure about the 
	problem but also helps the next time someone has a similar question.  When they
	look at the archives of the newsgroup or mailing list, they will see 
	you had the same problem, the discussion that followed your question and
	your final solution.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="GETTING-HELP-MORE-INFO"
></A
>18.1.6. More Information</H2
><P
>This short guide is simply a paraphrase
	and summary of  the excellent (and more detailed) document ``How To 
	Ask Questions The Smart Way'' by Eric S Raymond.  <A
HREF="http://www.catb.org/~esr/faqs/smart-questions.html"
TARGET="_top"
>	http://www.catb.org/~esr/faqs/smart-questions.html</A
>.  It is
	recommend that you read it before you post anything.  It will help 
	you formulate  your question to maximize your
	chances of getting the answer you are looking for.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="IRC"
></A
>18.2. IRC</H1
><P
>IRC (Internet Relay Chat) is not covered in the Eric Raymond 
	document, but IRC can also be an excellent way of finding the answers you need.  
	However it does require some practice in asking questions in the right way.  
	Most IRC networks have busy #linux channels and if the answer to your question
	is contained in the man pages, or in the HOWTOs then expect to be told 
	to go read them.  The rule about typing in clear and grammatical English
	still applies.</P
><P
>Most of what has been said about newsgroups and mailing lists 
	is still relevant for IRC, with a the following additions</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="COLOURS"
></A
>18.2.1. Colours</H2
><P
>Do not use colours, bold, underline or strange (non ASCII)
	characters.  This breaks some older terminals and is just plain ugly 
	to look at.  If you arrive in a channel and start spewing colour or bold
	then expect to be kicked out.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BE-POLITE"
></A
>18.2.2. Be Polite</H2
><P
>Remember you are not entitled to an answer.  If you ask the
	question in the right way then you will probably get one, but you have
	no right to get one.  The people in Linux IRC channels are all there 
	on their own time, nobody is paying them, especially not you.</P
><P
>Be polite.  Treat others as you would like to be
	treated.  If you think people are not being polite to you then don't
	start calling them names or getting annoyed, become even politer.  
	This makes them look foolish rather than dragging you down to their level.</P
><P
>Don't go slapping anyone with large trouts.  Would you believe 
	this has been done before once or twice?  And that we it wasn't
	funny the first time?</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="TYPE-PROPERLY"
></A
>18.2.3. Type Properly, in English</H2
><P
>Most #linux channels are English channels.  Speak English whilst
	in them.  Most of the larger IRC networks also have #linux channel in
	other languages, for example the French language channel might be
	called #linuxfr, the Spanish one might be #linuxes or #linuxlatino.  
	If you can't find the right channel then asking in the main #linux 
	channel (preferably in English) should help you find the one you are looking
	for.</P
><P
>Do not type like a ``1337 H4X0R d00d!!!''.  Even if other people
	are.  It looks silly and thereby makes you look silly.  At best you 
	will only look like an idiot, at worst you will be derided then kicked 
	out.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="PORT-SCANNING"
></A
>18.2.4. Port scanning</H2
><P
>Never <EM
>ever</EM
> ask anyone to port scan you, or 
	try to ``hack'' you.  This is inviolable.  There is no way of knowing that
	you are who you say you are, or that the IP that you are connected 
	from belongs to you.  Don't put people in the position where they have to 
	say no to a request like this.</P
><P
><EM
>Don't ever port scan anyone</EM
>, even if they 
	ask you to.  You have no way to tell
	that they are who they say they are or that the IP they are connected 
	from is their own IP.  In some jurisdictions port scanning may be illegal 
	and it is certainly against the Terms of Service of most ISPs.
	Most people log TCP connections, they will notice they are being
	scanned.  Most people <EM
>will</EM
> report you to your ISP
	for this (it is trivial to find out who that is).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="KEEP-IN-CHANNEL"
></A
>18.2.5. Keep it in the Channel</H2
><P
>Don't /msg anyone unless they ask you to.  It diminishes the
	usefulness of the channel and some people just prefer that
	you not do it.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN4751"
></A
>18.2.6. Stay On Topic</H2
><P
>Stay on topic.  The channel is a ``Linux'' channel, not a ``What
	Uncle Bob Got Up To Last Weekend'' channel.  Even if you see other
	people being off topic, this does not mean that you should be.  They 
	are probably channel regulars and different conventions apply to
	them.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="MASS-CTCP"
></A
>18.2.7. CTCPs</H2
><P
>If you are thinking of mass CTCP pinging the channel or CTCP
	version or CTCP anything, then think again.  It is liable to get you
	kicked out very quickly.</P
><P
>If you are not familiar with IRC, CTCP stands for Client To
	Client Protocol.  It is a method whereby you can find out things 
	about other peoples' clients.  See the documentation for your IRC 
	for more details.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="HACKING"
></A
>18.2.8. Hacking, Cracking, Phreaking, Warezing</H2
><P
>Don't ask about exploits, unless you are looking for a further 
	way to be unceremoniously kicked out.</P
><P
>Don't be in hacker/cracker/phreaker/warezer channels whilst in a
	#linux channel.  For some reason the people in charge of #linux 
	channels seem to hate people who like causing destruction to people's machines
	or who like to steal software.  Can't imagine why.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="ROUND-UP"
></A
>18.2.9. Round Up</H2
><P
>Apologies if that seems like a lot of DON'Ts, and very few DOs. 
	 The DOs were already pretty much covered in the section on newsgroups and
	mailing lists.</P
><P
>Probably the best thing you can do is to go into a #linux 
	channel, sit there and watch, getting the feel for a half hour before
	you say anything.  This can help you to recognize the correct tone you
	should be using.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FURTHER-READING"
></A
>18.2.10. Further Reading</H2
><P
>There are excellent FAQs about how to get the most of IRC #linux
	channels.  Most #linux channels have an FAQ and/or set or channel 
	rules. How to find this will usually be in the channel topic (which you can 
	see at any time using the <B
CLASS="COMMAND"
>/topic</B
> command.  Make sure 
	you read the rules if there are any and follow them.  One fairly generic 
	set of rules and advice is the ``Undernet #linux FAQ'' which can be found 
	at <A
HREF="http://linuxfaq.quartz.net.nz/"
TARGET="_top"
>http://linuxfaq.quartz.net.nz
	</A
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="GFDL1.2"
></A
>Appendix A. GNU Free Documentation License</H1
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="GFDL-0"
></A
>A.1. PREAMBLE</H1
><P
>The purpose of this License is to make a manual, textbook, or
	other functional and useful document "free" in the sense of freedom: to
	assure everyone the effective freedom to copy and redistribute it, with
	or without modifying it, either commercially or noncommercially.
	Secondarily, this License preserves for the author and publisher a way
	to get credit for their work, while not being considered responsible for
	modifications made by others.</P
><P
>This License is a kind of "copyleft", which means that derivative
	works of the document must themselves be free in the same sense.  It
	complements the GNU General Public License, which is a copyleft license
	designed for free software.</P
><P
>We have designed this License in order to use it for manuals for
	free software, because free software needs free documentation: a free
	program should come with manuals providing the same freedoms that the
	software does.  But this License is not limited to software manuals; it
	can be used for any textual work, regardless of subject matter or
	whether it is published as a printed book.  We recommend this License
	principally for works whose purpose is instruction or reference.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="GFDL-1"
></A
>A.2. APPLICABILITY AND DEFINITIONS</H1
><P
>This License applies to any manual or other work, in
	any medium, that contains a notice placed by the copyright holder saying
	it can be distributed under the terms of this License.  Such a notice
	grants a world-wide, royalty-free license, unlimited in duration, to use
	that work under the conditions stated herein.  The "Document", below,
	refers to any such manual or work.  Any member of the public is a
	licensee, and is addressed as "you".  You accept the license if you
	copy, modify or distribute the work in a way requiring permission under
	copyright law.</P
><P
>A "Modified Version" of the Document means any
	work containing the Document or a portion of it, either copied verbatim,
	or with modifications and/or translated into another language.</P
><P
>A "Secondary Section" is a named appendix or
	a front-matter section of the Document that deals exclusively with the
	relationship of the publishers or authors of the Document to the
	Document's overall subject (or to related matters) and contains nothing
	that could fall directly within that overall subject.  (Thus, if the
	Document is in part a textbook of mathematics, a Secondary Section may
	not explain any mathematics.)  The relationship could be a matter of
	historical connection with the subject or with related matters, or of
	legal, commercial, philosophical, ethical or political position
	regarding them.</P
><P
>The "Invariant Sections" are certain Secondary
	Sections whose titles are designated, as being those of Invariant
	Sections, in the notice that says that the Document is released under
	this License.  If a section does not fit the above definition of
	Secondary then it is not allowed to be designated as Invariant.  The
	Document may contain zero Invariant Sections.  If the Document does not
	identify any Invariant Sections then there are none.</P
><P
>The "Cover Texts" are certain short passages of
	text that are listed, as Front-Cover Texts or Back-Cover Texts, in the
	notice that says that the Document is released under this License.  A
	Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at
	most 25 words.</P
><P
>A "Transparent" copy of the Document means a
	machine-readable copy, represented in a format whose specification is
	available to the general public, that is suitable for revising the
	document straightforwardly with generic text editors or (for images
	composed of pixels) generic paint programs or (for drawings) some widely
	available drawing editor, and that is suitable for input to text
	formatters or for automatic translation to a variety of formats suitable
	for input to text formatters.  A copy made in an otherwise Transparent
	file format whose markup, or absence of markup, has been arranged to
	thwart or discourage subsequent modification by readers is not
	Transparent.  An image format is not Transparent if used for any
	substantial amount of text.  A copy that is not "Transparent" is called
	"Opaque".</P
><P
>Examples of suitable formats for Transparent copies include plain
	ASCII without markup, Texinfo input format, LaTeX input format, SGML or
	XML using a publicly available DTD, and standard-conforming simple HTML,
	PostScript or PDF designed for human modification.  Examples of
	transparent image formats include PNG, XCF and JPG.  Opaque formats
	include proprietary formats that can be read and edited only by
	proprietary word processors, SGML or XML for which the DTD and/or
	processing tools are not generally available, and the machine-generated
	HTML, PostScript or PDF produced by some word processors for output
	purposes only.</P
><P
>The "Title Page" means, for a printed book,
	the title page itself, plus such following pages as are needed to hold,
	legibly, the material this License requires to appear in the title page.
	For works in formats which do not have any title page as such, "Title
	Page" means the text near the most prominent appearance of the work's
	title, preceding the beginning of the body of the text.</P
><P
>A section "Entitled XYZ" means a named subunit
	of the Document whose title either is precisely XYZ or contains XYZ in
	parentheses following text that translates XYZ in another language.
	(Here XYZ stands for a specific section name mentioned below, such as
	"Acknowledgements", "Dedications", "Endorsements", or "History".)  To
	"Preserve the Title" of such a section when you modify the Document
	means that it remains a section "Entitled XYZ" according to this
	definition.</P
><P
>The Document may include Warranty Disclaimers next to the notice
	which states that this License applies to the Document.  These Warranty
	Disclaimers are considered to be included by reference in this License,
	but only as regards disclaiming warranties: any other implication that
	these Warranty Disclaimers may have is void and has no effect on the
	meaning of this License.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="GFDL-2"
></A
>A.3. VERBATIM COPYING</H1
><P
>You may copy and distribute the Document in any medium, either
	commercially or noncommercially, provided that this License, the
	copyright notices, and the license notice saying this License applies to
	the Document are reproduced in all copies, and that you add no other
	conditions whatsoever to those of this License.  You may not use
	technical measures to obstruct or control the reading or further copying
	of the copies you make or distribute.  However, you may accept
	compensation in exchange for copies.  If you distribute a large enough
	number of copies you must also follow the conditions in section 3.
	</P
><P
>You may also lend copies, under the same conditions stated above,
	and you may publicly display copies.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="GFDL-3"
></A
>A.4. COPYING IN QUANTITY</H1
><P
>If you publish printed copies (or copies in media that commonly
	have printed covers) of the Document, numbering more than 100, and the
	Document's license notice requires Cover Texts, you must enclose the
	copies in covers that carry, clearly and legibly, all these Cover Texts:
	Front-Cover Texts on the front cover, and Back-Cover Texts on the back
	cover.  Both covers must also clearly and legibly identify you as the
	publisher of these copies.  The front cover must present the full title
	with all words of the title equally prominent and visible.  You may add
	other material on the covers in addition.  Copying with changes limited
	to the covers, as long as they preserve the title of the Document and
	satisfy these conditions, can be treated as verbatim copying in other
	respects.</P
><P
>If the required texts for either cover are too voluminous to fit
	legibly, you should put the first ones listed (as many as fit
	reasonably) on the actual cover, and continue the rest onto adjacent
	pages.</P
><P
>If you publish or distribute Opaque copies of the Document
	numbering more than 100, you must either include a machine-readable
	Transparent copy along with each Opaque copy, or state in or with each
	Opaque copy a computer-network location from which the general
	network-using public has access to download using public-standard
	network protocols a complete Transparent copy of the Document, free of
	added material.  If you use the latter option, you must take reasonably
	prudent steps, when you begin distribution of Opaque copies in quantity,
	to ensure that this Transparent copy will remain thus accessible at the
	stated location until at least one year after the last time you
	distribute an Opaque copy (directly or through your agents or retailers)
	of that edition to the public.</P
><P
>It is requested, but not required, that you contact the authors of
	the Document well before redistributing any large number of copies, to
	give them a chance to provide you with an updated version of the
	Document.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="GFDL-4"
></A
>A.5. MODIFICATIONS</H1
><P
>You may copy and distribute a Modified Version of the Document
	under the conditions of sections 2 and 3 above, provided that you
	release the Modified Version under precisely this License, with the
	Modified Version filling the role of the Document, thus licensing
	distribution and modification of the Modified Version to whoever
	possesses a copy of it.  In addition, you must do these things in the
	Modified Version:</P
><P
></P
><P
><B
>GNU FDL Modification Conditions</B
></P
><OL
TYPE="A"
><LI
><P
>Use in the Title Page (and on the covers, if any) a
	title distinct from that of the Document, and from those of previous
	versions (which should, if there were any, be listed in the History
	section of the Document).  You may use the same title as a previous
	version if the original publisher of that version gives permission.
	</P
></LI
><LI
><P
>List on the Title Page, as authors, one or more
	persons or entities responsible for authorship of the modifications in
	the Modified Version, together with at least five of the principal
	authors of the Document (all of its principal authors, if it has fewer
	than five), unless they release you from this requirement.
	</P
></LI
><LI
><P
>State on the Title page the name of the publisher of
	the Modified Version, as the publisher.</P
></LI
><LI
><P
>Preserve all the copyright notices of the Document.
	</P
></LI
><LI
><P
>Add an appropriate copyright notice for your
	modifications adjacent to the other copyright notices.
	</P
></LI
><LI
><P
>Include, immediately after the copyright notices, a
	license notice giving the public permission to use the Modified
	Version under the terms of this License, in the form shown in the
	<A
HREF="#GFDL-ADDENDUM"
>Addendum</A
> below.
	</P
></LI
><LI
><P
>Preserve in that license notice the full lists of
	Invariant Sections and required Cover Texts given in the Document's
	license notice.</P
></LI
><LI
><P
>Include an unaltered copy of this License.
	</P
></LI
><LI
><P
>Preserve the section Entitled "History", Preserve its
	 Title, and add to it an item stating at least the title, year, new
	authors, and publisher of the Modified Version as given on the Title
	Page.  If there is no section Entitled "History" in the Document,
	create one stating the title, year, authors, and publisher of the
	Document as given on its Title Page, then add an item describing the
	Modified Version as stated in the previous sentence.
	</P
></LI
><LI
><P
>Preserve the network location, if any, given in the
	Document for public access to a Transparent copy of the Document, and
	likewise the network locations given in the Document for previous
	versions it was based on.  These may be placed in the "History"
	section.  You may omit a network location for a work that was
	published at least four years before the Document itself, or if the
	original publisher of the version it refers to gives permission.
	</P
></LI
><LI
><P
>For any section Entitled "Acknowledgements" or
	"Dedications", Preserve the Title of the section, and preserve in the
	section all the substance and tone of each of the contributor
	acknowledgements and/or dedications given therein.
	</P
></LI
><LI
><P
>Preserve all the Invariant Sections of the Document,
	unaltered in their text and in their titles.  Section numbers or the
	equivalent are not considered part of the section titles.
	</P
></LI
><LI
><P
>Delete any section Entitled "Endorsements".
	Such a section may not be included in the Modified Version.
	</P
></LI
><LI
><P
>Do not retitle any existing section to be Entitled
	"Endorsements" or to conflict in title with any Invariant Section.
	</P
></LI
><LI
><P
>Preserve any Warranty Disclaimers.
	</P
></LI
></OL
><P
>If the Modified Version includes new front-matter sections or
	appendices that qualify as Secondary Sections and contain no material
	copied from the Document, you may at your option designate some or all
	of these sections as invariant.  To do this, add their titles to the
	list of Invariant Sections in the Modified Version's license notice.
	These titles must be distinct from any other section titles.</P
><P
>You may add a section Entitled "Endorsements", provided it
	contains nothing but endorsements of your Modified Version by various
	parties--for example, statements of peer review or that the text has
	been approved by an organization as the authoritative definition of a
	standard.</P
><P
>You may add a passage of up to five words as a Front-Cover Text,
	and a passage of up to 25 words as a Back-Cover Text, to the end of the
	list of Cover Texts in the Modified Version.  Only one passage of
	Front-Cover Text and one of Back-Cover Text may be added by (or through
	arrangements made by) any one entity.  If the Document already includes
	a cover text for the same cover, previously added by you or by
	arrangement made by the same entity you are acting on behalf of, you may
	not add another; but you may replace the old one, on explicit permission
	from the previous publisher that added the old one.</P
><P
>The author(s) and publisher(s) of the Document do not by this
	License give permission to use their names for publicity for or to
	assert or imply endorsement of any Modified Version.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="GFDL-5"
></A
>A.6. COMBINING DOCUMENTS</H1
><P
>You may combine the Document with other documents released under
	this License, under the terms defined in <A
HREF="#GFDL-4"
>section
	4</A
> above for modified versions, provided that you include in the
	combination all of the Invariant Sections of all of the original
	documents, unmodified, and list them all as Invariant Sections of your
	combined work in its license notice, and that you preserve all their
	Warranty Disclaimers.</P
><P
>The combined work need only contain one copy of this License, and
	multiple identical Invariant Sections may be replaced with a single
	copy.  If there are multiple Invariant Sections with the same name but
	different contents, make the title of each such section unique by adding
	at the end of it, in parentheses, the name of the original author or
	publisher of that section if known, or else a unique number.  Make the
	same adjustment to the section titles in the list of Invariant Sections
	in the license notice of the combined work.</P
><P
>In the combination, you must combine any sections Entitled
	"History" in the various original documents, forming one section
	Entitled "History"; likewise combine any sections Entitled
	"Acknowledgements", and any sections Entitled "Dedications".  You must
	delete all sections Entitled "Endorsements".</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="GFDL-6"
></A
>A.7. COLLECTIONS OF DOCUMENTS</H1
><P
>You may make a collection consisting of the Document and other
	documents released under this License, and replace the individual copies
	of this License in the various documents with a single copy that is
	included in the collection, provided that you follow the rules of this
	License for verbatim copying of each of the documents in all other
	respects.</P
><P
>You may extract a single document from such a collection, and
	distribute it individually under this License, provided you insert a
	copy of this License into the extracted document, and follow this
	License in all other respects regarding verbatim copying of that
	document.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="GFDL-7"
></A
>A.8. AGGREGATION WITH INDEPENDENT WORKS</H1
><P
>A compilation of the Document or its derivatives with other
	separate and independent documents or works, in or on a volume of a
	storage or distribution medium, is called an "aggregate" if the
	copyright resulting from the compilation is not used to limit the legal
	rights of the compilation's users beyond what the individual works
	permit.  When the Document is included in an aggregate, this License does
	not apply to the other works in the aggregate which are not themselves
	derivative works of the Document.</P
><P
>If the Cover Text requirement of section 3 is applicable to these
	copies of the Document, then if the Document is less than one half of
	the entire aggregate, the Document's Cover Texts may be placed on covers
	that bracket the Document within the aggregate, or the electronic
	equivalent of covers if the Document is in electronic form.  Otherwise
	they must appear on printed covers that bracket the whole
	aggregate.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="GFDL-8"
></A
>A.9. TRANSLATION</H1
><P
>Translation is considered a kind of modification, so you may
	distribute translations of the Document under the terms of section 4.
	Replacing Invariant Sections with translations requires special
	permission from their copyright holders, but you may include
	translations of some or all Invariant Sections in addition to the
	original versions of these Invariant Sections.  You may include a
	translation of this License, and all the license notices in the
	Document, and any Warranty Disclaimers, provided that you also include
	the original English version of this License and the original versions
	of those notices and disclaimers.  In case of a disagreement between the
	translation and the original version of this License or a notice or
	disclaimer, the original version will prevail.</P
><P
>If a section in the Document is Entitled "Acknowledgements",
	"Dedications", or "History", the requirement (section 4) to Preserve its
	Title (section 1) will typically require changing the actual
	title.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="GFDL-9"
></A
>A.10. TERMINATION</H1
><P
>You may not copy, modify, sublicense, or distribute the Document
	except as expressly provided for under this License.  Any other attempt
	to copy, modify, sublicense or distribute the Document is void, and will
	automatically terminate your rights under this License.  However,
	parties who have received copies, or rights, from you under this License
	will not have their licenses terminated so long as such parties remain
	in full compliance.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="GFDL-10"
></A
>A.11. FUTURE REVISIONS OF THIS LICENSE</H1
><P
>The Free Software Foundation may publish new, revised versions of
	the GNU Free Documentation License from time to time.  Such new versions
	will be similar in spirit to the present version, but may differ in
	detail to address new problems or concerns.  See
	http://www.gnu.org/copyleft/.</P
><P
>Each version of the License is given a distinguishing version
	number.  If the Document specifies that a particular numbered version of
	this License "or any later version" applies to it, you have the option
	of following the terms and conditions either of that specified version
	or of any later version that has been published (not as a draft) by the
	Free Software Foundation.  If the Document does not specify a version
	number of this License, you may choose any version ever published (not
	as a draft) by the Free Software Foundation.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H1
CLASS="SECTION"
><A
NAME="GFDL-ADDENDUM"
></A
>A.12. ADDENDUM: How to use this License for
  your documents</H1
><P
>To use this License in a document you have written, include a copy
	of the License in the document and put the following copyright and
	license notices just after the title page:</P
><A
NAME="COPYRIGHT-SAMPLE"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><B
>Sample Invariant Sections list</B
></P
><P
>Copyright (c)  YEAR  YOUR NAME.
    	Permission is granted to copy, distribute and/or modify this document
    	under the terms of the GNU Free Documentation License, Version 1.2
    	or any later version published by the Free Software Foundation;
    	with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    	A copy of the license is included in the section entitled "GNU
    	Free Documentation License".
	</P
></BLOCKQUOTE
><P
>If you have Invariant Sections, Front-Cover Texts and Back-Cover
	Texts, replace the "with...Texts." line with this:</P
><A
NAME="INV-COVER-SAMPLE"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><B
>Sample Invariant Sections list</B
></P
><P
>    	with the Invariant Sections being LIST THEIR TITLES, with the
    	Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
	</P
></BLOCKQUOTE
><P
>If you have Invariant Sections without Cover Texts, or some other
	combination of the three, merge those two alternatives to suit the
	situation.</P
><P
>If your document contains nontrivial examples of program code, we
	recommend releasing these examples in parallel under your choice of free
	software license, such as the GNU General Public License, to permit
	their use in free software.</P
></DIV
></DIV
><DIV
CLASS="GLOSSARY"
><H1
><A
NAME="GLOSSARY"
></A
>Glossary (DRAFT, but not for long hopefully)</H1
><A
NAME="AEN4895"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
><SPAN
CLASS="QUOTE"
>"The Librarian of the Unseen University
	had unilaterally decided to aid comprehension
	by producing an Orang-utan/Human Dictionary.
	He'd been working on it for three months.
	It wasn't easy.  He'd got as far as `Oook.'"</SPAN
>
	(Terry Pratchett, ``Men At Arms'')</P
></BLOCKQUOTE
><P
> This is a short list of word definitions for concepts
	relating to Linux and system administration.  </P
><DL
><DT
><B
>CMOS RAM</B
></DT
><DD
><P
>	CMOS stands for "Complementary Metal Oxide Semiconductor".  
	It is a complex technology, but put very simply it is a type 
	of transistor which maintains its state even if computer is 
	powered off.  This is due to a small battery on the motherboard. 
	As a result, it  does not lose what was	stored on it when the 
        power is switched off.
	</P
></DD
><DT
><B
>account</B
></DT
><DD
><P
>	A Unix system gives users <I
CLASS="GLOSSTERM"
>accounts</I
>.  It 
	gives them a username and a password with which to log on to the 
	account.  A home directory in which to store files is usually 
	provided, and permissions to access hardware and software.  These 
	things taken as a whole are an <I
CLASS="GLOSSTERM"
>account</I
>.
	</P
></DD
><DT
><B
>application program</B
></DT
><DD
><P
>	Software that does something useful.  The results of using an
	application program is what the computer was bought for.  
	See also system program, operating system.
	</P
></DD
><DT
><B
>bad block</B
></DT
><DD
><P
>	A block (usually one sector on a disk) that cannot reliably hold 
	data.
	</P
></DD
><DT
><B
>bad sector</B
></DT
><DD
><P
>	Similar to <I
CLASS="GLOSSTERM"
>bad block</I
> but more precise in 
	the case where a block and a sector may be of differing sizes.
	</P
></DD
><DT
><B
>boot sector</B
></DT
><DD
><P
>	Usually the first sector on any given partition.  It contains 
	a very short program (on the order of a few hundred bytes) which 
	will load and start running the operating system proper.
	</P
></DD
><DT
><B
>booting</B
></DT
><DD
><P
>	Everything that happens between the time the computer is 
	switched on and it is ready to accept commands/input from 
	the user is known as <I
CLASS="GLOSSTERM"
>booting</I
>.
	</P
></DD
><DT
><B
>bootstrap loader</B
></DT
><DD
><P
>	A very small program (usually residing in ROM) which reads 
	a fixed location on a disk (eg. the <I
CLASS="GLOSSTERM"
>MBR</I
>)
	and passes control over to it.  The data residing on that fixed 
	location is, in general, slightly bigger and more sophisticated, 
	and it then takes responsibility for loading the actual operating 
	system and passing control to it.
	</P
></DD
><DT
><B
>cylinder</B
></DT
><DD
><P
>	The set of <I
CLASS="GLOSSTERM"
>tracks</I
> on a multi-headed disk 
	that may be accessed without head movement.  In other words the 
	tracks which are the same distance from the spindle about which 
	the disk <I
CLASS="GLOSSTERM"
>platters</I
> rotate.  Placing data 
	that is more likely to be accessed at the same time on the same 
	cylinder can reduce the access time significantly as moving the 
	read-write heads is slow compared to the speed with which the 
	disks rotate.
	</P
></DD
><DT
><B
>daemon</B
></DT
><DD
><P
>	A process lurking in the background, usually unnoticed, until
	something triggers it into action.  For example, the 
	<B
CLASS="COMMAND"
>update</B
>
	daemon wakes up every thirty seconds or so to flush the buffer
	cache, and the <B
CLASS="COMMAND"
>sendmail</B
> daemon awakes whenever 
	someone sends mail.
	</P
></DD
><DT
><B
>daylight savings time</B
></DT
><DD
><P
>	A time of the year during which clocks are set forward one hour.
	Widely used around the world in summer so that evenings have more
	daylight than they would otherwise.
	</P
></DD
><DT
><B
>disk controller</B
></DT
><DD
><P
>	A hardware circuit which translates instructions about disk access 
	from the operating system to the physical disk.  This provides a 
	layer of abstraction that means that an operating system does not 
	need to know how to talk to the many different types of disks, but 
	only needs to know about the (comparatively low) number of types of 
	disk controller.  Common disk controller types are IDE and SCSI.
	</P
></DD
><DT
><B
>emergency boot floppy</B
></DT
><DD
><P
>	A floppy disk which can be used to boot the system even 
	if the hard disk has suffered damage on its filesystem.  
	Most linux distributions offer to make one of these during 
	installation, this is highly recommended.  If your Linux 
	distribution does not offer this facility then read the
	Boot floppy HOWTO, available at the LDP (**Find URL to cite**).
	</P
></DD
><DT
><B
>fibre channel</B
></DT
><DD
><P
>	A high speed networking protocol primarily used in Storage
	Area Networks.  Unlike it's name suggests, fibre channel can be 
	ran over fiber optic, or copper cables.
	</P
></DD
><DT
><B
>filesystem</B
></DT
><DD
><P
>	A term which is used for two purposes and which can have two 
	subtly different meanings.  It is either the collection of 
	files and directories on a drive (whether hard drive, floppy,
	Cd-ROM, etc).  Or it is the markers put onto the disk media 
	which the OS uses to decide where to write files to (inodes, 
	blocks, superblocks etc).  The actual meaning can almost 
	always be inferred from context.
	</P
></DD
><DT
><B
>formatting</B
></DT
><DD
><P
>	Strictly, formatting is organizing and marking the surface of 
	a disk into <I
CLASS="GLOSSTERM"
>tracks</I
>, <I
CLASS="GLOSSTERM"
>sectors
	</I
>, and <I
CLASS="GLOSSTERM"
>cylinders</I
>.  It is also
	sometimes (incorrectly)	a term used to signify the action of 
	writing a <I
CLASS="GLOSSTERM"
>filesystem</I
> to a disk (especially
	in the MS Windows/MS DOS world).
	</P
></DD
><DT
><B
>fragmented</B
></DT
><DD
><P
>	When a file is not written to a disk in contiguous <I
CLASS="GLOSSTERM"
>	blocks</I
>.  If there is not enough free space to write
	a full file to a disk in one continuous stream of <I
CLASS="GLOSSTERM"
>	blocks</I
> then the file gets split up between two or 
	more parts of the disk surface.  This is known as <I
CLASS="GLOSSTERM"
>	fragmenting</I
> and can make the time for loading a 
	file longer as the disk has to seek for the rest of the file.
	</P
></DD
><DT
><B
>full backup</B
></DT
><DD
><P
>	Taking a copy of the whole filesystem to a backup media 
	(eg tape, floppy, or CD).
	</P
></DD
><DT
><B
>geometry</B
></DT
><DD
><P
>	How many cylinders, sectors per cylinder and heads a disk 
	drive has.
	</P
></DD
><DT
><B
>high level formatting</B
></DT
><DD
><P
>	An incorrect term for writing a filesystem to a disk.  Often 
	used in the MS Windows and MS DOS world.
	</P
></DD
><DT
><B
>incremental backups</B
></DT
><DD
><P
>	A backup of what has changed in a filesystem since the last 
	<I
CLASS="GLOSSTERM"
>full backup</I
>.  <I
CLASS="GLOSSTERM"
>Incremental
	backups</I
> if used sensibly as part of a backup regime, 
	can save a lot of time and effort in maintaining a backup of data.
	</P
></DD
><DT
><B
>inode</B
></DT
><DD
><P
>	A data structure holding information about files in a Unix 
	file system.  There is an inode for each file and a file is
	uniquely identified by the file system on which it resides 
	and its inode number on that system.  Each inode contains 
	the following information: the device where the inode resides, 
	locking information, mode and type of file, the number of links
	to the file, the owner's user and group ids, the number of bytes 
	in the file, access and modification times, the time the inode 
	itself was last modified and the addresses of the file's 
	blocks on disk.  A Unix directory is an association between 
	file leafnames and inode numbers.  A file's inode number 
	can be found using the "-i" switch to ls.
	</P
></DD
><DT
><B
>iSCSI</B
></DT
><DD
><P
>	A network storage protocol that enables the sending of SCSI commands
	over a TCP/IP network.  Primarily used in Storage Area Networks.
	</P
></DD
><DT
><B
>kernel</B
></DT
><DD
><P
>	Part of an operating system that implements the interaction with
	hardware and the sharing of resources.  See also system program.
	</P
></DD
><DT
><B
>local time</B
></DT
><DD
><P
>	The official time in a local region (adjusted for location around 
	the Earth); established by law or custom.
	</P
></DD
><DT
><B
>logical partition</B
></DT
><DD
><P
>	A partition inside an <I
CLASS="GLOSSTERM"
>extended partition</I
>, 
	which is ``logical'' in that it does not exist in reality,
	but only inside the logical structure of the software.
	</P
></DD
><DT
><B
>logical volume manager (LVM)</B
></DT
><DD
><P
>	A collection of programs that allow larger physical
	disks to be reassembled into "logical" disks that can be shrunk or 
	expanded as data needs change.
        </P
></DD
><DT
><B
>low level formatting</B
></DT
><DD
><P
>	Synonymous with <I
CLASS="GLOSSTERM"
>formatting</I
> and used in 
	the MS DOS world so differentiate from creating a filesystem 
	which is also known as formatting sometimes.
	</P
></DD
><DT
><B
>mail transfer agent</B
></DT
><DD
><P
>	(MTA) The program responsible for delivering e-mail messages.  
	Upon receiving a message from a <I
CLASS="GLOSSTERM"
>mail user agent
	</I
> or another MTA it stores it temporarily locally 
	and analyzes the recipients and either delivers it (local 
	addressee) or forwards it to another MTA.  In either case 
	it may edit and/or add to the message headers.  A widely used 
	MTA for Unix is sendmail.
	</P
></DD
><DT
><B
>mail user agent</B
></DT
><DD
><P
>	(MUA) The program that allows the user to compose and read 
	electronic mail messages.  The MUA provides the interface 
	between the user and the <I
CLASS="GLOSSTERM"
>mail transfer agent
	</I
>.  Outgoing mail is eventually handed over to an 
	MTA for delivery while the incoming messages are picked up 
	from where the MTA left it (although MUAs running on 
	single-user machines may pick up mail using POP).  
	Examples of MUAs are pine, elm and mutt.
	</P
></DD
><DT
><B
>master boot record</B
></DT
><DD
><P
>	(MBR) The first logical sector on a disk, this is (usually) 
	where the BIOS looks to load a small program that will boot 
	the computer.
	</P
></DD
><DT
><B
>network file system</B
></DT
><DD
><P
>	(NFS) A protocol developed by Sun Microsystems, and defined in 
	RFC 1094 (FIND URL), which allows a computer to access files 
	over a network as if they were on its local disks.
	</P
></DD
><DT
><B
>operating system</B
></DT
><DD
><P
>	Software that shares a computer system's resources (processor,
	memory, disk space, network bandwidth, and so on) between
	users and the application programs they run.  Controls access
	to the system to provide security.  See also kernel, system program,
	application program.
	</P
></DD
><DT
><B
>partition</B
></DT
><DD
><P
>	A logical section of a disk.  Each partition normally has its 
	own file system.  Unix tends to treat partitions as though 
	they were separate physical entities.
	</P
></DD
><DT
><B
>password file</B
></DT
><DD
><P
>	A file that holds usernames and information about their accounts 
	like their password.  On Unix systems this file is usually 
	<TT
CLASS="FILENAME"
>/etc/passwd</TT
>.  On most modern Linux systems 
	the <TT
CLASS="FILENAME"
>/etc/passwd</TT
> file does not actually hold 
	password data.  That tends to be held in a different file <TT
CLASS="FILENAME"
>	/etc/shadow</TT
> for security reasons.  See manual pages 
	passwd(5) and shadow(5)	for more information.
	</P
></DD
><DT
><B
>physical extents</B
></DT
><DD
><P
>	A term used to describe a the chunks a physical volume is broken
	down into when using the Logical Volume Manager.
	</P
></DD
><DT
><B
>physical volume</B
></DT
><DD
><P
>	A term used an actual disk partition, usually in reference to the 
	logical volume manager.
	</P
></DD
><DT
><B
>platters</B
></DT
><DD
><P
>	A physical disk inside a hard drive.  Usually a hard drive is 
	made up of multiple physical disks stacked up on top of each 
	other.  One individual disk is known as a <I
CLASS="GLOSSTERM"
>platter
	</I
>.
	</P
></DD
><DT
><B
>power on self test</B
></DT
><DD
><P
>	(POST) A series of diagnostic tests which are run when a computer 
	is powered on.  Typically this might include testing the memory, 
	testing that the hardware configuration is the same as the last
	saved configuration, checking that any floppy drives, or hard 
	drives which are known about by the BIOS are installed and working.
	</P
></DD
><DT
><B
>print queue</B
></DT
><DD
><P
>	A file (or set of files) which the print <I
CLASS="GLOSSTERM"
>daemon
	</I
><I
CLASS="GLOSSTERM"
> uses so that applications which wish to use the 
	printer do not have to wait until the print job they have sent 
	is finished before they can continue.  It also allows multiple 
	users to share a printer.
	</I
></P
></DD
><DT
><B
>read-write head</B
></DT
><DD
><P
>	A tiny electromagnetic coil and metal pole used to write and read 
	magnetic patterns on a disk.  These coils move laterally against 
	the rotary motion on the <I
CLASS="GLOSSTERM"
>platters</I
>.
	</P
></DD
><DT
><B
>root filesystem</B
></DT
><DD
><P
>	The parent of all the other filesystems mounted in a Unix filesystem 
	tree.  Mounted as / it might have other filesystems mounted on it 
	(/usr for example).  If the root filesystem cannot be mounted then the 
	<I
CLASS="GLOSSTERM"
>kernel</I
> will panic and the system will not be 
	able to continue <I
CLASS="GLOSSTERM"
>booting</I
>
	</P
></DD
><DT
><B
>run level</B
></DT
><DD
><P
>	Linux has up to 10 runlevels (0-9) available (of which usually only 
	the first 7 are defined).  Each runlevel may start a different set 
	of services, giving multiple different configurations in the same 
	system.  Runlevel 0 is defined as ``system halt'', runlevel 1 is 
	defined as ``<I
CLASS="GLOSSTERM"
>single user mode</I
>'', and runlevel 
	6 is defined as ``reboot system''.  The remaining runlevels can, 
	theoretically, be defined by the system administrator in any way.  
	However most distributions provide some other predefined runlevels.  
	For example, runlevel 2 might be defined as ``multi-user console'', 
	and runlevel 5 as ``multi-user X-Window system''.  These definitions 
	vary considerably from distribution to distribution, so please check 
	the documentation for your own distribution.
	</P
></DD
><DT
><B
>sectors</B
></DT
><DD
><P
>	The minimum <I
CLASS="GLOSSTERM"
>track</I
> length that can be 
allocated 
	to store data.  This is usually	(but not always) 512 bytes.
	</P
></DD
><DT
><B
>shadow passwords</B
></DT
><DD
><P
>	Because the <I
CLASS="GLOSSTERM"
>password file</I
> on Unix systems 
often 
	needs to be world readable it usually does not actually contain the 
	encrypted passwords for users' accounts.  Instead a shadow file	is 
	employed (which is not world readable) which holds the encrypted 
	passwords for users' accounts.
	</P
></DD
><DT
><B
>single user mode</B
></DT
><DD
><P
>	Usually runlevel 1.  A runlevel where logins are not allowed except 
	by the root account.  Used either for system repairs (if the 
	filesystem is partially damaged it may still be possible to boot into
	runlevel 1 and repair it), or for moving filesystems around between 
	partitions.  These are just two examples.  Any task that requires a 
	system where only one person can write to a disk at a time is a 
	candidate for requiring runlevel 1.
	</P
></DD
><DT
><B
>spool</B
></DT
><DD
><P
>	To send a file (or other data) to a queue.  Generally used in 
	conjunction with printers, but might also be used for other 
	things (mail for example).  The term is reported to be an acronym 
	for ``Simultaneous Peripheral Operation On-Line'', but according 
	to the <A
HREF="http://www.tuxedo.org/~esr/jargon"
TARGET="_top"
>Jargon File
	</A
> it may	have been a backronym (something made up later 
	for effect).
	</P
></DD
><DT
><B
>system call</B
></DT
><DD
><P
>	The services provided by the kernel to application programs,
	and the way in which they are invoked.  See section 2 of the
	manual pages.
	</P
></DD
><DT
><B
>swap space</B
></DT
><DD
><P
>	Space on a disk in which the system can write portions of memory 
	to.  Usually this is a dedicated partition, but it may also be 
	a swapfile.
	</P
></DD
><DT
><B
>system program</B
></DT
><DD
><P
>	Programs that implement high level functionality of an operating
	system, i.e., things that aren't directly dependent on the
	hardware.  May sometimes require special privileges to run
	(e.g., for delivering electronic mail), but often just commonly
	thought of as part of the system (e.g., a compiler).  See also
	application program, kernel, operating system.
	</P
></DD
><DT
><B
>time drift</B
></DT
><DD
><P
>	This is a term for a computers inaccuracy at keeping track of time. 
	All computers have some rate of error when keeping time.  With newer
	computers this rate of error is extremely small.</P
></DD
><DT
><B
>track</B
></DT
><DD
><P
>	The part of a disk <I
CLASS="GLOSSTERM"
>platter</I
> which passes 
	under one <I
CLASS="GLOSSTERM"
>read-write head</I
> while the head 
	is stationary but the disk is spinning.  Each track is divided 
	into <I
CLASS="GLOSSTERM"
>sectors</I
>, and a vertical collection of 
	tracks is a <I
CLASS="GLOSSTERM"
>cylinder</I
>
	</P
></DD
><DT
><B
>volume group</B
></DT
><DD
><P
>	A collection of physical volumes broken down into physical 
	extents, and available for use in logical partitions.
        </P
></DD
></DL
></DIV
><DIV
CLASS="INDEX"
><HR><H1
><A
NAME="BOOKINDEX"
></A
>Index-Draft</H1
><DIV
CLASS="INDEXDIV"
><H2
CLASS="INDEXDIV"
><A
NAME="AEN5152"
></A
>A</H2
><DL
><DT
>at 	,
    <A
HREF="#CRON"
>Periodic command execution: cron and at</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5157"
></A
>B</H2
><DL
><DT
>BIOS,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>,
    <A
HREF="#PART-HD"
>Partitioning a hard disk</A
>
  </DT
><DT
>booting
  </DT
><DD
><DL
><DT
>vmlinuz,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5168"
></A
>C</H2
><DL
><DT
>CMOS,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DT
>commands
  </DT
><DD
><DL
><DT
>badblocks,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>cfdisk,
    <A
HREF="#PART-HD"
>Partitioning a hard disk</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>chsh,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>depmod,
    <A
HREF="#AEN1955"
>depmod</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>df,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>fdformat,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>fdisk,
    <A
HREF="#MBR"
>The MBR, boot sectors and partition table</A
>,
    <A
HREF="#PART-TYPES"
>Partition types</A
>,
    <A
HREF="#PART-HD"
>Partitioning a hard disk</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>file,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>fips,
    <A
HREF="#PART-HD"
>Partitioning a hard disk</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>free,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>fsck,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>ftpd,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>getty,
    <A
HREF="#INIT"
>init</A
>,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>gzexe,
    <A
HREF="#SPACE-SAVING-TIPS"
>Tips for saving disk space</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>gzip,
    <A
HREF="#SPACE-SAVING-TIPS"
>Tips for saving disk space</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>hdparm,
    <A
HREF="#HDPARM"
>The hdparm  command</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>init,
    <A
HREF="#INIT"
>init</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>insmod,
    <A
HREF="#AEN1944"
>insmod</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>login,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>losetup,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>lpr,
    <A
HREF="#BLOCK-CHAR-DEV"
>Two kinds of devices</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>ls,
    <A
HREF="#BLOCK-CHAR-DEV"
>Two kinds of devices</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>lsdev,
    <A
HREF="#LSDEV"
>The lsdev  command</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>lsmod,
    <A
HREF="#AEN1933"
>lsmod</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>lspci,
    <A
HREF="#LSPCI"
>The lspci  command</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>lsraid,
    <A
HREF="#LSRAID"
>The lsraid  command</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>lsusb,
    <A
HREF="#LSUSB"
>The lsusb  command</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>MAKEDEV,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>,
    <A
HREF="#MAKEDEV"
>The MAKEDEV Script</A
>,
    <A
HREF="#MKNOD"
>The mknod command</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>man,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>mkfs,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>mknod,
    <A
HREF="#MKNOD"
>The mknod command</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>modprobe,
    <A
HREF="#AEN1977"
>modprobe</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>mount,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>parted,
    <A
HREF="#PART-HD"
>Partitioning a hard disk</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>rmmod,
    <A
HREF="#AEN1966"
>rmmod</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>setfdparm,
    <A
HREF="#FLOPPIES"
>Floppies</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>setfdprm,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>su,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>sudo,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>swapon,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>syslog,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>zip,
    <A
HREF="#SPACE-SAVING-TIPS"
>Tips for saving disk space</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>Common Internet File System (CIFS),
    <A
HREF="#NFS"
>Network file systems</A
>,
    <A
HREF="#NET-ATTACHED"
>Network Attached Storage - Draft</A
>,
    <A
HREF="#CIFS"
>CIFS</A
>
  </DT
><DT
>cron,
    <A
HREF="#CRON"
>Periodic command execution: cron and at</A
>
  </DT
><DD
><DL
><DT
>crontab 	,
    <A
HREF="#CRON"
>Periodic command execution: cron and at</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5278"
></A
>D</H2
><DL
><DT
>devices
  </DT
><DD
><DL
><DT
>block,
    <A
HREF="#BLOCK-CHAR-DEV"
>Two kinds of devices</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>character,
    <A
HREF="#BLOCK-CHAR-DEV"
>Two kinds of devices</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>disks,
    <A
HREF="#DISK-USAGE"
>Using Disks and Other Storage Media</A
>
  </DT
><DD
><DL
><DT
>bad blocks,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>bad sectors,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>boot sectors,
    <A
HREF="#MBR"
>The MBR, boot sectors and partition table</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>changing partition size,
    <A
HREF="#PART-HD"
>Partitioning a hard disk</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>components,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>cylinders,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>extended partition,
    <A
HREF="#EXTENDED-LOGICAL-PART"
>Extended and logical partitions</A
>,
    <A
HREF="#DEV-FILES-PARTS"
>Device files and partitions</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>filesystem,
    <A
HREF="#FS-INTRO"
>What are filesystems?</A
>
  </DT
><DD
><DL
><DT
>data block,
    <A
HREF="#FS-INTRO"
>What are filesystems?</A
>
  </DT
><DT
>directory block,
    <A
HREF="#FS-INTRO"
>What are filesystems?</A
>
  </DT
><DT
>indirection block,
    <A
HREF="#FS-INTRO"
>What are filesystems?</A
>
  </DT
><DT
>inode,
    <A
HREF="#FS-INTRO"
>What are filesystems?</A
>
  </DT
><DT
>superblock,
    <A
HREF="#FS-INTRO"
>What are filesystems?</A
>
  </DT
></DL
></DD
><DT
>formatting,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
><DD
><DL
><DT
>high-level,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
><DT
>low-level,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
></DL
></DD
><DT
>geometry,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>IDE,
    <A
HREF="#PART-HD"
>Partitioning a hard disk</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>Logical Block Addressing (LBA),
    <A
HREF="#PART-HD"
>Partitioning a hard disk</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>MBR,
    <A
HREF="#MBR"
>The MBR, boot sectors and partition table</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>partition table,
    <A
HREF="#MBR"
>The MBR, boot sectors and partition table</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>partition type,
    <A
HREF="#PART-TYPES"
>Partition types</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>partitions,
    <A
HREF="#PARTITIONS"
>Partitions</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>saving space,
    <A
HREF="#SPACE-SAVING-TIPS"
>Tips for saving disk space</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>sectors,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>tracks,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5342"
></A
>E</H2
><DL
><DT
>email,
    <A
HREF="#MAIL"
>Mail</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5347"
></A
>F</H2
><DL
><DT
>fibre channel,
    <A
HREF="#SAN"
>Storage Area Networks - Draft</A
>
  </DT
><DT
>filesystem,
    <A
HREF="#FS-LAYOUT"
>The filesystem layout</A
>,
    <A
HREF="#USR-FS"
>The /usr filesystem.</A
>
  </DT
><DD
><DL
><DT
>/ (root),
    <A
HREF="#FS-BACKGROUND"
>Background</A
>,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>/bin,
    <A
HREF="#FS-LAYOUT"
>The filesystem layout</A
>,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>/boot,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>/dev,
    <A
HREF="#FS-LAYOUT"
>The filesystem layout</A
>,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>,
    <A
HREF="#BLOCK-CHAR-DEV"
>Two kinds of devices</A
>
  </DT
><DD
><DL
><DT
>/dev/dsp,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/fb0,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/fd0,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>,
    <A
HREF="#FLOPPIES"
>Floppies</A
>,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
><DT
>/dev/fd1,
    <A
HREF="#FLOPPIES"
>Floppies</A
>
  </DT
><DT
>/dev/hda,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DT
>/dev/hdb,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DT
>/dev/hdc,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DT
>/dev/hdc9,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/hdd,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DT
>/dev/ht0,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/js0,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/loop0,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/lp0,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/md0,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/mixer,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/null,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/parport0,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/pcd0,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/pda,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/pdb,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/pdc,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/pdd,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/psaux,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/pt0,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/pt1,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/random,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/sda,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>,
    <A
HREF="#BLOCK-CHAR-DEV"
>Two kinds of devices</A
>,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DT
>/dev/sdb,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DT
>/dev/sdd,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/ttyS0,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>,
    <A
HREF="#MAKEDEV"
>The MAKEDEV Script</A
>,
    <A
HREF="#MKNOD"
>The mknod command</A
>
  </DT
><DT
>/dev/urandom,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
><DT
>/dev/zero,
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
></DL
></DD
><DT
>/etc,
    <A
HREF="#FS-LAYOUT"
>The filesystem layout</A
>,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DD
><DL
><DT
>/etc/bash.rc,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/csh.cshrc,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/fdprm,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>,
    <A
HREF="#FLOPPIES"
>Floppies</A
>
  </DT
><DT
>/etc/fstab,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/group,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/inittab,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/issue,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/login.defs,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/magic,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/motd,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/mtab,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/passwd,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/printcap,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/profile,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/rc.d,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/securetty,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/shadow,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/shells,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DT
>/etc/termcap,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
></DL
></DD
><DT
>/home,
    <A
HREF="#FS-LAYOUT"
>The filesystem layout</A
>,
    <A
HREF="#FS-BACKGROUND"
>Background</A
>,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>/lib,
    <A
HREF="#FS-LAYOUT"
>The filesystem layout</A
>,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>/lib/modules,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>/mnt,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>/proc,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DD
><DL
><DT
>/proc/1,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/cpuinfo,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/devices,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/dma,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/filesystems,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/interrupts,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/ioports,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/kcore,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DT
>/proc/kmsg,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/ksyms,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/loadavg,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/meminfo,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/modules,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/net,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/self,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/stat,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/uptime,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
><DT
>/proc/version,
    <A
HREF="#PROC-FS"
>The /proc filesystem</A
>
  </DT
></DL
></DD
><DT
>/root,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>/sbin,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>/tmp,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>/usr,
    <A
HREF="#FS-LAYOUT"
>The filesystem layout</A
>,
    <A
HREF="#FS-BACKGROUND"
>Background</A
>,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>
  </DT
><DD
><DL
><DT
>/usr/bin,
    <A
HREF="#USR-FS"
>The /usr filesystem.</A
>
  </DT
><DT
>/usr/include,
    <A
HREF="#USR-FS"
>The /usr filesystem.</A
>
  </DT
><DT
>/usr/lib,
    <A
HREF="#USR-FS"
>The /usr filesystem.</A
>
  </DT
><DT
>/usr/local,
    <A
HREF="#USR-FS"
>The /usr filesystem.</A
>,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/usr/sbin,
    <A
HREF="#USR-FS"
>The /usr filesystem.</A
>
  </DT
><DT
>/usr/share/doc,
    <A
HREF="#USR-FS"
>The /usr filesystem.</A
>
  </DT
><DT
>/usr/share/info,
    <A
HREF="#USR-FS"
>The /usr filesystem.</A
>
  </DT
><DT
>/usr/share/man,
    <A
HREF="#USR-FS"
>The /usr filesystem.</A
>
  </DT
><DT
>/usr/share/man/cat,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/usr/share/man/man,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/usr/X11R6,
    <A
HREF="#USR-FS"
>The /usr filesystem.</A
>
  </DT
></DL
></DD
><DT
>/var,
    <A
HREF="#FS-LAYOUT"
>The filesystem layout</A
>,
    <A
HREF="#FS-BACKGROUND"
>Background</A
>,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DD
><DL
><DT
>/var/cache/man,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/games,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/lib,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/local,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/lock,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/log,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/log/messages,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/log/wtmp,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/mail,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/run,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/spool,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/spool/mail,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/spool/news,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/tmp,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DT
>/var/utmp,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
></DL
></DD
></DL
></DD
><DT
>Filesystem Hierarchy Standard (FHS)         ,
    <A
HREF="#FS-LAYOUT"
>The filesystem layout</A
>,
    <A
HREF="#DIR-TREE-OVERVIEW"
>Overview of the Directory Tree</A
>,
    <A
HREF="#FS-BACKGROUND"
>Background</A
>
  </DT
><DT
>filesystem types
  </DT
><DD
><DL
><DT
>ext,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>ext2,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>,
    <A
HREF="#FS-COMPARE"
>Filesystem comparison</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>ext3,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>,
    <A
HREF="#FS-COMPARE"
>Filesystem comparison</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>fat16,
    <A
HREF="#FS-COMPARE"
>Filesystem comparison</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>fat32,
    <A
HREF="#FS-COMPARE"
>Filesystem comparison</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>hfs+,
    <A
HREF="#FS-COMPARE"
>Filesystem comparison</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>hpfs,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>,
    <A
HREF="#FS-COMPARE"
>Filesystem comparison</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>iso9660,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>jfs,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>,
    <A
HREF="#FS-COMPARE"
>Filesystem comparison</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>minix,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>msdos,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>nfs,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>ntfs,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>,
    <A
HREF="#FS-COMPARE"
>Filesystem comparison</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>reiserfs,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>,
    <A
HREF="#FS-COMPARE"
>Filesystem comparison</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>smbfs,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>sysv,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>ufs2,
    <A
HREF="#FS-COMPARE"
>Filesystem comparison</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>umsdos,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>vfat,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>vxfs,
    <A
HREF="#FS-COMPARE"
>Filesystem comparison</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>xfs,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>xia,
    <A
HREF="#FS-GALORE"
>Filesystems galore</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>zfs,
    <A
HREF="#FS-COMPARE"
>Filesystem comparison</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>filesystems
  </DT
><DD
><DL
><DT
>/etc
  </DT
><DD
><DL
><DT
>/etc/fstab,
    <A
HREF="#ADDING-DISK"
>Adding more disk space for Linux</A
>
  </DT
></DL
></DD
></DL
></DD
><DT
>Free Software Foundation,
    <A
HREF="#GNU-OR-NOT"
>Linux or GNU/Linux, that is the question.</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5675"
></A
>G</H2
><DL
><DT
>getty,
    <A
HREF="#TERMINAL-LOGINS"
>Logins from terminals</A
>,
    <A
HREF="#NETWORK-LOGINS"
>Network logins</A
>
  </DT
><DT
>GNOME,
    <A
HREF="#GUI"
>Graphical user interface</A
>
  </DT
><DT
>GRUB 		,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>
  </DT
><DT
>GUI,
    <A
HREF="#INIT"
>init</A
>,
    <A
HREF="#GUI"
>Graphical user interface</A
>
  </DT
><DD
><DL
><DT
>blackbox,
    <A
HREF="#GUI"
>Graphical user interface</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>fvwm,
    <A
HREF="#GUI"
>Graphical user interface</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>icewm,
    <A
HREF="#GUI"
>Graphical user interface</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>windowmaker 	,
    <A
HREF="#GUI"
>Graphical user interface</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>X Windows,
    <A
HREF="#GUI"
>Graphical user interface</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5701"
></A
>H</H2
><DL
><DT
>hardware
  </DT
><DD
><DL
><DT
>CD-ROM,
    <A
HREF="#CDROM"
>CD-ROMs</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>Central Processing Unit (CPU),
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>disk controller,
    <A
HREF="#HARD-DISK"
>Hard disks</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>fibre channel,
    <A
HREF="#SAN"
>Storage Area Networks - Draft</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>floppy disk,
    <A
HREF="#FLOPPIES"
>Floppies</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>tape drive,
    <A
HREF="#TAPES"
>Tapes</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5717"
></A
>I</H2
><DL
><DT
>init,
    <A
HREF="#INIT"
>init</A
>,
    <A
HREF="#TERMINAL-LOGINS"
>Logins from terminals</A
>
  </DT
><DT
>inittab,
    <A
HREF="#INIT"
>init</A
>
  </DT
><DT
>iSCSI,
    <A
HREF="#SAN"
>Storage Area Networks - Draft</A
>
  </DT
><DT
>ISO 9660,
    <A
HREF="#CDROM"
>CD-ROMs</A
>
  </DT
><DD
><DL
><DT
>Rock Ridge extensions,
    <A
HREF="#CDROM"
>CD-ROMs</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5734"
></A
>K</H2
><DL
><DT
>KDE,
    <A
HREF="#GUI"
>Graphical user interface</A
>
  </DT
><DT
>kernel
  </DT
><DD
><DL
><DT
>devices,
    <A
HREF="#DEVICE-LIST"
>Hardware, Devices, and Tools</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>documentation
  </DT
><DD
><DL
><DT
>devices.txt,
    <A
HREF="#MKNOD"
>The mknod command</A
>
  </DT
></DL
></DD
><DT
>driver,
    <A
HREF="#KERNEL-PARTS"
>Important parts of the kernel</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>memory management,
    <A
HREF="#KERNEL-PARTS"
>Important parts of the kernel</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>modules,
    <A
HREF="#AEN1926"
>Kernel Modules</A
>
  </DT
><DD
><DL
><DT
>depmod,
    <A
HREF="#AEN1955"
>depmod</A
>
  </DT
><DT
>insmod,
    <A
HREF="#AEN1944"
>insmod</A
>
  </DT
><DT
>lsmod,
    <A
HREF="#AEN1933"
>lsmod</A
>
  </DT
><DT
>modprobe,
    <A
HREF="#AEN1977"
>modprobe</A
>
  </DT
><DT
>rmmod,
    <A
HREF="#AEN1966"
>rmmod</A
>
  </DT
></DL
></DD
><DT
>NFS,
    <A
HREF="#NFS"
>Network file systems</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>overview,
    <A
HREF="#VARIOUS-PARTS"
>Various parts of an operating system</A
>,
    <A
HREF="#KERNEL-PARTS"
>Important parts of the kernel</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>	process management,
    <A
HREF="#KERNEL-PARTS"
>Important parts of the kernel</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>virtual 	filesystem (VFS),
    <A
HREF="#KERNEL-PARTS"
>Important parts of the kernel</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5771"
></A
>L</H2
><DL
><DT
>LILO,
    <A
HREF="#ROOT-FS"
>The root filesystem</A
>,
    <A
HREF="#PART-HD"
>Partitioning a hard disk</A
>
  </DT
><DT
>Linux
  </DT
><DD
><DL
><DT
>Distributions,
    <A
HREF="#INTRO"
>Introduction</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>GNU 	,
    <A
HREF="#GNU-OR-NOT"
>Linux or GNU/Linux, that is the question.</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>logging in,
    <A
HREF="#NETWORK-LOGINS"
>Network logins</A
>
  </DT
><DT
>login,
    <A
HREF="#TERMINAL-LOGINS"
>Logins from terminals</A
>
  </DT
><DT
>logs
  </DT
><DD
><DL
><DT
>/var/log/messages,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>,
    <A
HREF="#FORMATTING"
>Formatting</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>/var/log/wtmp,
    <A
HREF="#VAR-FS"
>The /var filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5796"
></A
>M</H2
><DL
><DT
>mail transfer agent (MTA) 	,
    <A
HREF="#MAIL"
>Mail</A
>
  </DT
><DD
><DL
><DT
>postfix,
    <A
HREF="#MAIL"
>Mail</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>sendmail,
    <A
HREF="#MAIL"
>Mail</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>mail user agent,
    <A
HREF="#MAIL"
>Mail</A
>
  </DT
><DD
><DL
><DT
>evolution,
    <A
HREF="#MAIL"
>Mail</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>pine,
    <A
HREF="#MAIL"
>Mail</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5812"
></A
>N</H2
><DL
><DT
>Network Attached Storage (NAS),
    <A
HREF="#NET-ATTACHED"
>Network Attached Storage - Draft</A
>
  </DT
><DT
>Network File System (NFS),
    <A
HREF="#NFS"
>Network file systems</A
>,
    <A
HREF="#FS-BACKGROUND"
>Background</A
>,
    <A
HREF="#NET-ATTACHED"
>Network Attached Storage - Draft</A
>,
    <A
HREF="#NET-FILE-SYS"
>NFS</A
>
  </DT
><DT
>networking,
    <A
HREF="#NETWORKING"
>Networking</A
>
  </DT
><DD
><DL
><DT
>Network  	Admin Guide (NAG),
    <A
HREF="#NETWORKING"
>Networking</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5828"
></A
>O</H2
><DL
><DT
>Open Sound System (OSS),
    <A
HREF="#DEV-FS"
>The /dev directory</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5833"
></A
>P</H2
><DL
><DT
>partition types
  </DT
><DD
><DL
><DT
>AIX,
    <A
HREF="#PART-TYPES"
>Partition types</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>FAT16,
    <A
HREF="#PART-TYPES"
>Partition types</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>FAT32,
    <A
HREF="#PART-TYPES"
>Partition types</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>FreeBSD,
    <A
HREF="#PART-TYPES"
>Partition types</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>HPFS,
    <A
HREF="#PART-TYPES"
>Partition types</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>Linux,
    <A
HREF="#PART-TYPES"
>Partition types</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>Linux LVM,
    <A
HREF="#PART-TYPES"
>Partition types</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>Linux Swap,
    <A
HREF="#PART-TYPES"
>Partition types</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>Minix,
    <A
HREF="#PART-TYPES"
>Partition types</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>NetBSD,
    <A
HREF="#PART-TYPES"
>Partition types</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>NTFS,
    <A
HREF="#PART-TYPES"
>Partition types</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>printing,
    <A
HREF="#PRINTING"
>Printing</A
>
  </DT
><DD
><DL
><DT
>queue,
    <A
HREF="#PRINTING"
>Printing</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>spools,
    <A
HREF="#PRINTING"
>Printing</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5866"
></A
>R</H2
><DL
><DT
>runlevels,
    <A
HREF="#INIT"
>init</A
>
  </DT
><DD
><DL
><DT
>0 - shutdown,
    <A
HREF="#INIT"
>init</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>1 - single user 	,
    <A
HREF="#INIT"
>init</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>1 - single-user,
    <A
HREF="#INIT"
>init</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>3 - multi-user,
    <A
HREF="#INIT"
>init</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>5 - multi-user with GUI 	,
    <A
HREF="#INIT"
>init</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>6 - reboot,
    <A
HREF="#INIT"
>init</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>inittab,
    <A
HREF="#INIT"
>init</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5885"
></A
>S</H2
><DL
><DT
>Samba 	,
    <A
HREF="#NFS"
>Network file systems</A
>,
    <A
HREF="#NET-ATTACHED"
>Network Attached Storage - Draft</A
>,
    <A
HREF="#CIFS"
>CIFS</A
>
  </DT
><DT
>shells
  </DT
><DD
><DL
><DT
>bash - Bourne Again SHell,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>csh - C SHell,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>sh - Bourne,
    <A
HREF="#ETC-FS"
>The /etc directory</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>ssh,
    <A
HREF="#NETWORK-LOGINS"
>Network logins</A
>
  </DT
><DT
>Storage Area Network (SAN),
    <A
HREF="#SAN"
>Storage Area Networks - Draft</A
>,
    <A
HREF="#NET-ATTACHED"
>Network Attached Storage - Draft</A
>
  </DT
><DD
><DL
><DT
>LUN,
    <A
HREF="#SAN"
>Storage Area Networks - Draft</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>syslog 	,
    <A
HREF="#SYSLOG"
>Syslog</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5912"
></A
>T</H2
><DL
><DT
>telnet 	,
    <A
HREF="#NETWORK-LOGINS"
>Network logins</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5917"
></A
>V</H2
><DL
><DT
>VMWare,
    <A
HREF="#CDROM"
>CD-ROMs</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN5922"
></A
>W</H2
><DL
><DT
>WINE,
    <A
HREF="#CDROM"
>CD-ROMs</A
>
  </DT
></DL
></DIV
></DIV
></DIV
></BODY
>
<!-- Mirrored from tldp.org/LDP/sag/html/sag.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 23 Oct 2018 23:50:42 GMT -->
</HTML
>